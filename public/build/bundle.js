
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_options(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            option.selected = ~value.indexOf(option.__value);
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function select_multiple_value(select) {
        return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch$1(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch$1(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch$1(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch$1(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.32.1' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }
    function loop_guard(timeout) {
        const start = Date.now();
        return () => {
            if (Date.now() - start > timeout) {
                throw new Error('Infinite loop detected');
            }
        };
    }

    /* src/components/Header.svelte generated by Svelte v3.32.1 */
    const file = "src/components/Header.svelte";

    function create_fragment(ctx) {
    	let div;
    	let button;
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			img = element("img");
    			if (img.src !== (img_src_value = "images/logo.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			add_location(img, file, 14, 8, 397);
    			attr_dev(button, "class", "link-logo");
    			attr_dev(button, "data-step", "login-step");
    			add_location(button, file, 10, 4, 283);
    			attr_dev(div, "class", "center-block__header");
    			add_location(div, file, 9, 0, 244);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, img);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*goToHome*/ ctx[0]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Header", slots, []);
    	const dispatch = createEventDispatcher();

    	const goToHome = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		goToHome
    	});

    	return [goToHome];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const dateInstance = new Date();
    const currentYear  = dateInstance.getFullYear();

    const translations = {
    	"en": {
    		"inputsErrors" : {
    			"name":"Only letters and whitespace are allowed",
    			"email":"Only without Cyrillic and without spaces",
    			"subject":"Only letters and whitespace are allowed",
    		},
    		"footer" :{
    			"footer_text" : "© Copyright "+currentYear+" by Superfeed. All Rights Reserved.",
    		},
    		"BtnBack" :{
    			"BtnBack_text" : "Back",
    		},
    		"login_step": {
    			"heading" : "Login",
    			"description" : "<p>View your Superfeeds by logging in with <br>Google or LinkedIn. Any CRM that matches.</p>",
    			"login_btn_1_text" : "Continue with</i>",
    			"login_btn_2_text" : "Continue with</i>",
    		},
    		"signup_step": {
    			"heading" : "Sign up",
    			"description" : "<p>Porttitor rhoncus dolor purus enim praesent elementum facilisis leo.</p>",
    			"signup_btn_1_text" : "Continue with</i>",
    			"signup_btn_2_text" : "Continue with</i>",
    		},
    		"welcome_step": {
    			"heading" : "Welcome",
    			"description" : "	<p>Ready to transform the way your community communicates? Just give us 5 minutes. Here’s what we’ll need from you:</p><ol><li>Your name</li> <li>Your community’s name</li><li>Permission to sync to your CRM.</li></ol><p>That’s it! Just click the button below to continue.</p>",
    			"welcome_step_btn" : "LET’S GO",
    		},
    		"personality_step" : {
    			"heading" : "What’s your name?",
    			"description" : "<p class='test'>Maybe you’ll be “just” a customer. Maybe you’ll become my best friend. Either way, let’s get to\n" +
    				"know one another a bit better.</p><br><p>My name’s Nathan. My email is <a href=\"nathan@superfeed.io.\" class=\"link-purple-light\">nathan@superfeed.io.</a><br>My coolest moment ever was when I met The Edge from U2, made a joke and he laughed.</p><h4 class=\"mt-15 mb-15\">What’s your name?</h4>",
    			"personality_step_btn" : "LET’S NAME",
    			"placeholder_1" : "Type your full name...",
    			"placeholder_2" : "Type your email...",
    			"placeholder_3" : "Type your invitation code",
    		},
    		"community_step": {
    			"heading" : "What’s your community’s name?",
    			"description" : "<p>Imagine you're telling someone to go to \"<a href='' class='link-black'>www.superfeed/[something]</a>\" Tell us that something,<br>so we can give your community a unique URL.</p> <h4 class=\"mt-15 mb-15\">After this, we’ll ask to sync CRMs, and then the fun starts!</h4>",
    			"community_step_btn": "LET’S SYNC",
    			"placeholder_1" : "Type your company’s name...",
    			"placeholder_2" : "Type the name of your community...",
    		},
    		"which_crm":{
    			"heading" : "Which CRM do you use?",
    			"description" : "More CRMs coming soon",
    			"which_crm_btn" : "LET’S START",
    		},
    		"set_api_key":{
    			"heading" : "Set API Key",
    			"description" : "<p class=\"text-left mb-15\">1. Go to the <a href=\"doe.com\" class=\"link-black\">doe.com</a> website and create a free account<br>(you will need to confirm your email).<br>2. After that you can find your API key<br>here: <a href=\"https://doe.com/profile#api-key\" class=\"link-black\">https://doe.com/profile#api-key</a>.</p>",
    			"set_api_key_btn" : "SAVE",
    			"placeholder" : "API Key",
    		},
    		"willYouReadThisBlock":{
    			"heading" : "Will you read this?",
    			"description" : "<p class='mb-10'>Ah, the terms & services agreement. So. much. fun.  But our lawyers say that it’s actually quite important, so here we are.</p><p>What about payment you ask? Here’s the deal. You get to use Superfeed for <a href=\"#\" class=\"link-purple\"> 14 days for free</a>. If you like it, then we will ask nicely that you pay. If you don’t like it, then we will keep you in our system and send you annoying updates until you unsubscribe. </p>",
    			"willYouReadThisBlock_btn": "LET’S READ",
    		},
    		"willYouReadThisBlock2":{
    			"heading" : "Will you read this?",
    			"description" : "<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Cras sed felis eget velit aliquet sagittis id consectetur. Eu lobortis elementum nibh tellus molestie nunc non. Aliquam purus sit amet luctus. Purus gravida quis blandit turpis cursus in. Sed turpis tincidunt id aliquet risus feugiat in ante. Porttitor eget dolor morbi non arcu risus. Viverra adipiscing at in tellus integer feugiat scelerisque varius morbi. Ac auctor augue mauris augue neque gravida in fermentum et. Urna molestie at elementum eu facilisis. Purus gravida quis blandit turpis cursus in hac habitasse platea. Massa tincidunt nunc pulvinar sapien et ligula ullamcorper.<br> Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Cras sed felis eget velit aliquet sagittis id consectetur. Eu lobortis elementum nibh tellus molestie nunc non. Aliquam purus sit amet luctus. Purus gravida quis blandit turpis cursus in. Sed turpis tincidunt id aliquet risus feugiat in ante. Porttitor eget dolor morbi non arcu risus. Viverra adipiscing at in tellus integer feugiat scelerisque varius morbi. Ac auctor augue mauris augue neque gravida in fermentum et. Urna molestie at elementum eu facilisis. Purus gravida quis blandit turpis cursus in hac habitasse platea. Massa tincidunt nunc pulvinar sapien et ligula ullamcorper. </p>",
    			"willYouReadThisBlock2_btn": "Accepted",
    		},
    		"shallWeStart":{
    			"heading" : "Phew. Shall we start?",
    			"description" : "<p>Okay. Now that that’s done with, we can actually start.<br />Here’s we’ll ask:</p> <ol><li> What rules determine whether someone<br>is a member of your community</li><li> What fields in your CRM should Superfeed pull<br>to determine the audiences for individual posts</li><li> Who else should receive admin access</li></ol><p class='font-size-16'> Worried that you’ll change your mind later?<br>No worries, you can always edit your preferences later!</p>",
    			"shallWeStart_btn" : "LET’S SET THIS UP",
    		},
    		"createAccessRules":{
    			"heading" : "Create Access Rules",
    			"description" : "<p>Your CRM may contain 50,000 people, while your community<br>is comprised of 500 people. Superfeed gives you the ability to determine precisely who can access your feed. Simply choose the field(s), operators, and values that separate contact from community member. Remember to add a rule that will allow your fellow staff to access! </p> <h4 class=\"mt-10\">Sample rule:</h4> <p>Contact: Status equals Active</p>",
    			"createAccessRules_btn" : "LET’S MAKE SOME RULES",
    		},
    		"addRules":{
    			"heading" : "Add Rules",
    			"label_text_1":"Select field",
    			"label_text_2":"Select operator",
    			"label_text_3":"Select Value",
    			"addRules_btn" : "SAVE",
    		},
    		"editRules":{
    			"heading" : "Edit Rules",
    			"description":"Congrats! You’ve created your first rules. <br> You can always add or remove these rules later. ",
    			"editRules_btn" : "NEXT",
    		},
    		"selectFieldsPull":{
    			"heading" : "Select Fields to Pull",
    			"description":"<p>Select the fields in your CRM that you'd like to pull into your Superfeed. These fields will either be used to target an<br>audience for a post, build dynamic user profiles, or both.<br>When you update your CRM, you will automatically<br>update your Superfeed.</p> <h4>Sample tags:</h4> <p>Title, Industry</p> <h4>Sample audience:</h4> <p>Title = CEO, Industry = Fintech<br>Only Fintech CEOs can see the post.</p>",
    			"selectFieldsPull_btn" : "LET’S PULL SOME TAGS",
    		},
    		"addTags":{
    			"heading" : "Add Tags",
    			"select_1" : "Select field",
    			"select_2" : "Tags will be used to",
    			"addTags_btn" : "SAVE",
    		},
    		"editTags":{
    			"heading" : "Edit Tags",
    			"title_1" : "Email",
    			"title_2" : "Title",
    			"editTags_btn" : "CONFIRM ADMINS",
    		},
    		"addAdmin":{
    			"heading" : "Add Admin",
    			"description" : "<p>As an admin, you are the superhero of Superfeed. Your special abilities include: the ability to view analytics, edit the rules that determine access, and edit the tags pulled in. If you’re feeling generous, you can also give other people admin access.</p><br><h4>Do you want to give anyone else admin abilities?</h4>",
    			"addAdmin_btn_1" : "NO, KEEP THE POWER",
    			"addAdmin_btn_2" : "YES, SHARE THE POWER",
    		},
    		"admin":{
    			"heading" : "Settings",
    			"menu_1" : "Analytics",
    			"menu_2" : "Admins",
    			"menu_3" : "Tags",
    			"menu_4" : "Access",
    			"menu_5" : "Tools",
    			"menu_6" : "Import",
    		},
    		"analytics" : {
    			"menu_1" : "Overall",
    			"menu_2" : "Title",
    			"menu_3" : "Geography",
    			"menu_4" : "Industry",
    		},
    		"feed": {
    			"show" : "Show",
    			"hide" : "Hide",
    			"comment" : "comment",
    			"comments" : "comments",
    			"reply" : "Reply",
    			"delete" : "Delete",
    		},
    		"adminAllRules": {
    			"btn" : "ADD RULE",
    		},
    		"adminAddRules": {
    			"header" : "Add Rule",
    			"btn" : "ADD RULES",
    		},
    		"adminTools": {
    			"header" : "Admin Tools",
    		},
    		"NewAudienceTitle": {
    			"NewAudienceTitle_placeholder" : "Title",
    			"NewAudienceTitle_btn" : "SAVE",
    		},
    		"NewAudienceIndustry": {
    			"NewAudienceIndustry_placeholder" : "Semper",
    			"NewAudienceIndustry_btn" : "SAVE INDUSTRY",
    		},
    		"NewAudienceGeography": {
    			"NewAudienceGeography_placeholder" : "Detroit",
    			"NewAudienceGeography_btn" : "NEXT",
    		},
    		"NewAudience": {
    			"NewAudience_btn" : "NEXT",
    		},
    		"NewAudienceList":{
    			"NewAudienceList_placeholder" : "Find user",
    			"NewAudienceList_result" : "results",
    			"NewAudienceList_btn" : "Save as Audience",
    		},
    		"new_comment": {
    			"placeholder": "Suggest a post...",
    			"select_audience": "Select Audience",
    			"anonymously_label": "Post anonymously",
    		},
    		"editProfile": {
    			"editProfile_header": "Edit profile",
    			"editProfile_btn": "Edit profile",
    		},
    		"NewAudienceGeographySave": {
    			"NewAudienceGeographySave_btn_1" : "POST",
    			"NewAudienceGeographySave_btn_2" : "Save",
    			"NewAudienceGeographySave_placeholder" : "Post to Audience or Save the Audience"
    		},
    		"download_img": {
    			"download_img_header" : "Download image",
    			"download_btn_1" : "Save",
    			"download_btn_2" : "Image"
    		},
    		"adminAllTags": {
    			"adminAllTags_btn" : "ADD TAG"
    		},
    		"adminAddTags": {
    			"adminAddTags_heading" : "Add Tag",
    			"adminAddTags_btn" : "SAVE TAG",
    		},
    		"adminAddAdmins": {
    			"adminAddAdmins_input" : "Add admin",
    			"adminAddAdmins_btn" : "save as admin",
    		},
    		"adminAllAdmins": {
    			"adminAllAdmins_btn" : "ADD ADMIN",
    		},
    		"newAudience": {
    			"newAudience_header" : "New audience",
    			"newAudienceMenuItem1" : "Title",
    			"newAudienceMenuItem2" : "Industry",
    			"newAudienceMenuItem3" : "Geography",
    		},
    		"importWindow": {
    			"importWindow_btn" : "IMPORT CRM",
    		},
    		"search": {
    			"search_placeholder" : "Search tags...",
    		},
    		"importConfirmation": {
    			"heading" : "Import confirmation",
    			"label_1" : "Select base",
    			"label_2" : "Select table",
    			"placeholder_1" : "Base",
    			"placeholder_2" : "Table",
    			"btn" : "Save",
    		},
    		"setup": {
    			"heading" : "Setup",
    			"label_1" : "Location",
    			"label_2" : "Industry",
    			"label_3" : "Name",
    			"label_4" : "Organization",
    			"label_5" : "Title",
    			"label_6" : "Email",
    			"btn" : "Save",
    		},
    		"preview": {
    			"heading" : "Preview",
    			"label_1" : "Location",
    			"label_2" : "Industry",
    			"label_3" : "Name",
    			"label_4" : "Organization",
    			"label_5" : "Title",
    			"label_6" : "Email",
    			"btn" : "Save",
    		},
    		"select_audience":{
    			"heading" : "Select audience",
    		}
    	},

    };

    /* src/components/Footer.svelte generated by Svelte v3.32.1 */
    const file$1 = "src/components/Footer.svelte";

    function create_fragment$1(ctx) {
    	let div;
    	let raw_value = translations[/*LANG*/ ctx[0]].footer.footer_text + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "center-block__footer");
    			add_location(div, file$1, 5, 0, 1154);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Footer", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ translations, LANG });
    	return [LANG];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/components/CenterBlock.svelte generated by Svelte v3.32.1 */
    const file$2 = "src/components/CenterBlock.svelte";

    function create_fragment$2(ctx) {
    	let main;
    	let div;
    	let header;
    	let t0;
    	let t1;
    	let footer;
    	let current;
    	header = new Header({ $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			create_component(header.$$.fragment);
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			create_component(footer.$$.fragment);
    			attr_dev(div, "class", "center-block");
    			add_location(div, file$2, 6, 4, 151);
    			attr_dev(main, "class", "wrap-center-block");
    			add_location(main, file$2, 5, 0, 114);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);
    			mount_component(header, div, null);
    			append_dev(div, t0);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t1);
    			mount_component(footer, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(header);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(footer);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CenterBlock", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CenterBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Header, Footer });
    	return [$$scope, slots];
    }

    class CenterBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CenterBlock",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/components/buttons/BtnSocial.svelte generated by Svelte v3.32.1 */

    const file$3 = "src/components/buttons/BtnSocial.svelte";

    // (351:0) {#if type === 'link'}
    function create_if_block_1(ctx) {
    	let a;
    	let html_tag;
    	let t;
    	let i;
    	let i_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = space();
    			i = element("i");
    			html_tag = new HtmlTag(t);
    			attr_dev(i, "class", i_class_value = "btn-icons btn-icon-" + /*social*/ ctx[2] + " svelte-1jl4k3k");
    			add_location(i, file$3, 359, 8, 19511);
    			attr_dev(a, "class", "btn btn-social ml-5 mr-5 mb-5 svelte-1jl4k3k");
    			attr_dev(a, "data-step", /*dataStep*/ ctx[0]);
    			attr_dev(a, "data-social", /*social*/ ctx[2]);
    			attr_dev(a, "href", /*hrefAttr*/ ctx[5]);
    			attr_dev(a, "disabled", /*disabled*/ ctx[3]);
    			add_location(a, file$3, 351, 4, 19308);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			html_tag.m(/*text*/ ctx[1], a);
    			append_dev(a, t);
    			append_dev(a, i);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 2) html_tag.p(/*text*/ ctx[1]);

    			if (dirty & /*social*/ 4 && i_class_value !== (i_class_value = "btn-icons btn-icon-" + /*social*/ ctx[2] + " svelte-1jl4k3k")) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (dirty & /*dataStep*/ 1) {
    				attr_dev(a, "data-step", /*dataStep*/ ctx[0]);
    			}

    			if (dirty & /*social*/ 4) {
    				attr_dev(a, "data-social", /*social*/ ctx[2]);
    			}

    			if (dirty & /*hrefAttr*/ 32) {
    				attr_dev(a, "href", /*hrefAttr*/ ctx[5]);
    			}

    			if (dirty & /*disabled*/ 8) {
    				attr_dev(a, "disabled", /*disabled*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(351:0) {#if type === 'link'}",
    		ctx
    	});

    	return block;
    }

    // (364:0) {#if type === 'button'}
    function create_if_block(ctx) {
    	let button;
    	let html_tag;
    	let t;
    	let i;
    	let i_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = space();
    			i = element("i");
    			html_tag = new HtmlTag(t);
    			attr_dev(i, "class", i_class_value = "btn-icons btn-icon-" + /*social*/ ctx[2] + " svelte-1jl4k3k");
    			add_location(i, file$3, 371, 8, 19783);
    			attr_dev(button, "class", "btn btn-social ml-5 mr-5 mb-5 svelte-1jl4k3k");
    			attr_dev(button, "data-step", /*dataStep*/ ctx[0]);
    			attr_dev(button, "data-social", /*social*/ ctx[2]);
    			button.disabled = /*disabled*/ ctx[3];
    			add_location(button, file$3, 364, 4, 19599);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			html_tag.m(/*text*/ ctx[1], button);
    			append_dev(button, t);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 2) html_tag.p(/*text*/ ctx[1]);

    			if (dirty & /*social*/ 4 && i_class_value !== (i_class_value = "btn-icons btn-icon-" + /*social*/ ctx[2] + " svelte-1jl4k3k")) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (dirty & /*dataStep*/ 1) {
    				attr_dev(button, "data-step", /*dataStep*/ ctx[0]);
    			}

    			if (dirty & /*social*/ 4) {
    				attr_dev(button, "data-social", /*social*/ ctx[2]);
    			}

    			if (dirty & /*disabled*/ 8) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(364:0) {#if type === 'button'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let t;
    	let if_block1_anchor;
    	let if_block0 = /*type*/ ctx[4] === "link" && create_if_block_1(ctx);
    	let if_block1 = /*type*/ ctx[4] === "button" && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*type*/ ctx[4] === "link") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*type*/ ctx[4] === "button") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BtnSocial", slots, []);
    	let { dataStep = "" } = $$props;
    	let { text = "" } = $$props;
    	let { social = "" } = $$props;
    	let { disabled = "" } = $$props;
    	let { type = "button" } = $$props;
    	let { hrefAttr = "" } = $$props;
    	const writable_props = ["dataStep", "text", "social", "disabled", "type", "hrefAttr"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BtnSocial> was created with unknown prop '${key}'`);
    	});

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataStep" in $$props) $$invalidate(0, dataStep = $$props.dataStep);
    		if ("text" in $$props) $$invalidate(1, text = $$props.text);
    		if ("social" in $$props) $$invalidate(2, social = $$props.social);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("type" in $$props) $$invalidate(4, type = $$props.type);
    		if ("hrefAttr" in $$props) $$invalidate(5, hrefAttr = $$props.hrefAttr);
    	};

    	$$self.$capture_state = () => ({
    		dataStep,
    		text,
    		social,
    		disabled,
    		type,
    		hrefAttr
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataStep" in $$props) $$invalidate(0, dataStep = $$props.dataStep);
    		if ("text" in $$props) $$invalidate(1, text = $$props.text);
    		if ("social" in $$props) $$invalidate(2, social = $$props.social);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("type" in $$props) $$invalidate(4, type = $$props.type);
    		if ("hrefAttr" in $$props) $$invalidate(5, hrefAttr = $$props.hrefAttr);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dataStep,
    		text,
    		social,
    		disabled,
    		type,
    		hrefAttr,
    		click_handler_1,
    		click_handler
    	];
    }

    class BtnSocial extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			dataStep: 0,
    			text: 1,
    			social: 2,
    			disabled: 3,
    			type: 4,
    			hrefAttr: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BtnSocial",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get dataStep() {
    		throw new Error("<BtnSocial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataStep(value) {
    		throw new Error("<BtnSocial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<BtnSocial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<BtnSocial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get social() {
    		throw new Error("<BtnSocial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set social(value) {
    		throw new Error("<BtnSocial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<BtnSocial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<BtnSocial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<BtnSocial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<BtnSocial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hrefAttr() {
    		throw new Error("<BtnSocial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hrefAttr(value) {
    		throw new Error("<BtnSocial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Heading.svelte generated by Svelte v3.32.1 */
    const file$4 = "src/components/Heading.svelte";

    function create_fragment$4(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			add_location(h1, file$4, 8, 0, 149);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			h1.innerHTML = /*heading*/ ctx[0];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*heading*/ 1) h1.innerHTML = /*heading*/ ctx[0];		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Heading", slots, []);
    	const dispatch = createEventDispatcher();
    	let { heading = "" } = $$props;
    	const writable_props = ["heading"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Heading> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("heading" in $$props) $$invalidate(0, heading = $$props.heading);
    	};

    	$$self.$capture_state = () => ({ createEventDispatcher, dispatch, heading });

    	$$self.$inject_state = $$props => {
    		if ("heading" in $$props) $$invalidate(0, heading = $$props.heading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [heading];
    }

    class Heading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { heading: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Heading",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get heading() {
    		throw new Error("<Heading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set heading(value) {
    		throw new Error("<Heading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/LoginBlock.svelte generated by Svelte v3.32.1 */
    const file$5 = "src/components/LoginBlock.svelte";

    function create_fragment$5(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[0]]?.login_step?.description + "";
    	let t1;
    	let div1;
    	let btnsocial0;
    	let t2;
    	let btnsocial1;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.login_step?.heading
    			},
    			$$inline: true
    		});

    	btnsocial0 = new BtnSocial({
    			props: {
    				dataStep: "sign-up-step",
    				text: translations[/*LANG*/ ctx[0]]?.login_step?.login_btn_1_text,
    				social: "google",
    				type: "link",
    				hrefAttr: /*DOMAIN_FOR_REQUEST*/ ctx[1] + /*GOOGLE_AUTHORIZATION_LINK*/ ctx[2]
    			},
    			$$inline: true
    		});

    	btnsocial1 = new BtnSocial({
    			props: {
    				dataStep: "sign-up-step",
    				text: translations[/*LANG*/ ctx[0]]?.login_step?.login_btn_2_text,
    				social: "linkedin",
    				type: "link",
    				hrefAttr: /*DOMAIN_FOR_REQUEST*/ ctx[1] + /*LINKEDIN_AUTHORIZATION_LINK*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			create_component(btnsocial0.$$.fragment);
    			t2 = space();
    			create_component(btnsocial1.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$5, 174, 8, 7715);
    			html_tag = new HtmlTag(t1);
    			attr_dev(div1, "class", "d-flex justify-content-center flex-wrap mt-30");
    			add_location(div1, file$5, 179, 8, 7893);
    			attr_dev(div2, "class", "center-block__inner login-start");
    			add_location(div2, file$5, 173, 4, 7661);
    			attr_dev(div3, "class", "center-block__content");
    			add_location(div3, file$5, 171, 0, 7620);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(heading, div0, null);
    			append_dev(div2, t0);
    			html_tag.m(raw_value, div2);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(btnsocial0, div1, null);
    			append_dev(div1, t2);
    			mount_component(btnsocial1, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnsocial0.$$.fragment, local);
    			transition_in(btnsocial1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnsocial0.$$.fragment, local);
    			transition_out(btnsocial1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(heading);
    			destroy_component(btnsocial0);
    			destroy_component(btnsocial1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LoginBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const DOMAIN_FOR_REQUEST = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.DOMAIN_FOR_REQUEST;

    	const GOOGLE_AUTHORIZATION_LINK = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.GOOGLE_AUTHORIZATION_LINK;

    	const LINKEDIN_AUTHORIZATION_LINK = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.LINKEDIN_AUTHORIZATION_LINK;

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LoginBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnSocial,
    		Heading,
    		dispatch,
    		LANG,
    		DOMAIN_FOR_REQUEST,
    		GOOGLE_AUTHORIZATION_LINK,
    		LINKEDIN_AUTHORIZATION_LINK
    	});

    	return [
    		LANG,
    		DOMAIN_FOR_REQUEST,
    		GOOGLE_AUTHORIZATION_LINK,
    		LINKEDIN_AUTHORIZATION_LINK
    	];
    }

    class LoginBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LoginBlock",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src/components/SignUpBlock.svelte generated by Svelte v3.32.1 */
    const file$6 = "src/components/SignUpBlock.svelte";

    function create_fragment$6(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[0]]?.signup_step?.description + "";
    	let t1;
    	let div1;
    	let btnsocial0;
    	let t2;
    	let btnsocial1;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.signup_step?.heading
    			},
    			$$inline: true
    		});

    	btnsocial0 = new BtnSocial({
    			props: {
    				dataStep: "welcome-step",
    				text: translations[/*LANG*/ ctx[0]]?.login_step?.login_btn_1_text,
    				social: "google"
    			},
    			$$inline: true
    		});

    	btnsocial0.$on("click", /*goToNextStep*/ ctx[1]);

    	btnsocial1 = new BtnSocial({
    			props: {
    				dataStep: "welcome-step",
    				text: translations[/*LANG*/ ctx[0]]?.login_step?.login_btn_2_text,
    				social: "linkedin"
    			},
    			$$inline: true
    		});

    	btnsocial1.$on("click", /*goToNextStep*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			create_component(btnsocial0.$$.fragment);
    			t2 = space();
    			create_component(btnsocial1.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$6, 19, 8, 1615);
    			html_tag = new HtmlTag(t1);
    			attr_dev(div1, "class", "d-flex justify-content-center flex-wrap mt-30");
    			add_location(div1, file$6, 24, 8, 1795);
    			attr_dev(div2, "class", "center-block__inner login-start");
    			add_location(div2, file$6, 18, 4, 1561);
    			attr_dev(div3, "class", "center-block__content");
    			add_location(div3, file$6, 16, 0, 1520);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(heading, div0, null);
    			append_dev(div2, t0);
    			html_tag.m(raw_value, div2);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(btnsocial0, div1, null);
    			append_dev(div1, t2);
    			mount_component(btnsocial1, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnsocial0.$$.fragment, local);
    			transition_in(btnsocial1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnsocial0.$$.fragment, local);
    			transition_out(btnsocial1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(heading);
    			destroy_component(btnsocial0);
    			destroy_component(btnsocial1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SignUpBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SignUpBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnSocial,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep
    	});

    	return [LANG, goToNextStep];
    }

    class SignUpBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SignUpBlock",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/components/buttons/BtnStandart.svelte generated by Svelte v3.32.1 */
    const file$7 = "src/components/buttons/BtnStandart.svelte";

    // (361:0) {#if btnType === 'loader'}
    function create_if_block_1$1(ctx) {
    	let div;
    	let svg;
    	let circle0;
    	let animate0;
    	let animate1;
    	let circle1;
    	let animate2;
    	let animate3;
    	let circle2;
    	let animate4;
    	let animate5;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			circle0 = svg_element("circle");
    			animate0 = svg_element("animate");
    			animate1 = svg_element("animate");
    			circle1 = svg_element("circle");
    			animate2 = svg_element("animate");
    			animate3 = svg_element("animate");
    			circle2 = svg_element("circle");
    			animate4 = svg_element("animate");
    			animate5 = svg_element("animate");
    			attr_dev(animate0, "attributeName", "r");
    			attr_dev(animate0, "from", "15");
    			attr_dev(animate0, "to", "15");
    			attr_dev(animate0, "begin", "0s");
    			attr_dev(animate0, "dur", "0.8s");
    			attr_dev(animate0, "values", "15;9;15");
    			attr_dev(animate0, "calcMode", "linear");
    			attr_dev(animate0, "repeatCount", "indefinite");
    			add_location(animate0, file$7, 364, 16, 19754);
    			attr_dev(animate1, "attributeName", "fill-opacity");
    			attr_dev(animate1, "from", "1");
    			attr_dev(animate1, "to", "1");
    			attr_dev(animate1, "begin", "0s");
    			attr_dev(animate1, "dur", "0.8s");
    			attr_dev(animate1, "values", "1;.5;1");
    			attr_dev(animate1, "calcMode", "linear");
    			attr_dev(animate1, "repeatCount", "indefinite");
    			add_location(animate1, file$7, 368, 16, 19975);
    			attr_dev(circle0, "cx", "15");
    			attr_dev(circle0, "cy", "15");
    			attr_dev(circle0, "r", "15");
    			add_location(circle0, file$7, 363, 12, 19706);
    			attr_dev(animate2, "attributeName", "r");
    			attr_dev(animate2, "from", "9");
    			attr_dev(animate2, "to", "9");
    			attr_dev(animate2, "begin", "0s");
    			attr_dev(animate2, "dur", "0.8s");
    			attr_dev(animate2, "values", "9;15;9");
    			attr_dev(animate2, "calcMode", "linear");
    			attr_dev(animate2, "repeatCount", "indefinite");
    			add_location(animate2, file$7, 374, 16, 20288);
    			attr_dev(animate3, "attributeName", "fill-opacity");
    			attr_dev(animate3, "from", "0.5");
    			attr_dev(animate3, "to", "0.5");
    			attr_dev(animate3, "begin", "0s");
    			attr_dev(animate3, "dur", "0.8s");
    			attr_dev(animate3, "values", ".5;1;.5");
    			attr_dev(animate3, "calcMode", "linear");
    			attr_dev(animate3, "repeatCount", "indefinite");
    			add_location(animate3, file$7, 378, 16, 20506);
    			attr_dev(circle1, "cx", "60");
    			attr_dev(circle1, "cy", "15");
    			attr_dev(circle1, "r", "9");
    			attr_dev(circle1, "fill-opacity", "0.3");
    			add_location(circle1, file$7, 373, 12, 20222);
    			attr_dev(animate4, "attributeName", "r");
    			attr_dev(animate4, "from", "15");
    			attr_dev(animate4, "to", "15");
    			attr_dev(animate4, "begin", "0s");
    			attr_dev(animate4, "dur", "0.8s");
    			attr_dev(animate4, "values", "15;9;15");
    			attr_dev(animate4, "calcMode", "linear");
    			attr_dev(animate4, "repeatCount", "indefinite");
    			add_location(animate4, file$7, 384, 16, 20807);
    			attr_dev(animate5, "attributeName", "fill-opacity");
    			attr_dev(animate5, "from", "1");
    			attr_dev(animate5, "to", "1");
    			attr_dev(animate5, "begin", "0s");
    			attr_dev(animate5, "dur", "0.8s");
    			attr_dev(animate5, "values", "1;.5;1");
    			attr_dev(animate5, "calcMode", "linear");
    			attr_dev(animate5, "repeatCount", "indefinite");
    			add_location(animate5, file$7, 388, 16, 21028);
    			attr_dev(circle2, "cx", "105");
    			attr_dev(circle2, "cy", "15");
    			attr_dev(circle2, "r", "15");
    			add_location(circle2, file$7, 383, 12, 20758);
    			attr_dev(svg, "width", "120");
    			attr_dev(svg, "height", "30");
    			attr_dev(svg, "viewBox", "0 0 120 30");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "fill", "#fff");
    			attr_dev(svg, "class", "svelte-e3dr2i");
    			add_location(svg, file$7, 362, 8, 19596);
    			attr_dev(div, "class", div_class_value = "btn loader btn-" + /*color*/ ctx[3] + " " + /*className*/ ctx[6] + " svelte-e3dr2i");
    			add_location(div, file$7, 361, 4, 19539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, circle0);
    			append_dev(circle0, animate0);
    			append_dev(circle0, animate1);
    			append_dev(svg, circle1);
    			append_dev(circle1, animate2);
    			append_dev(circle1, animate3);
    			append_dev(svg, circle2);
    			append_dev(circle2, animate4);
    			append_dev(circle2, animate5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*color, className*/ 72 && div_class_value !== (div_class_value = "btn loader btn-" + /*color*/ ctx[3] + " " + /*className*/ ctx[6] + " svelte-e3dr2i")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(361:0) {#if btnType === 'loader'}",
    		ctx
    	});

    	return block;
    }

    // (398:0) {#if btnType !== 'loader'}
    function create_if_block$1(ctx) {
    	let button;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", button_class_value = "btn btn-" + /*color*/ ctx[3] + " " + /*className*/ ctx[6] + " svelte-e3dr2i");
    			attr_dev(button, "type", /*btnType*/ ctx[4]);
    			attr_dev(button, "data-step", /*dataStep*/ ctx[0]);
    			attr_dev(button, "data-role", /*role*/ ctx[1]);
    			button.disabled = /*disabled*/ ctx[5];
    			attr_dev(button, "data-href", /*dataHref*/ ctx[7]);
    			add_location(button, file$7, 398, 4, 21327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			button.innerHTML = /*text*/ ctx[2];

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 4) button.innerHTML = /*text*/ ctx[2];
    			if (dirty & /*color, className*/ 72 && button_class_value !== (button_class_value = "btn btn-" + /*color*/ ctx[3] + " " + /*className*/ ctx[6] + " svelte-e3dr2i")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty & /*btnType*/ 16) {
    				attr_dev(button, "type", /*btnType*/ ctx[4]);
    			}

    			if (dirty & /*dataStep*/ 1) {
    				attr_dev(button, "data-step", /*dataStep*/ ctx[0]);
    			}

    			if (dirty & /*role*/ 2) {
    				attr_dev(button, "data-role", /*role*/ ctx[1]);
    			}

    			if (dirty & /*disabled*/ 32) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[5]);
    			}

    			if (dirty & /*dataHref*/ 128) {
    				attr_dev(button, "data-href", /*dataHref*/ ctx[7]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(398:0) {#if btnType !== 'loader'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let t;
    	let if_block1_anchor;
    	let if_block0 = /*btnType*/ ctx[4] === "loader" && create_if_block_1$1(ctx);
    	let if_block1 = /*btnType*/ ctx[4] !== "loader" && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*btnType*/ ctx[4] === "loader") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*btnType*/ ctx[4] !== "loader") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BtnStandart", slots, []);
    	const dispatch = createEventDispatcher();
    	let { dataStep = "" } = $$props;
    	let { role = "" } = $$props;
    	let { text = "" } = $$props;
    	let { color = "purple" } = $$props;
    	let { btnType = "button" } = $$props;
    	let { disabled = false } = $$props;
    	let { className = "" } = $$props;
    	let { dataHref = "" } = $$props;

    	const writable_props = [
    		"dataStep",
    		"role",
    		"text",
    		"color",
    		"btnType",
    		"disabled",
    		"className",
    		"dataHref"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BtnStandart> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataStep" in $$props) $$invalidate(0, dataStep = $$props.dataStep);
    		if ("role" in $$props) $$invalidate(1, role = $$props.role);
    		if ("text" in $$props) $$invalidate(2, text = $$props.text);
    		if ("color" in $$props) $$invalidate(3, color = $$props.color);
    		if ("btnType" in $$props) $$invalidate(4, btnType = $$props.btnType);
    		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ("className" in $$props) $$invalidate(6, className = $$props.className);
    		if ("dataHref" in $$props) $$invalidate(7, dataHref = $$props.dataHref);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		dataStep,
    		role,
    		text,
    		color,
    		btnType,
    		disabled,
    		className,
    		dataHref
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataStep" in $$props) $$invalidate(0, dataStep = $$props.dataStep);
    		if ("role" in $$props) $$invalidate(1, role = $$props.role);
    		if ("text" in $$props) $$invalidate(2, text = $$props.text);
    		if ("color" in $$props) $$invalidate(3, color = $$props.color);
    		if ("btnType" in $$props) $$invalidate(4, btnType = $$props.btnType);
    		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ("className" in $$props) $$invalidate(6, className = $$props.className);
    		if ("dataHref" in $$props) $$invalidate(7, dataHref = $$props.dataHref);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dataStep,
    		role,
    		text,
    		color,
    		btnType,
    		disabled,
    		className,
    		dataHref,
    		click_handler
    	];
    }

    class BtnStandart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			dataStep: 0,
    			role: 1,
    			text: 2,
    			color: 3,
    			btnType: 4,
    			disabled: 5,
    			className: 6,
    			dataHref: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BtnStandart",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get dataStep() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataStep(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get role() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set role(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get btnType() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set btnType(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataHref() {
    		throw new Error("<BtnStandart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataHref(value) {
    		throw new Error("<BtnStandart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/WelcomeBlock.svelte generated by Svelte v3.32.1 */
    const file$8 = "src/components/WelcomeBlock.svelte";

    function create_fragment$8(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let heading;
    	let t0;
    	let div1;
    	let raw_value = translations[/*LANG*/ ctx[0]]?.welcome_step?.description + "";
    	let t1;
    	let div2;
    	let btnstandart;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.welcome_step?.heading
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "user-personality-step",
    				text: translations[/*LANG*/ ctx[0]]?.welcome_step?.welcome_step_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*goToNextStep*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$8, 173, 8, 4536);
    			add_location(div1, file$8, 177, 8, 4656);
    			attr_dev(div2, "class", "mt-30");
    			add_location(div2, file$8, 179, 8, 4730);
    			attr_dev(div3, "class", "center-block__inner");
    			add_location(div3, file$8, 172, 4, 4494);
    			attr_dev(div4, "class", "center-block__content");
    			add_location(div4, file$8, 170, 0, 4453);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			mount_component(heading, div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			div1.innerHTML = raw_value;
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			mount_component(btnstandart, div2, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(heading);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WelcomeBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WelcomeBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep
    	});

    	return [LANG, goToNextStep];
    }

    class WelcomeBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WelcomeBlock",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    //New audience
    const createdNewAudienceData   = writable([]);
    const createdNewAudiencePeople   = writable([]);

    const peopleAudienceData   = writable([]);
    const createdCommunityData = writable([]);
    const createdAudienceData  = writable([]);
    const createdDriversData   = writable([]);
    const exportFieldsData     = writable([]);
    const responseFieldsData   = writable([]);
    const previewTagsData      = writable([]);
    const createTagsData       = writable([]);


    const previewTagsResponseData = writable([]);

    /**
     * Debounce function
     * @param fn     - function that should be executed
     * @param time   - time delay
     * @returns {Function}
     */
    const debounce = (fn, time = 1000) => {

    	if ( !fn ) {
    		throw Error('"debounce function - "You didn\'t add required parameters');
    	}

    	let timeout;

    	return function() {
    		const functionCall = () => fn.apply(this, arguments);

    		clearTimeout(timeout);
    		timeout = setTimeout(functionCall, time);
    	}
    };


    /**
     * Test value with regex
     * @param {(name|email|phone|postal)} fieldType  - The allowed type of the fields
     * @param value
     * @return {boolean}
     */
    const validateField = (fieldType = null, value = null) => {

    	if ( !fieldType ) {
    		throw Error('"validateField function - "You didn\'t add required parameters');
    	}

    	const phoneREGEX  = /^[0-9\+]{6,13}$/;
    	const nameREGEX   = /^[a-zA-Zа-яА-Я\s]{2,30}$/;
    	const postalREGEX = /^[A-Z]{1,2}[0-9]{1,2} ?[0-9][A-Z]{2}$/i;
    	const emailREGEX  = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;
    	const dummyREGEX  = /^.+$/;

    	let checkResult   = false;

    	switch (fieldType) {
    		case 'name':
    			checkResult = nameREGEX.test(value);
    			break;
    		case 'phone':
    			checkResult = phoneREGEX.test(value);
    			break;
    		case 'postal':
    			checkResult = postalREGEX.test(value);
    			break;
    		case 'email':
    			checkResult = emailREGEX.test(value);
    			break;
    		case 'price':
    			checkResult = dummyREGEX.test(value);
    			break;
    		case 'aim':
    			checkResult = dummyREGEX.test(value);
    			break;
    		case 'date':
    			checkResult = dummyREGEX.test(value);
    			break;
    		case 'subject':
    			checkResult = dummyREGEX.test(value);
    			break;
    		case 'anyText':
    			checkResult = dummyREGEX.test(value);
    			break;
    	}

    	return checkResult;

    };


    /**
     *  Check step's field according to form step selector
     */
    const checkStepFields = (formStepSelector) => {
    	if ( !formStepSelector ) return false;

    	let errorCheckArr  = [];
    	const inputToCheck = document.querySelectorAll(`[data-role="${formStepSelector}"] input[data-input-role]`);

    	[...inputToCheck].forEach( (item, index) => {
    		const checkField     = +validateField( item.dataset.inputRole, item.value );
    		const operationType  = (checkField) ? 'remove' : 'add';
    		errorCheckArr[index] = checkField;

    		item.classList[operationType]('error');
    	});

    	return ( errorCheckArr.reduce( (accum, current) => accum+current, 0 ) === errorCheckArr.length );
    };


    /**
     * Save to localStorage entered user's data
     *
     * @param formStepSelector
     * @return {boolean}
     */
    const saveEnteredUserData = (formStepSelector) => {
    	const fieldsToSave = document.querySelectorAll(`[data-role="${formStepSelector}"] [data-input-role]`);

    	if ( !fieldsToSave ) return false;

    	let updatedData = {};

    	// Update according fields
    	[...fieldsToSave].forEach( item => {

    		if ( item.type === 'radio' && !item.checked ) {
    			return false;
    		}

    		if ( updatedData[item.name] ) {
    			let temp = [...updatedData[item.name], item.value];
    			updatedData[item.name] = [...new Set(temp)];

    		} else {
    			updatedData[item.name] = [item.value];
    		}

    	});

    	if ( formStepSelector === 'user-personality' ) {
    		let tempData = {
    			"user_name" : updatedData.user_name[0],
    			"user_email" : updatedData.user_email[0],
    			"user_code" : updatedData.user_code[0],
    		};
    		peopleAudienceData.update( (n) => tempData);
    	}

    	if ( formStepSelector === 'user-community' ) {
    		createdAudienceData.update( (n) => updatedData);
    	}

    	if ( formStepSelector === 'user-which-crm' ) {
    		let tempData = {
    			"driver" : updatedData.user_crm_name[0]
    		};
    		exportFieldsData.update( (n) => tempData);
    	}

    	if ( formStepSelector === 'user-api-key' ) {
    		let tempData = {
    			...get_store_value(exportFieldsData),
    			"key"    : updatedData.user_api_key[0]
    		};
    		exportFieldsData.update( (n) => tempData);
    	}

    	if ( formStepSelector === 'user-import-step' ) {
    		let tempData = {
    			...get_store_value(exportFieldsData),
    			"base"   : updatedData.user_import_base[0],
    			"table"  : updatedData.user_import_table[0]
    		};

    		exportFieldsData.update( (n) => tempData);
    	}

    	if ( formStepSelector === 'user-setup' ) {
    		let tempData = {
    			...get_store_value(exportFieldsData),
    			"fields" : {
    				"Email": updatedData['email'][0],
    				"Name": updatedData['name'][0],
    				"Location": updatedData['location'][0],
    				"Organization": updatedData['organization'][0],
    				"Title": updatedData['title'][0],
    				"Industry": updatedData['industry'][0],
    			}
    		};

    		previewTagsData.update( (n) => tempData);
    	}

    	//localStorage.setItem( 'entered-user-data', JSON.stringify(updatedData) );

    	return true;
    };



    /**
     * Save to Store entered audience data
     *
     * @param formStepSelector
     * @return {boolean}
     */
    const saveEnteredAudienceData = (formStepSelector) => {
    	const fieldsToSave = document.querySelectorAll(`[data-role="${formStepSelector}"] [data-input-role]`);

    	if ( !fieldsToSave ) return false;

    	let updatedData = {...get_store_value(createdNewAudienceData)};

    	// Update according fields
    	[...fieldsToSave].forEach( item => {

    		if (updatedData[item.name]) {
    			let temp = [...updatedData[item.name], item.value];
    			updatedData[item.name] = [...new Set(temp)];
    		} else {
    			updatedData[item.name] = [item.value];
    		}

    	});
    	createdNewAudienceData.update( (n) => updatedData);
    	return true;
    };



    /**
     * Save to localStorage entered rule's data
     *
     * @param formStepSelector
     * @return {boolean}
     */
    const saveEnteredRuleData = (formStepSelector) => {
    	const fieldsToSave = document.querySelectorAll(`[data-role="${formStepSelector}"] [data-input-role]`);

    	if ( !fieldsToSave ) return false;
    	let updatedData = [];

    	// Update according fields
    	[...fieldsToSave].forEach( (item, index) => {
    		const groupIndex = item.dataset.groupIndex;
    		const itemValue  = (item.name).replace(/[\[\] ]/g, "");

    		updatedData[groupIndex] = {
    			...updatedData[groupIndex],
    			[itemValue] : item.value
    		};
    	});

    	localStorage.setItem( 'entered-rule-data', JSON.stringify(updatedData) );

    	return true;
    };



    /**
     * Save to Store entered tag's data
     *
     * @param formStepSelector
     * @return {boolean}
     */
    const saveEnteredTagData = (formStepSelector) => {
    	const fieldsToSave = document.querySelectorAll(`[data-role="${formStepSelector}"] [data-input-role]`);

    	if ( !fieldsToSave ) return false;
    	//let updatedData = [];
    	let updatedData = {...get_store_value(createTagsData)};

    	// Update according fields
    	[...fieldsToSave].forEach( (item, index) => {
    		const groupIndex = item.dataset.groupIndex;
    		const itemValue  = (item.name).replace(/[\[\] ]/g, "");

    		updatedData[groupIndex] = {
    			...updatedData[groupIndex],
    			[itemValue] : item.value
    		};
    	});
    	console.log('saveEnteredTagData - updatedData -----', updatedData);
    	// localStorage.setItem( 'entered-tag-data', JSON.stringify(updatedData) );
    	createTagsData.update( (n) => updatedData);

    	return true;
    };



    /**
     * Save to localStorage entered admins's data
     *
     * @param formStepSelector
     * @return {boolean}
     */
    const saveEnteredAdminData = (formStepSelector) => {
    	const fieldsToSave = document.querySelectorAll(`[data-role="${formStepSelector}"] [data-input-role]`);

    	if ( !fieldsToSave ) return false;
    	let updatedData = [];

    	// Update according fields
    	[...fieldsToSave].forEach( (item, index) => {
    		const itemValue  = (item.name).replace(/[\[\] ]/g, "");

    		updatedData[index] = {
    			...updatedData[index],
    			[itemValue] : item.value
    		};
    	});

    	localStorage.setItem( 'entered-admin-data', JSON.stringify(updatedData) );

    	return true;
    };


    /**
     * Send data to backend
     *
     * @param dataToSent
     * @param endpoint
     * @param method
     * @param isFormData
     * @returns {boolean}
     */
    const makeRequestToBackend = async (dataToSent = false, endpoint, method, isFormData = false) => {

    	const DOMAIN_FOR_REQUEST  = {"env":{"isProd":false,"CURRENT_LANG":"en","DOMAIN_FOR_REQUEST":"https://super.aladin.od.ua","GOOGLE_AUTHORIZATION_LINK":"/auth/redirect/google","LINKEDIN_AUTHORIZATION_LINK":"/auth/redirect/linkedin","GET_POST_ENDPOINT":"/community/posts/12","SET_NEW_POST_ENDPOINT":"/community/posts/13","SEARCH_POST_ENDPOINT":"/community/search/16","DELETE_POST_ENDPOINT":"/post/delete/15","CREATE_COMMENT_ENDPOINT":"/post/comment/1","DELETE_COMMENT_ENDPOINT":"/comment/delete/1","GET_USER_PROFILE_ENDPOINT":"/profile","GET_USER_PROFILE_EMAIL_ENDPOINT":"/profile/email","SEARCH_TAGS_ENDPOINT":"/community/tags/","LIST_TAGS_ENDPOINT":"/community/tags/12","LIST_CONTACTS_ENDPOINT":"/community/contacts/13","CREATE_COMMUNITY_ENDPOINT":"/community/0","GET_COMMUNITIES_ENDPOINT":"/community","GET_DRIVERS_ENDPOINT":"/export/drivers","GET_FIELDS_ENDPOINT":"/export/fields","PREVIEW_TAGS_ENDPOINT":"/export/preview","LOAD_PREVIEW_PARAMETERS_ENDPOINT":"/export/load","AUTOCOMPLETE_VALUES_ENDPOINT":"/export/values","EXPORT_RULES_ENDPOINT":"/export"}}.env.DOMAIN_FOR_REQUEST;
    	let myHeaders             = new Headers();
    	let data                  = '';
    	let develop_get_param = '';

    	{
    		console.log('Cookie check');
    		develop_get_param = '?test_user=2';
    	}

    	myHeaders.append("Accept", "application/json");

    	if ( endpoint === '/export/preview' || endpoint === '/export/load' ) {
    		data = new URLSearchParams();
    		data.append("key", dataToSent?.key );
    		data.append("driver", dataToSent?.driver );
    		data.append("base", dataToSent?.base );
    		data.append("table", dataToSent?.table );
    		data.append("fields[Email]", dataToSent?.fields['Email'] );
    		data.append("fields[Name]", dataToSent?.fields['Name'] );
    		data.append("fields[Location]", dataToSent?.fields['Location'] );
    		data.append("fields[Organization]", dataToSent?.fields['Organization'] );
    		data.append("fields[Title]", dataToSent?.fields['Title'] );
    		data.append("fields[Industry]", dataToSent?.fields['Industry'] );
    	}
    	else {

    		// FormDta variant
    		if ( dataToSent && isFormData ) {
    			data = new FormData();
    			for (let key in dataToSent) {
    				data.append(key, dataToSent[key]);
    			}
    		}

    		// URLSearchParams variant
    		if ( dataToSent && !isFormData ) {
    			data = new URLSearchParams();
    			for (let key in dataToSent) {
    				data.append(key, dataToSent[key]);
    			}
    		}

    	}

    	console.log('v.26.02.2021 21:49');

    	console.log('makeRequestToBackend', makeRequestToBackend);

    	let requestOptions = {
    		method   : method,
    		headers  : myHeaders,
    		//redirect : 'follow'
    	};

    	if ( method.toLowerCase() === 'post' ) {
    		requestOptions.body = data;
    	}

    	const response   = await fetch(DOMAIN_FOR_REQUEST+endpoint+develop_get_param, requestOptions);

    	if ( +response.status !== 200 ) {
    		const error = await response.json();
    		return {
    			status  : response.status,
    			message : error.message
    		};
    	}

    	return await response.text();
    };

    /* src/components/buttons/BtnBack.svelte generated by Svelte v3.32.1 */
    const file$9 = "src/components/buttons/BtnBack.svelte";

    function create_fragment$9(ctx) {
    	let button;
    	let i;
    	let t;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[2]].BtnBack.BtnBack_text + "";
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = space();
    			attr_dev(i, "class", "btn-icon-back svelte-1jl4k3k");
    			add_location(i, file$9, 354, 4, 20398);
    			html_tag = new HtmlTag(null);
    			attr_dev(button, "class", "btn-back svelte-1jl4k3k");
    			attr_dev(button, "data-step", /*dataStep*/ ctx[0]);
    			attr_dev(button, "data-role", /*role*/ ctx[1]);
    			add_location(button, file$9, 349, 0, 20294);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);
    			append_dev(button, t);
    			html_tag.m(raw_value, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dataStep*/ 1) {
    				attr_dev(button, "data-step", /*dataStep*/ ctx[0]);
    			}

    			if (dirty & /*role*/ 2) {
    				attr_dev(button, "data-role", /*role*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BtnBack", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let { dataStep = "" } = $$props;
    	let { role = "" } = $$props;
    	const writable_props = ["dataStep", "role"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BtnBack> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataStep" in $$props) $$invalidate(0, dataStep = $$props.dataStep);
    		if ("role" in $$props) $$invalidate(1, role = $$props.role);
    	};

    	$$self.$capture_state = () => ({ translations, LANG, dataStep, role });

    	$$self.$inject_state = $$props => {
    		if ("dataStep" in $$props) $$invalidate(0, dataStep = $$props.dataStep);
    		if ("role" in $$props) $$invalidate(1, role = $$props.role);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dataStep, role, LANG, click_handler];
    }

    class BtnBack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { dataStep: 0, role: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BtnBack",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get dataStep() {
    		throw new Error("<BtnBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataStep(value) {
    		throw new Error("<BtnBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get role() {
    		throw new Error("<BtnBack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set role(value) {
    		throw new Error("<BtnBack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/inputs/Input.svelte generated by Svelte v3.32.1 */
    const file$a = "src/components/inputs/Input.svelte";

    // (352:4) {#if label}
    function create_if_block_1$2(ctx) {
    	let label_1;

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			attr_dev(label_1, "class", "form-control__label svelte-1isdxio");
    			attr_dev(label_1, "for", /*id*/ ctx[0]);
    			add_location(label_1, file$a, 352, 8, 10677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			label_1.innerHTML = /*label*/ ctx[9];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 512) label_1.innerHTML = /*label*/ ctx[9];
    			if (dirty & /*id*/ 1) {
    				attr_dev(label_1, "for", /*id*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(352:4) {#if label}",
    		ctx
    	});

    	return block;
    }

    // (369:4) {#if errorText }
    function create_if_block$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "error-message svelte-1isdxio");
    			add_location(div, file$a, 369, 8, 11102);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = /*errorText*/ ctx[4];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errorText*/ 16) div.innerHTML = /*errorText*/ ctx[4];		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(369:4) {#if errorText }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let t0;
    	let input;
    	let input_class_value;
    	let t1;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block0 = /*label*/ ctx[9] && create_if_block_1$2(ctx);
    	let if_block1 = /*errorText*/ ctx[4] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			input = element("input");
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(input, "id", /*id*/ ctx[0]);
    			attr_dev(input, "type", /*type*/ ctx[1]);
    			attr_dev(input, "name", /*name*/ ctx[2]);
    			input.value = /*value*/ ctx[3];
    			attr_dev(input, "class", input_class_value = "" + (null_to_empty(/*className*/ ctx[5] + " " + /*search*/ ctx[11] + " " + /*readonly*/ ctx[13]) + " svelte-1isdxio"));
    			attr_dev(input, "data-input-role", /*dataInputRole*/ ctx[7]);
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[8]);
    			attr_dev(input, "data-group-index", /*groupIndex*/ ctx[12]);
    			input.readOnly = /*valueReadOnly*/ ctx[10];
    			add_location(input, file$a, 355, 4, 10760);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`form-control ${/*wrapperClass*/ ctx[6]}`) + " svelte-1isdxio"));
    			add_location(div, file$a, 350, 0, 10606);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, input);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_handler*/ ctx[14], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*id*/ 1) {
    				attr_dev(input, "id", /*id*/ ctx[0]);
    			}

    			if (dirty & /*type*/ 2) {
    				attr_dev(input, "type", /*type*/ ctx[1]);
    			}

    			if (dirty & /*name*/ 4) {
    				attr_dev(input, "name", /*name*/ ctx[2]);
    			}

    			if (dirty & /*value*/ 8 && input.value !== /*value*/ ctx[3]) {
    				prop_dev(input, "value", /*value*/ ctx[3]);
    			}

    			if (dirty & /*className, search*/ 2080 && input_class_value !== (input_class_value = "" + (null_to_empty(/*className*/ ctx[5] + " " + /*search*/ ctx[11] + " " + /*readonly*/ ctx[13]) + " svelte-1isdxio"))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (dirty & /*dataInputRole*/ 128) {
    				attr_dev(input, "data-input-role", /*dataInputRole*/ ctx[7]);
    			}

    			if (dirty & /*placeholder*/ 256) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[8]);
    			}

    			if (dirty & /*groupIndex*/ 4096) {
    				attr_dev(input, "data-group-index", /*groupIndex*/ ctx[12]);
    			}

    			if (dirty & /*valueReadOnly*/ 1024) {
    				prop_dev(input, "readOnly", /*valueReadOnly*/ ctx[10]);
    			}

    			if (/*errorText*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$2(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*wrapperClass*/ 64 && div_class_value !== (div_class_value = "" + (null_to_empty(`form-control ${/*wrapperClass*/ ctx[6]}`) + " svelte-1isdxio"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Input", slots, []);
    	const dispatch = createEventDispatcher();
    	let { id = "" } = $$props;
    	let { type = "text" } = $$props;
    	let { name = "" } = $$props;
    	let { value = "" } = $$props;
    	let { errorText = "" } = $$props;
    	let { className = "form-control__input-text" } = $$props;
    	let { wrapperClass = "" } = $$props;
    	let { dataInputRole = "" } = $$props;
    	let { placeholder = "" } = $$props;
    	let { label = "" } = $$props;
    	let { valueReadOnly = "" } = $$props;
    	let { search = "" } = $$props;
    	let { groupIndex = "" } = $$props;
    	let readonly = valueReadOnly ? valueReadOnly : "";

    	const writable_props = [
    		"id",
    		"type",
    		"name",
    		"value",
    		"errorText",
    		"className",
    		"wrapperClass",
    		"dataInputRole",
    		"placeholder",
    		"label",
    		"valueReadOnly",
    		"search",
    		"groupIndex"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Input> was created with unknown prop '${key}'`);
    	});

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("errorText" in $$props) $$invalidate(4, errorText = $$props.errorText);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("wrapperClass" in $$props) $$invalidate(6, wrapperClass = $$props.wrapperClass);
    		if ("dataInputRole" in $$props) $$invalidate(7, dataInputRole = $$props.dataInputRole);
    		if ("placeholder" in $$props) $$invalidate(8, placeholder = $$props.placeholder);
    		if ("label" in $$props) $$invalidate(9, label = $$props.label);
    		if ("valueReadOnly" in $$props) $$invalidate(10, valueReadOnly = $$props.valueReadOnly);
    		if ("search" in $$props) $$invalidate(11, search = $$props.search);
    		if ("groupIndex" in $$props) $$invalidate(12, groupIndex = $$props.groupIndex);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		id,
    		type,
    		name,
    		value,
    		errorText,
    		className,
    		wrapperClass,
    		dataInputRole,
    		placeholder,
    		label,
    		valueReadOnly,
    		search,
    		groupIndex,
    		readonly
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("type" in $$props) $$invalidate(1, type = $$props.type);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("errorText" in $$props) $$invalidate(4, errorText = $$props.errorText);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("wrapperClass" in $$props) $$invalidate(6, wrapperClass = $$props.wrapperClass);
    		if ("dataInputRole" in $$props) $$invalidate(7, dataInputRole = $$props.dataInputRole);
    		if ("placeholder" in $$props) $$invalidate(8, placeholder = $$props.placeholder);
    		if ("label" in $$props) $$invalidate(9, label = $$props.label);
    		if ("valueReadOnly" in $$props) $$invalidate(10, valueReadOnly = $$props.valueReadOnly);
    		if ("search" in $$props) $$invalidate(11, search = $$props.search);
    		if ("groupIndex" in $$props) $$invalidate(12, groupIndex = $$props.groupIndex);
    		if ("readonly" in $$props) $$invalidate(13, readonly = $$props.readonly);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		id,
    		type,
    		name,
    		value,
    		errorText,
    		className,
    		wrapperClass,
    		dataInputRole,
    		placeholder,
    		label,
    		valueReadOnly,
    		search,
    		groupIndex,
    		readonly,
    		input_handler
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			id: 0,
    			type: 1,
    			name: 2,
    			value: 3,
    			errorText: 4,
    			className: 5,
    			wrapperClass: 6,
    			dataInputRole: 7,
    			placeholder: 8,
    			label: 9,
    			valueReadOnly: 10,
    			search: 11,
    			groupIndex: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get id() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errorText() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorText(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapperClass() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapperClass(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataInputRole() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataInputRole(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueReadOnly() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueReadOnly(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get search() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set search(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupIndex() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupIndex(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/UserPersonalityBlock.svelte generated by Svelte v3.32.1 */

    const { console: console_1 } = globals;
    const file$b = "src/components/UserPersonalityBlock.svelte";

    // (166:16) {#if user_email_exist}
    function create_if_block$3(ctx) {
    	let input;
    	let current;

    	input = new Input({
    			props: {
    				name: "user_code",
    				wrapperClass: "mt-0 mb-15 m-15",
    				value: /*user_code*/ ctx[4],
    				dataInputRole: "subject",
    				className: "form-control__input-text js-check-input-code",
    				errorText: translations[/*LANG*/ ctx[5]]?.inputsErrors?.subject,
    				placeholder: translations[/*LANG*/ ctx[5]]?.personality_step?.placeholder_3
    			},
    			$$inline: true
    		});

    	input.$on("input", /*changeInputHandler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(166:16) {#if user_email_exist}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div5;
    	let div4;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[5]]?.personality_step?.description + "";
    	let t1;
    	let form;
    	let div1;
    	let input0;
    	let t2;
    	let input1;
    	let t3;
    	let t4;
    	let div2;
    	let btnstandart;
    	let t5;
    	let div3;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[5]]?.personality_step?.heading
    			},
    			$$inline: true
    		});

    	input0 = new Input({
    			props: {
    				name: "user_name",
    				wrapperClass: "mt-0 mb-15 m-15",
    				value: /*user_name*/ ctx[3],
    				dataInputRole: "name",
    				className: "form-control__input-text js-check-input-name",
    				errorText: translations[/*LANG*/ ctx[5]]?.inputsErrors?.name,
    				placeholder: translations[/*LANG*/ ctx[5]]?.personality_step?.placeholder_1
    			},
    			$$inline: true
    		});

    	input0.$on("input", /*changeInputHandler*/ ctx[8]);

    	input1 = new Input({
    			props: {
    				type: "email",
    				name: "user_email",
    				wrapperClass: "mt-0 mb-15 m-15",
    				value: /*user_email*/ ctx[0],
    				dataInputRole: "email",
    				className: "form-control__input-text js-check-input-email",
    				errorText: translations[/*LANG*/ ctx[5]]?.inputsErrors?.email,
    				placeholder: translations[/*LANG*/ ctx[5]]?.personality_step?.placeholder_2
    			},
    			$$inline: true
    		});

    	input1.$on("input", /*changeInputHandler*/ ctx[8]);
    	let if_block = /*user_email_exist*/ ctx[1] && create_if_block$3(ctx);

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[5]]?.personality_step?.personality_step_btn,
    				color: "purple",
    				btnType: "submit",
    				disabled: /*isNextBtnDisabled*/ ctx[2]
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "welcome-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			form = element("form");
    			div1 = element("div");
    			create_component(input0.$$.fragment);
    			t2 = space();
    			create_component(input1.$$.fragment);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			div2 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t5 = space();
    			div3 = element("div");
    			create_component(btnback.$$.fragment);
    			html_tag = new HtmlTag(null);
    			attr_dev(div0, "class", "center-block__text svelte-1j8191b");
    			add_location(div0, file$b, 134, 8, 8315);
    			attr_dev(div1, "class", "user-data__group svelte-1j8191b");
    			add_location(div1, file$b, 142, 12, 8678);
    			attr_dev(div2, "class", "mt-30");
    			add_location(div2, file$b, 178, 12, 10393);
    			attr_dev(form, "data-role", "user-personality");
    			attr_dev(form, "data-step", "user-community-step");
    			add_location(form, file$b, 138, 8, 8521);
    			attr_dev(div3, "class", "mt-30");
    			add_location(div3, file$b, 188, 8, 10752);
    			attr_dev(div4, "class", "center-block__inner center-block__inner-mod svelte-1j8191b");
    			add_location(div4, file$b, 133, 4, 8249);
    			attr_dev(div5, "class", "center-block__content");
    			add_location(div5, file$b, 132, 0, 8209);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			mount_component(heading, div0, null);
    			append_dev(div0, t0);
    			html_tag.m(raw_value, div0);
    			append_dev(div4, t1);
    			append_dev(div4, form);
    			append_dev(form, div1);
    			mount_component(input0, div1, null);
    			append_dev(div1, t2);
    			mount_component(input1, div1, null);
    			append_dev(div1, t3);
    			if (if_block) if_block.m(div1, null);
    			append_dev(form, t4);
    			append_dev(form, div2);
    			mount_component(btnstandart, div2, null);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			mount_component(btnback, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[6]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const input1_changes = {};
    			if (dirty & /*user_email*/ 1) input1_changes.value = /*user_email*/ ctx[0];
    			input1.$set(input1_changes);

    			if (/*user_email_exist*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*user_email_exist*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const btnstandart_changes = {};
    			if (dirty & /*isNextBtnDisabled*/ 4) btnstandart_changes.disabled = /*isNextBtnDisabled*/ ctx[2];
    			btnstandart.$set(btnstandart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(input0.$$.fragment, local);
    			transition_in(input1.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(heading);
    			destroy_component(input0);
    			destroy_component(input1);
    			if (if_block) if_block.d();
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $peopleAudienceData;
    	validate_store(peopleAudienceData, "peopleAudienceData");
    	component_subscribe($$self, peopleAudienceData, $$value => $$invalidate(10, $peopleAudienceData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserPersonalityBlock", slots, []);

    	let user_name = $peopleAudienceData && $peopleAudienceData?.user_name
    	? $peopleAudienceData?.user_name
    	: "";

    	let user_email = $peopleAudienceData && $peopleAudienceData?.user_email
    	? $peopleAudienceData?.user_email
    	: "";

    	let user_code = $peopleAudienceData && $peopleAudienceData?.user_code
    	? $peopleAudienceData?.user_code
    	: "";

    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let profileData;
    	let user_email_exist = true;

    	(async () => {

    		const GET_USER_PROFILE_ENDPOINT = ({
    			"env": {
    				"isProd": false,
    				"CURRENT_LANG": "en",
    				"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    				"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    				"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    				"GET_POST_ENDPOINT": "/community/posts/12",
    				"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    				"SEARCH_POST_ENDPOINT": "/community/search/16",
    				"DELETE_POST_ENDPOINT": "/post/delete/15",
    				"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    				"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    				"GET_USER_PROFILE_ENDPOINT": "/profile",
    				"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    				"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    				"LIST_TAGS_ENDPOINT": "/community/tags/12",
    				"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    				"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    				"GET_COMMUNITIES_ENDPOINT": "/community",
    				"GET_DRIVERS_ENDPOINT": "/export/drivers",
    				"GET_FIELDS_ENDPOINT": "/export/fields",
    				"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    				"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    				"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    				"EXPORT_RULES_ENDPOINT": "/export"
    			}
    		}).env.GET_USER_PROFILE_ENDPOINT;

    		let res = await makeRequestToBackend(false, GET_USER_PROFILE_ENDPOINT, "GET", true);
    		profileData = JSON.parse(res);
    		console.log("profileData", profileData);

    		// Access isn't authorized
    		if (res.status === 401) {
    			nextStep = "login-step";
    			return;
    		}

    		if (profileData.email === null) {
    			// if user came first time
    			console.log("email === null");

    			if (profileData.social_email) {
    				// and if came from social network
    				$$invalidate(0, user_email = profileData.social_email); //show email in input

    				$$invalidate(1, user_email_exist = false); //hidden input for code
    			}
    		}
    	})();

    	/**
     * Check form's input for valid values
     * and skip transition to the next step if some fields isn't valid
     * @param event
     * @returns {boolean}
     */
    	const goToNextStep = event => {
    		if (!checkStepFields("user-personality")) return false;

    		// Update localStorage with users data
    		saveEnteredUserData("user-personality");

    		(async () => {
    			//the user came to the site for the first time
    			if (profileData.email === null) {
    				let dataToSent = { "email": $peopleAudienceData?.user_email };

    				if (!profileData.social_email) {
    					dataToSent = {
    						...dataToSent,
    						"code": $peopleAudienceData?.user_code
    					};
    				}

    				const GET_USER_PROFILE_EMAIL_ENDPOINT = ({
    					"env": {
    						"isProd": false,
    						"CURRENT_LANG": "en",
    						"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    						"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    						"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    						"GET_POST_ENDPOINT": "/community/posts/12",
    						"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    						"SEARCH_POST_ENDPOINT": "/community/search/16",
    						"DELETE_POST_ENDPOINT": "/post/delete/15",
    						"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    						"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    						"GET_USER_PROFILE_ENDPOINT": "/profile",
    						"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    						"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    						"LIST_TAGS_ENDPOINT": "/community/tags/12",
    						"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    						"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    						"GET_COMMUNITIES_ENDPOINT": "/community",
    						"GET_DRIVERS_ENDPOINT": "/export/drivers",
    						"GET_FIELDS_ENDPOINT": "/export/fields",
    						"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    						"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    						"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    						"EXPORT_RULES_ENDPOINT": "/export"
    					}
    				}).env.GET_USER_PROFILE_EMAIL_ENDPOINT;

    				console.log("dataToSent", dataToSent);
    				let resEmail = await makeRequestToBackend(dataToSent, GET_USER_PROFILE_EMAIL_ENDPOINT, "POST", false);
    				let emailProfileData = JSON.parse(resEmail);
    				console.log("emailProfileData", emailProfileData);
    			}
    		})();

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	//checking for the presence of the entered data
    	let isNextBtnDisabled = true;

    	const changeInputHandler = () => {
    		const nameInput = document.querySelector(".js-check-input-name");
    		const emailInput = document.querySelector(".js-check-input-email");
    		const codeInput = document.querySelector(".js-check-input-code");
    		console.log("user_email_exist", user_email_exist);

    		if (user_email_exist) {
    			$$invalidate(2, isNextBtnDisabled = !(!!nameInput.value && !!emailInput.value && !!codeInput.value));
    		} else {
    			$$invalidate(2, isNextBtnDisabled = !(!!nameInput.value && !!emailInput.value));
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<UserPersonalityBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		makeRequestToBackend,
    		saveEnteredUserData,
    		createEventDispatcher,
    		translations,
    		BtnBack,
    		BtnStandart,
    		Input,
    		Heading,
    		peopleAudienceData,
    		user_name,
    		user_email,
    		user_code,
    		dispatch,
    		LANG,
    		profileData,
    		user_email_exist,
    		goToNextStep,
    		goToBack,
    		isNextBtnDisabled,
    		changeInputHandler,
    		$peopleAudienceData
    	});

    	$$self.$inject_state = $$props => {
    		if ("user_name" in $$props) $$invalidate(3, user_name = $$props.user_name);
    		if ("user_email" in $$props) $$invalidate(0, user_email = $$props.user_email);
    		if ("user_code" in $$props) $$invalidate(4, user_code = $$props.user_code);
    		if ("profileData" in $$props) profileData = $$props.profileData;
    		if ("user_email_exist" in $$props) $$invalidate(1, user_email_exist = $$props.user_email_exist);
    		if ("isNextBtnDisabled" in $$props) $$invalidate(2, isNextBtnDisabled = $$props.isNextBtnDisabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		user_email,
    		user_email_exist,
    		isNextBtnDisabled,
    		user_name,
    		user_code,
    		LANG,
    		goToNextStep,
    		goToBack,
    		changeInputHandler
    	];
    }

    class UserPersonalityBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserPersonalityBlock",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/components/UserCommunityBlock.svelte generated by Svelte v3.32.1 */
    const file$c = "src/components/UserCommunityBlock.svelte";

    function create_fragment$c(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[4]]?.community_step?.description + "";
    	let t1;
    	let form;
    	let input0;
    	let t2;
    	let input1;
    	let t3;
    	let div1;
    	let btnstandart;
    	let t4;
    	let div2;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[4]]?.community_step?.heading
    			},
    			$$inline: true
    		});

    	input0 = new Input({
    			props: {
    				name: "user_community_name",
    				wrapperClass: "mb-15",
    				value: /*user_community_name*/ ctx[2],
    				className: "form-control__input-text js-user-community-name",
    				dataInputRole: "name",
    				errorText: translations[/*LANG*/ ctx[4]]?.inputsErrors?.name,
    				placeholder: translations[/*LANG*/ ctx[4]]?.community_step?.placeholder_1
    			},
    			$$inline: true
    		});

    	input0.$on("input", /*changeInputHandler*/ ctx[6]);

    	input1 = new Input({
    			props: {
    				name: "user_community_type",
    				value: /*user_community_type*/ ctx[3],
    				wrapperClass: "mb-5",
    				className: "form-control__input-text js-user-community-type",
    				dataInputRole: "subject",
    				errorText: translations[/*LANG*/ ctx[4]]?.inputsErrors?.subject,
    				placeholder: translations[/*LANG*/ ctx[4]]?.community_step?.placeholder_2
    			},
    			$$inline: true
    		});

    	input1.$on("input", /*changeInputHandler*/ ctx[6]);

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[4]]?.community_step?.community_step_btn,
    				color: "purple",
    				btnType: /*submitBtnType*/ ctx[0],
    				disabled: /*isNextBtnDisabled*/ ctx[1]
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "user-personality-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[5]);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			form = element("form");
    			create_component(input0.$$.fragment);
    			t2 = space();
    			create_component(input1.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t4 = space();
    			div2 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$c, 95, 8, 6292);
    			html_tag = new HtmlTag(t1);
    			attr_dev(div1, "class", "mt-30");
    			add_location(div1, file$c, 127, 12, 7580);
    			attr_dev(form, "data-role", "user-community");
    			attr_dev(form, "data-step", "user-whichCRM-step");
    			add_location(form, file$c, 101, 8, 6487);
    			attr_dev(div2, "class", "mt-30");
    			add_location(div2, file$c, 138, 8, 7941);
    			attr_dev(div3, "class", "center-block__inner");
    			add_location(div3, file$c, 94, 4, 6250);
    			attr_dev(div4, "class", "center-block__content");
    			add_location(div4, file$c, 93, 0, 6210);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			mount_component(heading, div0, null);
    			append_dev(div3, t0);
    			html_tag.m(raw_value, div3);
    			append_dev(div3, t1);
    			append_dev(div3, form);
    			mount_component(input0, form, null);
    			append_dev(form, t2);
    			mount_component(input1, form, null);
    			append_dev(form, t3);
    			append_dev(form, div1);
    			mount_component(btnstandart, div1, null);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			mount_component(btnback, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[7]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const btnstandart_changes = {};
    			if (dirty & /*submitBtnType*/ 1) btnstandart_changes.btnType = /*submitBtnType*/ ctx[0];
    			if (dirty & /*isNextBtnDisabled*/ 2) btnstandart_changes.disabled = /*isNextBtnDisabled*/ ctx[1];
    			btnstandart.$set(btnstandart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(input0.$$.fragment, local);
    			transition_in(input1.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(heading);
    			destroy_component(input0);
    			destroy_component(input1);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $createdAudienceData;
    	validate_store(createdAudienceData, "createdAudienceData");
    	component_subscribe($$self, createdAudienceData, $$value => $$invalidate(8, $createdAudienceData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserCommunityBlock", slots, []);
    	let submitBtnType = "submit";

    	let user_community_name = $createdAudienceData && $createdAudienceData?.user_community_name && $createdAudienceData?.user_community_name[0]
    	? $createdAudienceData?.user_community_name[0]
    	: "";

    	let user_community_type = $createdAudienceData && $createdAudienceData?.user_community_type && $createdAudienceData?.user_community_type[0]
    	? $createdAudienceData?.user_community_type[0]
    	: "";

    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	//checking for the presence of the entered data
    	let isNextBtnDisabled = true;

    	const changeInputHandler = () => {
    		const nameInput = document.querySelector(".js-user-community-name");
    		const typeInput = document.querySelector(".js-user-community-type");
    		$$invalidate(1, isNextBtnDisabled = !(!!nameInput.value && !!typeInput.value));
    	};

    	const goToNextStep = event => {
    		const blockHolder = "user-community";
    		if (!checkStepFields(blockHolder)) return false;
    		let nextStep = event.target.dataset.step;

    		// Update localStorage with users data
    		saveEnteredUserData(blockHolder);

    		// Checking what page should we open on start app
    		(async () => {

    			const CREATE_COMMUNITY_ENDPOINT = ({
    				"env": {
    					"isProd": false,
    					"CURRENT_LANG": "en",
    					"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    					"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    					"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    					"GET_POST_ENDPOINT": "/community/posts/12",
    					"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    					"SEARCH_POST_ENDPOINT": "/community/search/16",
    					"DELETE_POST_ENDPOINT": "/post/delete/15",
    					"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    					"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    					"GET_USER_PROFILE_ENDPOINT": "/profile",
    					"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    					"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    					"LIST_TAGS_ENDPOINT": "/community/tags/12",
    					"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    					"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    					"GET_COMMUNITIES_ENDPOINT": "/community",
    					"GET_DRIVERS_ENDPOINT": "/export/drivers",
    					"GET_FIELDS_ENDPOINT": "/export/fields",
    					"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    					"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    					"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    					"EXPORT_RULES_ENDPOINT": "/export"
    				}
    			}).env.CREATE_COMMUNITY_ENDPOINT;

    			const dataToSent = {
    				"name": $createdAudienceData.user_community_name[0],
    				"company": $createdAudienceData.user_community_type[0]
    			};

    			$$invalidate(0, submitBtnType = "loader");
    			let res = await makeRequestToBackend(dataToSent, CREATE_COMMUNITY_ENDPOINT, "POST", true);
    			$$invalidate(0, submitBtnType = "submit");

    			// Access isn't authorized
    			if (res.status === 401) {
    				nextStep = "login-step";
    				return;
    			}

    			createdCommunityData.update(n => JSON.parse(res));

    			//console.log('createdCommunityData', $createdCommunityData);
    			// TODO: Add error catching
    			dispatch("goToStep", { step: nextStep });
    		})();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserCommunityBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		saveEnteredUserData,
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		BtnBack,
    		Input,
    		Heading,
    		createdCommunityData,
    		createdAudienceData,
    		makeRequestToBackend,
    		submitBtnType,
    		user_community_name,
    		user_community_type,
    		dispatch,
    		LANG,
    		goToBack,
    		isNextBtnDisabled,
    		changeInputHandler,
    		goToNextStep,
    		$createdAudienceData
    	});

    	$$self.$inject_state = $$props => {
    		if ("submitBtnType" in $$props) $$invalidate(0, submitBtnType = $$props.submitBtnType);
    		if ("user_community_name" in $$props) $$invalidate(2, user_community_name = $$props.user_community_name);
    		if ("user_community_type" in $$props) $$invalidate(3, user_community_type = $$props.user_community_type);
    		if ("isNextBtnDisabled" in $$props) $$invalidate(1, isNextBtnDisabled = $$props.isNextBtnDisabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		submitBtnType,
    		isNextBtnDisabled,
    		user_community_name,
    		user_community_type,
    		LANG,
    		goToBack,
    		changeInputHandler,
    		goToNextStep
    	];
    }

    class UserCommunityBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserCommunityBlock",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /*!
     * cookie
     * Copyright(c) 2012-2014 Roman Shtylman
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     * @public
     */

    var parse_1 = parse;
    var serialize_1 = serialize;

    /**
     * Module variables.
     * @private
     */

    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;

    /**
     * RegExp to match field-content in RFC 7230 sec 3.2
     *
     * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     * field-vchar   = VCHAR / obs-text
     * obs-text      = %x80-FF
     */

    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

    /**
     * Parse a cookie header.
     *
     * Parse the given cookie header string into an object
     * The object has the various cookies as keys(names) => values
     *
     * @param {string} str
     * @param {object} [options]
     * @return {object}
     * @public
     */

    function parse(str, options) {
      if (typeof str !== 'string') {
        throw new TypeError('argument str must be a string');
      }

      var obj = {};
      var opt = options || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;

      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var eq_idx = pair.indexOf('=');

        // skip things that don't look like key=value
        if (eq_idx < 0) {
          continue;
        }

        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();

        // quoted values
        if ('"' == val[0]) {
          val = val.slice(1, -1);
        }

        // only assign once
        if (undefined == obj[key]) {
          obj[key] = tryDecode(val, dec);
        }
      }

      return obj;
    }

    /**
     * Serialize data into a cookie header.
     *
     * Serialize the a name value pair into a cookie string suitable for
     * http headers. An optional options object specified cookie parameters.
     *
     * serialize('foo', 'bar', { httpOnly: true })
     *   => "foo=bar; httpOnly"
     *
     * @param {string} name
     * @param {string} val
     * @param {object} [options]
     * @return {string}
     * @public
     */

    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;

      if (typeof enc !== 'function') {
        throw new TypeError('option encode is invalid');
      }

      if (!fieldContentRegExp.test(name)) {
        throw new TypeError('argument name is invalid');
      }

      var value = enc(val);

      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError('argument val is invalid');
      }

      var str = name + '=' + value;

      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;

        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError('option maxAge is invalid')
        }

        str += '; Max-Age=' + Math.floor(maxAge);
      }

      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError('option domain is invalid');
        }

        str += '; Domain=' + opt.domain;
      }

      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError('option path is invalid');
        }

        str += '; Path=' + opt.path;
      }

      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== 'function') {
          throw new TypeError('option expires is invalid');
        }

        str += '; Expires=' + opt.expires.toUTCString();
      }

      if (opt.httpOnly) {
        str += '; HttpOnly';
      }

      if (opt.secure) {
        str += '; Secure';
      }

      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === 'string'
          ? opt.sameSite.toLowerCase() : opt.sameSite;

        switch (sameSite) {
          case true:
            str += '; SameSite=Strict';
            break;
          case 'lax':
            str += '; SameSite=Lax';
            break;
          case 'strict':
            str += '; SameSite=Strict';
            break;
          case 'none':
            str += '; SameSite=None';
            break;
          default:
            throw new TypeError('option sameSite is invalid');
        }
      }

      return str;
    }

    /**
     * Try decoding a string using a decoding function.
     *
     * @param {string} str
     * @param {function} decode
     * @private
     */

    function tryDecode(str, decode) {
      try {
        return decode(str);
      } catch (e) {
        return str;
      }
    }

    function hasDocumentCookie() {
        // Can we get/set cookies on document.cookie?
        return typeof document === 'object' && typeof document.cookie === 'string';
    }
    function parseCookies(cookies, options) {
        if (typeof cookies === 'string') {
            return parse_1(cookies, options);
        }
        else if (typeof cookies === 'object' && cookies !== null) {
            return cookies;
        }
        else {
            return {};
        }
    }
    function isParsingCookie(value, doNotParse) {
        if (typeof doNotParse === 'undefined') {
            // We guess if the cookie start with { or [, it has been serialized
            doNotParse =
                !value || (value[0] !== '{' && value[0] !== '[' && value[0] !== '"');
        }
        return !doNotParse;
    }
    function readCookie(value, options) {
        if (options === void 0) { options = {}; }
        var cleanValue = cleanupCookieValue(value);
        if (isParsingCookie(cleanValue, options.doNotParse)) {
            try {
                return JSON.parse(cleanValue);
            }
            catch (e) {
                // At least we tried
            }
        }
        // Ignore clean value if we failed the deserialization
        // It is not relevant anymore to trim those values
        return value;
    }
    function cleanupCookieValue(value) {
        // express prepend j: before serializing a cookie
        if (value && value[0] === 'j' && value[1] === ':') {
            return value.substr(2);
        }
        return value;
    }

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var Cookies = /** @class */ (function () {
        function Cookies(cookies, options) {
            var _this = this;
            this.changeListeners = [];
            this.HAS_DOCUMENT_COOKIE = false;
            this.cookies = parseCookies(cookies, options);
            new Promise(function () {
                _this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();
            }).catch(function () { });
        }
        Cookies.prototype._updateBrowserValues = function (parseOptions) {
            if (!this.HAS_DOCUMENT_COOKIE) {
                return;
            }
            this.cookies = parse_1(document.cookie, parseOptions);
        };
        Cookies.prototype._emitChange = function (params) {
            for (var i = 0; i < this.changeListeners.length; ++i) {
                this.changeListeners[i](params);
            }
        };
        Cookies.prototype.get = function (name, options, parseOptions) {
            if (options === void 0) { options = {}; }
            this._updateBrowserValues(parseOptions);
            return readCookie(this.cookies[name], options);
        };
        Cookies.prototype.getAll = function (options, parseOptions) {
            if (options === void 0) { options = {}; }
            this._updateBrowserValues(parseOptions);
            var result = {};
            for (var name_1 in this.cookies) {
                result[name_1] = readCookie(this.cookies[name_1], options);
            }
            return result;
        };
        Cookies.prototype.set = function (name, value, options) {
            var _a;
            if (typeof value === 'object') {
                value = JSON.stringify(value);
            }
            this.cookies = __assign(__assign({}, this.cookies), (_a = {}, _a[name] = value, _a));
            if (this.HAS_DOCUMENT_COOKIE) {
                document.cookie = serialize_1(name, value, options);
            }
            this._emitChange({ name: name, value: value, options: options });
        };
        Cookies.prototype.remove = function (name, options) {
            var finalOptions = (options = __assign(__assign({}, options), { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 }));
            this.cookies = __assign({}, this.cookies);
            delete this.cookies[name];
            if (this.HAS_DOCUMENT_COOKIE) {
                document.cookie = serialize_1(name, '', finalOptions);
            }
            this._emitChange({ name: name, value: undefined, options: options });
        };
        Cookies.prototype.addChangeListener = function (callback) {
            this.changeListeners.push(callback);
        };
        Cookies.prototype.removeChangeListener = function (callback) {
            var idx = this.changeListeners.indexOf(callback);
            if (idx >= 0) {
                this.changeListeners.splice(idx, 1);
            }
        };
        return Cookies;
    }());

    /* src/components/UserWhichCRMBlock.svelte generated by Svelte v3.32.1 */
    const file$d = "src/components/UserWhichCRMBlock.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (304:16) {#if listCRM}
    function create_if_block$4(ctx) {
    	let each_1_anchor;
    	let each_value = /*listCRM*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*listCRM, scoops, changeInputHandler*/ 35) {
    				each_value = /*listCRM*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(304:16) {#if listCRM}",
    		ctx
    	});

    	return block;
    }

    // (305:20) {#each listCRM as name, i}
    function create_each_block(ctx) {
    	let div;
    	let input;
    	let input_value_value;
    	let t0;
    	let span;
    	let t1_value = /*listCRM*/ ctx[1][/*i*/ ctx[12]] + "";
    	let t1;
    	let t2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "data-input-role", "name");
    			attr_dev(input, "name", "user_crm_name");
    			input.__value = input_value_value = /*listCRM*/ ctx[1][/*i*/ ctx[12]];
    			input.value = input.__value;
    			attr_dev(input, "class", "input-control__input js-check-input svelte-8tg9cb");
    			/*$$binding_groups*/ ctx[8][0].push(input);
    			add_location(input, file$d, 306, 28, 10148);
    			attr_dev(span, "class", "crm-block other-crm svelte-8tg9cb");
    			add_location(span, file$d, 313, 28, 10564);
    			attr_dev(div, "class", "input-control svelte-8tg9cb");
    			add_location(div, file$d, 305, 24, 10092);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			input.checked = input.__value === /*scoops*/ ctx[0];
    			append_dev(div, t0);
    			append_dev(div, span);
    			append_dev(span, t1);
    			append_dev(div, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[7]),
    					listen_dev(input, "input", /*changeInputHandler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*listCRM*/ 2 && input_value_value !== (input_value_value = /*listCRM*/ ctx[1][/*i*/ ctx[12]])) {
    				prop_dev(input, "__value", input_value_value);
    				input.value = input.__value;
    			}

    			if (dirty & /*scoops*/ 1) {
    				input.checked = input.__value === /*scoops*/ ctx[0];
    			}

    			if (dirty & /*listCRM*/ 2 && t1_value !== (t1_value = /*listCRM*/ ctx[1][/*i*/ ctx[12]] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*$$binding_groups*/ ctx[8][0].splice(/*$$binding_groups*/ ctx[8][0].indexOf(input), 1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(305:20) {#each listCRM as name, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div5;
    	let div4;
    	let div0;
    	let heading;
    	let t0;
    	let form;
    	let div1;
    	let t1;
    	let div2;
    	let btnstandart;
    	let t2;
    	let div3;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[3]]?.which_crm?.heading
    			},
    			$$inline: true
    		});

    	let if_block = /*listCRM*/ ctx[1] && create_if_block$4(ctx);

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[3]].which_crm.which_crm_btn,
    				btnType: "submit",
    				disabled: /*isNextBtnDisabled*/ ctx[2]
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "user-community-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			form = element("form");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t1 = space();
    			div2 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$d, 296, 8, 9675);
    			attr_dev(div1, "class", "d-flex justify-content-center flex-wrap");
    			add_location(div1, file$d, 302, 12, 9937);
    			attr_dev(div2, "class", "mt-30");
    			add_location(div2, file$d, 319, 12, 10731);
    			attr_dev(form, "data-step", "user-setApiKey-step");
    			attr_dev(form, "data-role", "user-which-crm");
    			add_location(form, file$d, 299, 8, 9791);
    			attr_dev(div3, "class", "mt-30");
    			add_location(div3, file$d, 326, 8, 10982);
    			attr_dev(div4, "class", "center-block__inner");
    			add_location(div4, file$d, 295, 4, 9633);
    			attr_dev(div5, "class", "center-block__content");
    			add_location(div5, file$d, 294, 0, 9593);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			mount_component(heading, div0, null);
    			append_dev(div4, t0);
    			append_dev(div4, form);
    			append_dev(form, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(form, t1);
    			append_dev(form, div2);
    			mount_component(btnstandart, div2, null);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			mount_component(btnback, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[6]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*listCRM*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const btnstandart_changes = {};
    			if (dirty & /*isNextBtnDisabled*/ 4) btnstandart_changes.disabled = /*isNextBtnDisabled*/ ctx[2];
    			btnstandart.$set(btnstandart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(heading);
    			if (if_block) if_block.d();
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserWhichCRMBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let scoops = "user-which-crm";
    	let listCRM = [];

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	//checking for the presence of the entered data
    	let isNextBtnDisabled = true;

    	const changeInputHandler = () => {
    		const nameInput = document.querySelector(".js-check-input");
    		$$invalidate(2, isNextBtnDisabled = !!!nameInput.value);
    	};

    	(async () => {
    		new Cookies();

    		/*if ( IS_DEV !== 'true') {
    	// Prevent access for user if he doesn't authorized
    	if ( !LARAVEL_SESSION ) {
    		nextStep = 'login-step';
    		return;
    	}
    }*/
    		const GET_DRIVERS_ENDPOINT = ({
    			"env": {
    				"isProd": false,
    				"CURRENT_LANG": "en",
    				"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    				"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    				"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    				"GET_POST_ENDPOINT": "/community/posts/12",
    				"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    				"SEARCH_POST_ENDPOINT": "/community/search/16",
    				"DELETE_POST_ENDPOINT": "/post/delete/15",
    				"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    				"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    				"GET_USER_PROFILE_ENDPOINT": "/profile",
    				"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    				"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    				"LIST_TAGS_ENDPOINT": "/community/tags/12",
    				"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    				"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    				"GET_COMMUNITIES_ENDPOINT": "/community",
    				"GET_DRIVERS_ENDPOINT": "/export/drivers",
    				"GET_FIELDS_ENDPOINT": "/export/fields",
    				"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    				"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    				"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    				"EXPORT_RULES_ENDPOINT": "/export"
    			}
    		}).env.GET_DRIVERS_ENDPOINT;

    		let res = await makeRequestToBackend(false, GET_DRIVERS_ENDPOINT, "GET");

    		// Access isn't authorized
    		if (res.status === 401) {
    			nextStep = "login-step";
    			return;
    		}

    		createdDriversData.update(n => JSON.parse(res));

    		//console.log('createdDriversData', $createdDriversData);
    		$$invalidate(1, listCRM = JSON.parse(res));
    	})();

    	const goToNextStep = event => {
    		// Update localStorage with users data
    		saveEnteredUserData("user-which-crm");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserWhichCRMBlock> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		scoops = this.__value;
    		$$invalidate(0, scoops);
    	}

    	$$self.$capture_state = () => ({
    		makeRequestToBackend,
    		saveEnteredUserData,
    		createEventDispatcher,
    		translations,
    		BtnBack,
    		BtnStandart,
    		Heading,
    		Cookies,
    		createdDriversData,
    		dispatch,
    		LANG,
    		scoops,
    		listCRM,
    		goToBack,
    		isNextBtnDisabled,
    		changeInputHandler,
    		goToNextStep
    	});

    	$$self.$inject_state = $$props => {
    		if ("scoops" in $$props) $$invalidate(0, scoops = $$props.scoops);
    		if ("listCRM" in $$props) $$invalidate(1, listCRM = $$props.listCRM);
    		if ("isNextBtnDisabled" in $$props) $$invalidate(2, isNextBtnDisabled = $$props.isNextBtnDisabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		scoops,
    		listCRM,
    		isNextBtnDisabled,
    		LANG,
    		goToBack,
    		changeInputHandler,
    		goToNextStep,
    		input_change_handler,
    		$$binding_groups
    	];
    }

    class UserWhichCRMBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserWhichCRMBlock",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/components/UserSetApiKeyBlock.svelte generated by Svelte v3.32.1 */
    const file$e = "src/components/UserSetApiKeyBlock.svelte";

    function create_fragment$e(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let heading;
    	let t0;
    	let form;
    	let div3;
    	let div1;
    	let video;
    	let source;
    	let source_src_value;
    	let video_is_paused = true;
    	let t1;
    	let span;
    	let span_class_value;
    	let t2;
    	let div2;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[4]].set_api_key.description + "";
    	let t3;
    	let input;
    	let t4;
    	let div4;
    	let btnstandart;
    	let t5;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[4]]?.set_api_key?.heading
    			},
    			$$inline: true
    		});

    	input = new Input({
    			props: {
    				wrapperClass: "ml-0",
    				className: "form-control__input-text js-check-input",
    				name: "user_api_key",
    				dataInputRole: "subject",
    				value: /*user_api_key*/ ctx[3],
    				errorText: translations[/*LANG*/ ctx[4]]?.inputsErrors?.subject,
    				placeholder: translations[/*LANG*/ ctx[4]].set_api_key.placeholder
    			},
    			$$inline: true
    		});

    	input.$on("input", /*changeInputHandler*/ ctx[7]);

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[4]].set_api_key.set_api_key_btn,
    				color: "purple",
    				btnType: /*submitBtnType*/ ctx[5],
    				disabled: /*isNextBtnDisabled*/ ctx[0]
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "user-whichCRM-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			form = element("form");
    			div3 = element("div");
    			div1 = element("div");
    			video = element("video");
    			source = element("source");
    			t1 = space();
    			span = element("span");
    			t2 = space();
    			div2 = element("div");
    			t3 = space();
    			create_component(input.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$e, 96, 8, 3909);
    			if (source.src !== (source_src_value = "../../video/svelteJS.mp4")) attr_dev(source, "src", source_src_value);
    			add_location(source, file$e, 111, 24, 4461);
    			video.controls = "controls";
    			attr_dev(video, "poster", "./images/video-poster.png");
    			attr_dev(video, "class", "svelte-vcode8");
    			add_location(video, file$e, 108, 20, 4282);
    			attr_dev(span, "class", span_class_value = "play " + (/*paused*/ ctx[2] ? "" : "active") + " svelte-vcode8");
    			add_location(span, file$e, 113, 20, 4550);
    			attr_dev(div1, "class", "video-api svelte-vcode8");
    			add_location(div1, file$e, 107, 16, 4238);
    			html_tag = new HtmlTag(t3);
    			add_location(div2, file$e, 117, 16, 4712);
    			attr_dev(div3, "class", "d-flex align-items-flex-end");
    			add_location(div3, file$e, 105, 12, 4179);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$e, 133, 12, 5371);
    			attr_dev(form, "data-role", "user-api-key");
    			attr_dev(form, "data-step", "user-import-step");
    			add_location(form, file$e, 100, 8, 4028);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$e, 141, 8, 5677);
    			attr_dev(div6, "class", "center-block__inner center-block__inner-api-mod svelte-vcode8");
    			add_location(div6, file$e, 95, 4, 3839);
    			attr_dev(div7, "class", "center-block__content");
    			add_location(div7, file$e, 94, 0, 3799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			mount_component(heading, div0, null);
    			append_dev(div6, t0);
    			append_dev(div6, form);
    			append_dev(form, div3);
    			append_dev(div3, div1);
    			append_dev(div1, video);
    			append_dev(video, source);
    			/*video_binding*/ ctx[10](video);
    			append_dev(div1, t1);
    			append_dev(div1, span);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			html_tag.m(raw_value, div2);
    			append_dev(div2, t3);
    			mount_component(input, div2, null);
    			append_dev(form, t4);
    			append_dev(form, div4);
    			mount_component(btnstandart, div4, null);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(video, "play", /*video_play_pause_handler*/ ctx[9]),
    					listen_dev(video, "pause", /*video_play_pause_handler*/ ctx[9]),
    					listen_dev(span, "click", /*click_handler*/ ctx[11], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[8]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*paused*/ 4 && video_is_paused !== (video_is_paused = /*paused*/ ctx[2])) {
    				video[video_is_paused ? "pause" : "play"]();
    			}

    			if (!current || dirty & /*paused*/ 4 && span_class_value !== (span_class_value = "play " + (/*paused*/ ctx[2] ? "" : "active") + " svelte-vcode8")) {
    				attr_dev(span, "class", span_class_value);
    			}

    			const btnstandart_changes = {};
    			if (dirty & /*isNextBtnDisabled*/ 1) btnstandart_changes.disabled = /*isNextBtnDisabled*/ ctx[0];
    			btnstandart.$set(btnstandart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(input.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(input.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(heading);
    			/*video_binding*/ ctx[10](null);
    			destroy_component(input);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $exportFieldsData;
    	validate_store(exportFieldsData, "exportFieldsData");
    	component_subscribe($$self, exportFieldsData, $$value => $$invalidate(12, $exportFieldsData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserSetApiKeyBlock", slots, []);

    	let user_api_key = $exportFieldsData && $exportFieldsData?.key
    	? $exportFieldsData?.key
    	: "";

    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let submitBtnType = "submit";

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	//checking for the presence of the entered data
    	let isNextBtnDisabled = true;

    	const changeInputHandler = () => {
    		const nameInput = document.querySelector(".js-check-input");
    		$$invalidate(0, isNextBtnDisabled = !!!nameInput.value);
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("user-api-key")) return false;

    		// Update localStorage with users data
    		saveEnteredUserData("user-api-key");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let videoplayer;
    	let paused = true;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserSetApiKeyBlock> was created with unknown prop '${key}'`);
    	});

    	function video_play_pause_handler() {
    		paused = this.paused;
    		$$invalidate(2, paused);
    	}

    	function video_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			videoplayer = $$value;
    			$$invalidate(1, videoplayer);
    		});
    	}

    	const click_handler = function () {
    		paused ? videoplayer.play() : videoplayer.pause();
    	};

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		saveEnteredUserData,
    		createEventDispatcher,
    		translations,
    		BtnBack,
    		BtnStandart,
    		Input,
    		Heading,
    		exportFieldsData,
    		user_api_key,
    		dispatch,
    		LANG,
    		submitBtnType,
    		goToBack,
    		isNextBtnDisabled,
    		changeInputHandler,
    		goToNextStep,
    		videoplayer,
    		paused,
    		$exportFieldsData
    	});

    	$$self.$inject_state = $$props => {
    		if ("user_api_key" in $$props) $$invalidate(3, user_api_key = $$props.user_api_key);
    		if ("submitBtnType" in $$props) $$invalidate(5, submitBtnType = $$props.submitBtnType);
    		if ("isNextBtnDisabled" in $$props) $$invalidate(0, isNextBtnDisabled = $$props.isNextBtnDisabled);
    		if ("videoplayer" in $$props) $$invalidate(1, videoplayer = $$props.videoplayer);
    		if ("paused" in $$props) $$invalidate(2, paused = $$props.paused);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isNextBtnDisabled,
    		videoplayer,
    		paused,
    		user_api_key,
    		LANG,
    		submitBtnType,
    		goToBack,
    		changeInputHandler,
    		goToNextStep,
    		video_play_pause_handler,
    		video_binding,
    		click_handler
    	];
    }

    class UserSetApiKeyBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserSetApiKeyBlock",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/components/inputs/Select.svelte generated by Svelte v3.32.1 */
    const file$f = "src/components/inputs/Select.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (325:4) {#if label}
    function create_if_block_1$3(ctx) {
    	let label_1;

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			attr_dev(label_1, "for", /*id*/ ctx[1]);
    			attr_dev(label_1, "class", "form-control__label svelte-174rzuu");
    			add_location(label_1, file$f, 325, 8, 9960);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			label_1.innerHTML = /*label*/ ctx[4];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 16) label_1.innerHTML = /*label*/ ctx[4];
    			if (dirty & /*id*/ 2) {
    				attr_dev(label_1, "for", /*id*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(325:4) {#if label}",
    		ctx
    	});

    	return block;
    }

    // (335:8) {#if optionObject}
    function create_if_block$5(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let each_value = /*optionObject*/ ctx[5];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*name*/ ctx[9];
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*optionObject*/ 32) {
    				each_value = /*optionObject*/ ctx[5];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
    			}
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(335:8) {#if optionObject}",
    		ctx
    	});

    	return block;
    }

    // (336:12) {#each optionObject as name (name)}
    function create_each_block$1(key_1, ctx) {
    	let option;
    	let t_value = /*name*/ ctx[9] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*name*/ ctx[9];
    			option.value = option.__value;
    			add_location(option, file$f, 336, 16, 10357);
    			this.first = option;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*optionObject*/ 32 && t_value !== (t_value = /*name*/ ctx[9] + "")) set_data_dev(t, t_value);

    			if (dirty & /*optionObject*/ 32 && option_value_value !== (option_value_value = /*name*/ ctx[9])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(336:12) {#each optionObject as name (name)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div;
    	let t;
    	let select;
    	let select_class_value;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block0 = /*label*/ ctx[4] && create_if_block_1$3(ctx);
    	let if_block1 = /*optionObject*/ ctx[5] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			select = element("select");
    			if (if_block1) if_block1.c();
    			attr_dev(select, "name", /*name*/ ctx[9]);
    			attr_dev(select, "id", /*id*/ ctx[1]);
    			attr_dev(select, "class", select_class_value = "" + (null_to_empty(/*className*/ ctx[2] + " " + /*valueReadOnly*/ ctx[7]) + " svelte-174rzuu"));
    			attr_dev(select, "data-input-role", /*dataInputRole*/ ctx[6]);
    			attr_dev(select, "data-group-index", /*groupIndex*/ ctx[8]);
    			if (/*selectedValue*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[10].call(select));
    			add_location(select, file$f, 328, 4, 10047);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`form-control ${/*wrapperClass*/ ctx[3]}`) + " svelte-174rzuu"));
    			add_location(div, file$f, 323, 0, 9891);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			append_dev(div, select);
    			if (if_block1) if_block1.m(select, null);
    			select_option(select, /*selectedValue*/ ctx[0]);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[10]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*optionObject*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					if_block1.m(select, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*name*/ 512) {
    				attr_dev(select, "name", /*name*/ ctx[9]);
    			}

    			if (dirty & /*id*/ 2) {
    				attr_dev(select, "id", /*id*/ ctx[1]);
    			}

    			if (dirty & /*className, valueReadOnly*/ 132 && select_class_value !== (select_class_value = "" + (null_to_empty(/*className*/ ctx[2] + " " + /*valueReadOnly*/ ctx[7]) + " svelte-174rzuu"))) {
    				attr_dev(select, "class", select_class_value);
    			}

    			if (dirty & /*dataInputRole*/ 64) {
    				attr_dev(select, "data-input-role", /*dataInputRole*/ ctx[6]);
    			}

    			if (dirty & /*groupIndex*/ 256) {
    				attr_dev(select, "data-group-index", /*groupIndex*/ ctx[8]);
    			}

    			if (dirty & /*selectedValue, optionObject*/ 33) {
    				select_option(select, /*selectedValue*/ ctx[0]);
    			}

    			if (dirty & /*wrapperClass*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(`form-control ${/*wrapperClass*/ ctx[3]}`) + " svelte-174rzuu"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Select", slots, []);
    	const dispatch = createEventDispatcher();
    	let { id = "" } = $$props;
    	let { name = "" } = $$props;
    	let { className = "select" } = $$props;
    	let { wrapperClass = "" } = $$props;
    	let { label = "" } = $$props;
    	let { optionObject = [] } = $$props;
    	let { dataInputRole = "" } = $$props;
    	let { valueReadOnly = "" } = $$props;
    	let { groupIndex = "" } = $$props;
    	let { selectedValue = "" } = $$props;

    	const writable_props = [
    		"id",
    		"name",
    		"className",
    		"wrapperClass",
    		"label",
    		"optionObject",
    		"dataInputRole",
    		"valueReadOnly",
    		"groupIndex",
    		"selectedValue"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		selectedValue = select_value(this);
    		$$invalidate(0, selectedValue);
    		$$invalidate(5, optionObject);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("name" in $$props) $$invalidate(9, name = $$props.name);
    		if ("className" in $$props) $$invalidate(2, className = $$props.className);
    		if ("wrapperClass" in $$props) $$invalidate(3, wrapperClass = $$props.wrapperClass);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("optionObject" in $$props) $$invalidate(5, optionObject = $$props.optionObject);
    		if ("dataInputRole" in $$props) $$invalidate(6, dataInputRole = $$props.dataInputRole);
    		if ("valueReadOnly" in $$props) $$invalidate(7, valueReadOnly = $$props.valueReadOnly);
    		if ("groupIndex" in $$props) $$invalidate(8, groupIndex = $$props.groupIndex);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		id,
    		name,
    		className,
    		wrapperClass,
    		label,
    		optionObject,
    		dataInputRole,
    		valueReadOnly,
    		groupIndex,
    		selectedValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("name" in $$props) $$invalidate(9, name = $$props.name);
    		if ("className" in $$props) $$invalidate(2, className = $$props.className);
    		if ("wrapperClass" in $$props) $$invalidate(3, wrapperClass = $$props.wrapperClass);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("optionObject" in $$props) $$invalidate(5, optionObject = $$props.optionObject);
    		if ("dataInputRole" in $$props) $$invalidate(6, dataInputRole = $$props.dataInputRole);
    		if ("valueReadOnly" in $$props) $$invalidate(7, valueReadOnly = $$props.valueReadOnly);
    		if ("groupIndex" in $$props) $$invalidate(8, groupIndex = $$props.groupIndex);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedValue,
    		id,
    		className,
    		wrapperClass,
    		label,
    		optionObject,
    		dataInputRole,
    		valueReadOnly,
    		groupIndex,
    		name,
    		select_change_handler
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			id: 1,
    			name: 9,
    			className: 2,
    			wrapperClass: 3,
    			label: 4,
    			optionObject: 5,
    			dataInputRole: 6,
    			valueReadOnly: 7,
    			groupIndex: 8,
    			selectedValue: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get id() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapperClass() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapperClass(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionObject() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionObject(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataInputRole() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataInputRole(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueReadOnly() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueReadOnly(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupIndex() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupIndex(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * Watching elem's size changes. If something
     * is changed, calling callback function.
     * Returns unsubscribe method (watch stopper).
     *
     * MODERN: via ResizeObserver
     * LEGACY: via requestAnimationFrame
     *
     * @param elem
     * @param callback
     * @returns {unsubscribe}
     */
    function createObserver(elem, callback) {
      const trueObserverSupported = typeof window.ResizeObserver !== 'undefined';
      let unsubscribe;

      if (trueObserverSupported) {
        const ro = new ResizeObserver((entries) => {
          for (const entry of entries) {
            callback();
          }
        });
        ro.observe(elem);
        unsubscribe = () => {
          ro.unobserve(elem);
          ro.disconnect();
        };
      } else {
        let lastHeight = null;
        let frameRequester;

        function getElemOffsetHeight() {
          const height = elem.offsetHeight;
          if (lastHeight !== null && lastHeight !== height) {
            callback();
          }
          lastHeight = height;
          frameRequester = requestAnimationFrame(getElemOffsetHeight);
        }

        frameRequester = requestAnimationFrame(getElemOffsetHeight);
        unsubscribe = () => {
          cancelAnimationFrame(frameRequester);
        };
      }

      return unsubscribe;
    }

    /* node_modules/happy-svelte-scrollbar/src/Thumb.svelte generated by Svelte v3.32.1 */
    const file$g = "node_modules/happy-svelte-scrollbar/src/Thumb.svelte";

    function create_fragment$g(ctx) {
    	let div;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "height", /*thumbHeight*/ ctx[3]);
    			set_style(div, "top", /*thumbTop*/ ctx[4]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*className*/ ctx[0]) + " svelte-1f9qc2h"));
    			toggle_class(div, "happy-scroll-thumb", true);
    			toggle_class(div, "no-scroll", /*noScroll*/ ctx[5]);
    			toggle_class(div, "smooth", /*smooth*/ ctx[1]);
    			add_location(div, file$g, 133, 0, 4268);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[13](div);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*thumbHeight*/ 8) {
    				set_style(div, "height", /*thumbHeight*/ ctx[3]);
    			}

    			if (dirty & /*thumbTop*/ 16) {
    				set_style(div, "top", /*thumbTop*/ ctx[4]);
    			}

    			if (dirty & /*className*/ 1 && div_class_value !== (div_class_value = "" + (null_to_empty(/*className*/ ctx[0]) + " svelte-1f9qc2h"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*className*/ 1) {
    				toggle_class(div, "happy-scroll-thumb", true);
    			}

    			if (dirty & /*className, noScroll*/ 33) {
    				toggle_class(div, "no-scroll", /*noScroll*/ ctx[5]);
    			}

    			if (dirty & /*className, smooth*/ 3) {
    				toggle_class(div, "smooth", /*smooth*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[13](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Thumb", slots, []);
    	let { className = "scrollbar-thumb" } = $$props;
    	let { wrapperElem = null } = $$props;
    	let { observerTarget = null } = $$props;
    	let { smooth = false } = $$props;
    	let { trackElem = null } = $$props;
    	let { pressingUp = false } = $$props;
    	let { pressingDown = false } = $$props;
    	let { buttonPressingMove = 5 } = $$props;
    	let { showArrows } = $$props;
    	const dispatch = createEventDispatcher();
    	const heightReducer = showArrows ? 40 : 0;
    	let thumbElem;
    	let thumbHeight = "0px";
    	let thumbTop = "0px";
    	let noScroll = true;
    	let pos = { top: 0, y: 0 };
    	let unsubscribeObserver;

    	/**
     * Calculating and setting new Height and Top of thumb
     */
    	function calcThumbHeight() {
    		const maxHeight = wrapperElem.scrollHeight - heightReducer;
    		const visibleArea = wrapperElem.offsetHeight - heightReducer;
    		const currentScrolled = wrapperElem.scrollTop;
    		const visiblePercent = visibleArea / maxHeight * 100;
    		const scrolledPercent = currentScrolled / maxHeight * 100;
    		$$invalidate(4, thumbTop = visibleArea / 100 * scrolledPercent + "px");
    		$$invalidate(3, thumbHeight = visiblePercent + "%");
    		$$invalidate(5, noScroll = thumbHeight === "100%");
    	}

    	/**
     * Common handler for "touchmove" and "mousemove"
     * @param {MouseEvent|TouchEvent} e
     */
    	function thumbInteractionHappening(e) {
    		e.preventDefault();
    		e.stopPropagation();

    		const clientY = e.type === "touchmove"
    		? e.changedTouches[0].clientY
    		: e.clientY;

    		const dy = clientY - pos.y;
    		$$invalidate(6, wrapperElem.scrollTop = pos.top + dy, wrapperElem);
    	}

    	/**
     * Common handler for "touchend" and "mouseup"
     */
    	function thumbInteractionEnd() {
    		setTimeout(() => {
    			dispatch("unlock-click");
    		});

    		document.body.style.userSelect = "inherit";
    		document.removeEventListener("mousemove", thumbInteractionHappening);
    		document.removeEventListener("mouseup", thumbInteractionEnd);
    		document.removeEventListener("touchmove", thumbInteractionHappening);
    		document.removeEventListener("touchend", thumbInteractionEnd);
    	}

    	/**
     * Common handler from "touchstart" and "mousedown
     * @param {MouseEvent|TouchEvent} e
     */
    	function thumbInteractionStart(e) {
    		dispatch("lock-click");
    		e.preventDefault();
    		e.stopPropagation();

    		pos = {
    			top: wrapperElem.scrollTop,
    			y: e.type === "touchstart"
    			? e.changedTouches[0].clientY
    			: e.clientY
    		};

    		document.body.style.userSelect = "none";

    		if (e.type === "touchstart") {
    			document.addEventListener("touchmove", thumbInteractionHappening);
    			document.addEventListener("touchend", thumbInteractionEnd);
    		} else {
    			document.addEventListener("mousemove", thumbInteractionHappening);
    			document.addEventListener("mouseup", thumbInteractionEnd);
    		}
    	}

    	/**
     * Setting position and size for
     * track element
     */
    	function initTrackBar() {
    		$$invalidate(7, trackElem.style.top = wrapperElem.offsetTop + heightReducer / 2 + "px", trackElem);
    		$$invalidate(7, trackElem.style.height = wrapperElem.offsetHeight - heightReducer + "px", trackElem);
    	}

    	onMount(() => {
    		initTrackBar();
    		thumbElem.addEventListener("mousedown", thumbInteractionStart);
    		thumbElem.addEventListener("touchstart", thumbInteractionStart);
    		wrapperElem.addEventListener("scroll", calcThumbHeight);
    		window.addEventListener("resize", initTrackBar);

    		let observerElem = observerTarget.$$
    		? observerTarget.happyObserverTarget()
    		: observerTarget;

    		unsubscribeObserver = createObserver(observerElem, () => calcThumbHeight());
    	});

    	onDestroy(() => {
    		thumbElem.removeEventListener("mousedown", thumbInteractionStart);
    		thumbElem.removeEventListener("touchstart", thumbInteractionStart);
    		window.removeEventListener("resize", initTrackBar);
    		unsubscribeObserver();
    	});

    	function buttonScrollDown(pressing) {
    		if (!pressing) return;

    		requestAnimationFrame(() => {
    			$$invalidate(6, wrapperElem.scrollTop += buttonPressingMove, wrapperElem);
    			buttonScrollDown(pressingDown);
    		});
    	}

    	function buttonScrollUp(pressing) {
    		if (!pressing) return;

    		requestAnimationFrame(() => {
    			$$invalidate(6, wrapperElem.scrollTop -= buttonPressingMove, wrapperElem);
    			buttonScrollUp(pressingUp);
    		});
    	}

    	const writable_props = [
    		"className",
    		"wrapperElem",
    		"observerTarget",
    		"smooth",
    		"trackElem",
    		"pressingUp",
    		"pressingDown",
    		"buttonPressingMove",
    		"showArrows"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Thumb> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			thumbElem = $$value;
    			$$invalidate(2, thumbElem);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("className" in $$props) $$invalidate(0, className = $$props.className);
    		if ("wrapperElem" in $$props) $$invalidate(6, wrapperElem = $$props.wrapperElem);
    		if ("observerTarget" in $$props) $$invalidate(8, observerTarget = $$props.observerTarget);
    		if ("smooth" in $$props) $$invalidate(1, smooth = $$props.smooth);
    		if ("trackElem" in $$props) $$invalidate(7, trackElem = $$props.trackElem);
    		if ("pressingUp" in $$props) $$invalidate(9, pressingUp = $$props.pressingUp);
    		if ("pressingDown" in $$props) $$invalidate(10, pressingDown = $$props.pressingDown);
    		if ("buttonPressingMove" in $$props) $$invalidate(11, buttonPressingMove = $$props.buttonPressingMove);
    		if ("showArrows" in $$props) $$invalidate(12, showArrows = $$props.showArrows);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		createEventDispatcher,
    		createObserver,
    		className,
    		wrapperElem,
    		observerTarget,
    		smooth,
    		trackElem,
    		pressingUp,
    		pressingDown,
    		buttonPressingMove,
    		showArrows,
    		dispatch,
    		heightReducer,
    		thumbElem,
    		thumbHeight,
    		thumbTop,
    		noScroll,
    		pos,
    		unsubscribeObserver,
    		calcThumbHeight,
    		thumbInteractionHappening,
    		thumbInteractionEnd,
    		thumbInteractionStart,
    		initTrackBar,
    		buttonScrollDown,
    		buttonScrollUp
    	});

    	$$self.$inject_state = $$props => {
    		if ("className" in $$props) $$invalidate(0, className = $$props.className);
    		if ("wrapperElem" in $$props) $$invalidate(6, wrapperElem = $$props.wrapperElem);
    		if ("observerTarget" in $$props) $$invalidate(8, observerTarget = $$props.observerTarget);
    		if ("smooth" in $$props) $$invalidate(1, smooth = $$props.smooth);
    		if ("trackElem" in $$props) $$invalidate(7, trackElem = $$props.trackElem);
    		if ("pressingUp" in $$props) $$invalidate(9, pressingUp = $$props.pressingUp);
    		if ("pressingDown" in $$props) $$invalidate(10, pressingDown = $$props.pressingDown);
    		if ("buttonPressingMove" in $$props) $$invalidate(11, buttonPressingMove = $$props.buttonPressingMove);
    		if ("showArrows" in $$props) $$invalidate(12, showArrows = $$props.showArrows);
    		if ("thumbElem" in $$props) $$invalidate(2, thumbElem = $$props.thumbElem);
    		if ("thumbHeight" in $$props) $$invalidate(3, thumbHeight = $$props.thumbHeight);
    		if ("thumbTop" in $$props) $$invalidate(4, thumbTop = $$props.thumbTop);
    		if ("noScroll" in $$props) $$invalidate(5, noScroll = $$props.noScroll);
    		if ("pos" in $$props) pos = $$props.pos;
    		if ("unsubscribeObserver" in $$props) unsubscribeObserver = $$props.unsubscribeObserver;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pressingUp*/ 512) {
    			buttonScrollUp(pressingUp);
    		}

    		if ($$self.$$.dirty & /*pressingDown*/ 1024) {
    			buttonScrollDown(pressingDown);
    		}
    	};

    	return [
    		className,
    		smooth,
    		thumbElem,
    		thumbHeight,
    		thumbTop,
    		noScroll,
    		wrapperElem,
    		trackElem,
    		observerTarget,
    		pressingUp,
    		pressingDown,
    		buttonPressingMove,
    		showArrows,
    		div_binding
    	];
    }

    class Thumb extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			className: 0,
    			wrapperElem: 6,
    			observerTarget: 8,
    			smooth: 1,
    			trackElem: 7,
    			pressingUp: 9,
    			pressingDown: 10,
    			buttonPressingMove: 11,
    			showArrows: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Thumb",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*showArrows*/ ctx[12] === undefined && !("showArrows" in props)) {
    			console.warn("<Thumb> was created without expected prop 'showArrows'");
    		}
    	}

    	get className() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapperElem() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapperElem(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get observerTarget() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set observerTarget(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get smooth() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set smooth(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trackElem() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trackElem(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pressingUp() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pressingUp(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pressingDown() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pressingDown(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttonPressingMove() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttonPressingMove(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showArrows() {
    		throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showArrows(value) {
    		throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/happy-svelte-scrollbar/src/ScrollButton.svelte generated by Svelte v3.32.1 */

    const file$h = "node_modules/happy-svelte-scrollbar/src/ScrollButton.svelte";

    function create_fragment$h(ctx) {
    	let div;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", div_class_value = "scroll-button " + /*direction*/ ctx[0] + " svelte-an71hn");
    			add_location(div, file$h, 24, 0, 521);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[4](div);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", click, false, false, false),
    					listen_dev(div, "mousedown", /*startPressing*/ ctx[2], false, false, false),
    					listen_dev(div, "touchstart", /*startPressing*/ ctx[2], { passive: true }, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*direction*/ 1 && div_class_value !== (div_class_value = "scroll-button " + /*direction*/ ctx[0] + " svelte-an71hn")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[4](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function click(evt) {
    	evt.preventDefault();
    	evt.stopPropagation();
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ScrollButton", slots, []);
    	let { direction = "up" } = $$props;
    	let { pressing = false } = $$props;
    	let button;

    	function stopPressing() {
    		$$invalidate(3, pressing = false);
    		document.removeEventListener("mouseup", stopPressing);
    		document.removeEventListener("touchend", stopPressing);
    	}

    	function startPressing() {
    		$$invalidate(3, pressing = true);
    		document.addEventListener("mouseup", stopPressing);
    		document.addEventListener("touchend", stopPressing);
    	}

    	const writable_props = ["direction", "pressing"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ScrollButton> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			button = $$value;
    			$$invalidate(1, button);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("direction" in $$props) $$invalidate(0, direction = $$props.direction);
    		if ("pressing" in $$props) $$invalidate(3, pressing = $$props.pressing);
    	};

    	$$self.$capture_state = () => ({
    		direction,
    		pressing,
    		button,
    		stopPressing,
    		startPressing,
    		click
    	});

    	$$self.$inject_state = $$props => {
    		if ("direction" in $$props) $$invalidate(0, direction = $$props.direction);
    		if ("pressing" in $$props) $$invalidate(3, pressing = $$props.pressing);
    		if ("button" in $$props) $$invalidate(1, button = $$props.button);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [direction, button, startPressing, pressing, div_binding];
    }

    class ScrollButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { direction: 0, pressing: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ScrollButton",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get direction() {
    		throw new Error("<ScrollButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<ScrollButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pressing() {
    		throw new Error("<ScrollButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pressing(value) {
    		throw new Error("<ScrollButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/happy-svelte-scrollbar/src/Track.svelte generated by Svelte v3.32.1 */
    const file$i = "node_modules/happy-svelte-scrollbar/src/Track.svelte";

    // (37:0) {#if wrapperElem}
    function create_if_block$6(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*trackElem*/ ctx[5] && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-8ilrm9"));
    			toggle_class(div, "happy-scroll-track", true);
    			add_location(div, file$i, 37, 2, 895);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			/*div_binding*/ ctx[15](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*clickTrack*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*trackElem*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*trackElem*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*className*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-8ilrm9"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*className*/ 2) {
    				toggle_class(div, "happy-scroll-track", true);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			/*div_binding*/ ctx[15](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(37:0) {#if wrapperElem}",
    		ctx
    	});

    	return block;
    }

    // (39:4) {#if trackElem}
    function create_if_block_1$4(ctx) {
    	let t0;
    	let thumb;
    	let t1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*showArrows*/ ctx[4] && create_if_block_3(ctx);

    	thumb = new Thumb({
    			props: {
    				wrapperElem: /*wrapperElem*/ ctx[0],
    				trackElem: /*trackElem*/ ctx[5],
    				observerTarget: /*observerTarget*/ ctx[2],
    				smooth: /*smooth*/ ctx[7],
    				pressingUp: /*pressingUp*/ ctx[8],
    				pressingDown: /*pressingDown*/ ctx[9],
    				buttonPressingMove: /*buttonPressingMove*/ ctx[3],
    				showArrows: /*showArrows*/ ctx[4]
    			},
    			$$inline: true
    		});

    	thumb.$on("lock-click", /*lock_click_handler*/ ctx[12]);
    	thumb.$on("unlock-click", /*unlock_click_handler*/ ctx[13]);
    	let if_block1 = /*showArrows*/ ctx[4] && create_if_block_2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			create_component(thumb.$$.fragment);
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(thumb, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*showArrows*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*showArrows*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const thumb_changes = {};
    			if (dirty & /*wrapperElem*/ 1) thumb_changes.wrapperElem = /*wrapperElem*/ ctx[0];
    			if (dirty & /*trackElem*/ 32) thumb_changes.trackElem = /*trackElem*/ ctx[5];
    			if (dirty & /*observerTarget*/ 4) thumb_changes.observerTarget = /*observerTarget*/ ctx[2];
    			if (dirty & /*smooth*/ 128) thumb_changes.smooth = /*smooth*/ ctx[7];
    			if (dirty & /*pressingUp*/ 256) thumb_changes.pressingUp = /*pressingUp*/ ctx[8];
    			if (dirty & /*pressingDown*/ 512) thumb_changes.pressingDown = /*pressingDown*/ ctx[9];
    			if (dirty & /*buttonPressingMove*/ 8) thumb_changes.buttonPressingMove = /*buttonPressingMove*/ ctx[3];
    			if (dirty & /*showArrows*/ 16) thumb_changes.showArrows = /*showArrows*/ ctx[4];
    			thumb.$set(thumb_changes);

    			if (/*showArrows*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showArrows*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(thumb.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(thumb.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(thumb, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(39:4) {#if trackElem}",
    		ctx
    	});

    	return block;
    }

    // (40:6) {#if showArrows}
    function create_if_block_3(ctx) {
    	let scrollbutton;
    	let updating_pressing;
    	let current;

    	function scrollbutton_pressing_binding(value) {
    		/*scrollbutton_pressing_binding*/ ctx[11].call(null, value);
    	}

    	let scrollbutton_props = { direction: "up" };

    	if (/*pressingUp*/ ctx[8] !== void 0) {
    		scrollbutton_props.pressing = /*pressingUp*/ ctx[8];
    	}

    	scrollbutton = new ScrollButton({
    			props: scrollbutton_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(scrollbutton, "pressing", scrollbutton_pressing_binding));

    	const block = {
    		c: function create() {
    			create_component(scrollbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(scrollbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const scrollbutton_changes = {};

    			if (!updating_pressing && dirty & /*pressingUp*/ 256) {
    				updating_pressing = true;
    				scrollbutton_changes.pressing = /*pressingUp*/ ctx[8];
    				add_flush_callback(() => updating_pressing = false);
    			}

    			scrollbutton.$set(scrollbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scrollbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scrollbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scrollbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(40:6) {#if showArrows}",
    		ctx
    	});

    	return block;
    }

    // (55:6) {#if showArrows}
    function create_if_block_2(ctx) {
    	let scrollbutton;
    	let updating_pressing;
    	let current;

    	function scrollbutton_pressing_binding_1(value) {
    		/*scrollbutton_pressing_binding_1*/ ctx[14].call(null, value);
    	}

    	let scrollbutton_props = { direction: "down" };

    	if (/*pressingDown*/ ctx[9] !== void 0) {
    		scrollbutton_props.pressing = /*pressingDown*/ ctx[9];
    	}

    	scrollbutton = new ScrollButton({
    			props: scrollbutton_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(scrollbutton, "pressing", scrollbutton_pressing_binding_1));

    	const block = {
    		c: function create() {
    			create_component(scrollbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(scrollbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const scrollbutton_changes = {};

    			if (!updating_pressing && dirty & /*pressingDown*/ 512) {
    				updating_pressing = true;
    				scrollbutton_changes.pressing = /*pressingDown*/ ctx[9];
    				add_flush_callback(() => updating_pressing = false);
    			}

    			scrollbutton.$set(scrollbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scrollbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scrollbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scrollbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(55:6) {#if showArrows}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*wrapperElem*/ ctx[0] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*wrapperElem*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*wrapperElem*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Track", slots, []);
    	let { className = "scrollbar-track" } = $$props;
    	let { wrapperElem = null } = $$props;
    	let { observerTarget = null } = $$props;
    	let { buttonPressingMove = 5 } = $$props;
    	let { showArrows } = $$props;
    	let trackElem;
    	let clickLock = false;
    	let smooth = false;
    	let pressingUp = false;
    	let pressingDown = false;

    	/**
     * Scrolling area when clicking on
     * scrollbar track
     *
     * @param {MouseEvent} event
     */
    	function clickTrack(event) {
    		if (clickLock) return;
    		$$invalidate(7, smooth = true);
    		event.preventDefault();
    		event.stopPropagation();
    		const { offsetY } = event;
    		const percents = offsetY / trackElem.offsetHeight * 100;
    		$$invalidate(0, wrapperElem.scrollTop = wrapperElem.scrollHeight / 100 * percents, wrapperElem);

    		setTimeout(
    			() => {
    				$$invalidate(7, smooth = false);
    			},
    			250
    		);
    	}

    	const writable_props = [
    		"className",
    		"wrapperElem",
    		"observerTarget",
    		"buttonPressingMove",
    		"showArrows"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Track> was created with unknown prop '${key}'`);
    	});

    	function scrollbutton_pressing_binding(value) {
    		pressingUp = value;
    		$$invalidate(8, pressingUp);
    	}

    	const lock_click_handler = () => $$invalidate(6, clickLock = true);
    	const unlock_click_handler = () => $$invalidate(6, clickLock = false);

    	function scrollbutton_pressing_binding_1(value) {
    		pressingDown = value;
    		$$invalidate(9, pressingDown);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			trackElem = $$value;
    			$$invalidate(5, trackElem);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("className" in $$props) $$invalidate(1, className = $$props.className);
    		if ("wrapperElem" in $$props) $$invalidate(0, wrapperElem = $$props.wrapperElem);
    		if ("observerTarget" in $$props) $$invalidate(2, observerTarget = $$props.observerTarget);
    		if ("buttonPressingMove" in $$props) $$invalidate(3, buttonPressingMove = $$props.buttonPressingMove);
    		if ("showArrows" in $$props) $$invalidate(4, showArrows = $$props.showArrows);
    	};

    	$$self.$capture_state = () => ({
    		Thumb,
    		ScrollButton,
    		className,
    		wrapperElem,
    		observerTarget,
    		buttonPressingMove,
    		showArrows,
    		trackElem,
    		clickLock,
    		smooth,
    		pressingUp,
    		pressingDown,
    		clickTrack
    	});

    	$$self.$inject_state = $$props => {
    		if ("className" in $$props) $$invalidate(1, className = $$props.className);
    		if ("wrapperElem" in $$props) $$invalidate(0, wrapperElem = $$props.wrapperElem);
    		if ("observerTarget" in $$props) $$invalidate(2, observerTarget = $$props.observerTarget);
    		if ("buttonPressingMove" in $$props) $$invalidate(3, buttonPressingMove = $$props.buttonPressingMove);
    		if ("showArrows" in $$props) $$invalidate(4, showArrows = $$props.showArrows);
    		if ("trackElem" in $$props) $$invalidate(5, trackElem = $$props.trackElem);
    		if ("clickLock" in $$props) $$invalidate(6, clickLock = $$props.clickLock);
    		if ("smooth" in $$props) $$invalidate(7, smooth = $$props.smooth);
    		if ("pressingUp" in $$props) $$invalidate(8, pressingUp = $$props.pressingUp);
    		if ("pressingDown" in $$props) $$invalidate(9, pressingDown = $$props.pressingDown);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		wrapperElem,
    		className,
    		observerTarget,
    		buttonPressingMove,
    		showArrows,
    		trackElem,
    		clickLock,
    		smooth,
    		pressingUp,
    		pressingDown,
    		clickTrack,
    		scrollbutton_pressing_binding,
    		lock_click_handler,
    		unlock_click_handler,
    		scrollbutton_pressing_binding_1,
    		div_binding
    	];
    }

    class Track extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			className: 1,
    			wrapperElem: 0,
    			observerTarget: 2,
    			buttonPressingMove: 3,
    			showArrows: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Track",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*showArrows*/ ctx[4] === undefined && !("showArrows" in props)) {
    			console.warn("<Track> was created without expected prop 'showArrows'");
    		}
    	}

    	get className() {
    		throw new Error("<Track>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Track>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapperElem() {
    		throw new Error("<Track>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapperElem(value) {
    		throw new Error("<Track>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get observerTarget() {
    		throw new Error("<Track>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set observerTarget(value) {
    		throw new Error("<Track>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttonPressingMove() {
    		throw new Error("<Track>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttonPressingMove(value) {
    		throw new Error("<Track>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showArrows() {
    		throw new Error("<Track>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showArrows(value) {
    		throw new Error("<Track>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/happy-svelte-scrollbar/src/Scrollbar.svelte generated by Svelte v3.32.1 */

    function create_fragment$j(ctx) {
    	let track;
    	let current;

    	track = new Track({
    			props: {
    				wrapperElem: /*scrollArea*/ ctx[1],
    				observerTarget: /*observerTarget*/ ctx[0],
    				buttonPressingMove: /*buttonPressingMove*/ ctx[2],
    				showArrows: /*showArrows*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(track.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(track, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const track_changes = {};
    			if (dirty & /*scrollArea*/ 2) track_changes.wrapperElem = /*scrollArea*/ ctx[1];
    			if (dirty & /*observerTarget*/ 1) track_changes.observerTarget = /*observerTarget*/ ctx[0];
    			if (dirty & /*buttonPressingMove*/ 4) track_changes.buttonPressingMove = /*buttonPressingMove*/ ctx[2];
    			if (dirty & /*showArrows*/ 8) track_changes.showArrows = /*showArrows*/ ctx[3];
    			track.$set(track_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(track.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(track.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(track, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Scrollbar", slots, []);
    	let { observerTarget } = $$props;
    	let { scrollArea } = $$props;
    	let { buttonPressingMove = 5 } = $$props;
    	let { showArrows = false } = $$props;
    	const writable_props = ["observerTarget", "scrollArea", "buttonPressingMove", "showArrows"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Scrollbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("observerTarget" in $$props) $$invalidate(0, observerTarget = $$props.observerTarget);
    		if ("scrollArea" in $$props) $$invalidate(1, scrollArea = $$props.scrollArea);
    		if ("buttonPressingMove" in $$props) $$invalidate(2, buttonPressingMove = $$props.buttonPressingMove);
    		if ("showArrows" in $$props) $$invalidate(3, showArrows = $$props.showArrows);
    	};

    	$$self.$capture_state = () => ({
    		Track,
    		observerTarget,
    		scrollArea,
    		buttonPressingMove,
    		showArrows
    	});

    	$$self.$inject_state = $$props => {
    		if ("observerTarget" in $$props) $$invalidate(0, observerTarget = $$props.observerTarget);
    		if ("scrollArea" in $$props) $$invalidate(1, scrollArea = $$props.scrollArea);
    		if ("buttonPressingMove" in $$props) $$invalidate(2, buttonPressingMove = $$props.buttonPressingMove);
    		if ("showArrows" in $$props) $$invalidate(3, showArrows = $$props.showArrows);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [observerTarget, scrollArea, buttonPressingMove, showArrows];
    }

    class Scrollbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			observerTarget: 0,
    			scrollArea: 1,
    			buttonPressingMove: 2,
    			showArrows: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Scrollbar",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*observerTarget*/ ctx[0] === undefined && !("observerTarget" in props)) {
    			console.warn("<Scrollbar> was created without expected prop 'observerTarget'");
    		}

    		if (/*scrollArea*/ ctx[1] === undefined && !("scrollArea" in props)) {
    			console.warn("<Scrollbar> was created without expected prop 'scrollArea'");
    		}
    	}

    	get observerTarget() {
    		throw new Error("<Scrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set observerTarget(value) {
    		throw new Error("<Scrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollArea() {
    		throw new Error("<Scrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollArea(value) {
    		throw new Error("<Scrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttonPressingMove() {
    		throw new Error("<Scrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttonPressingMove(value) {
    		throw new Error("<Scrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showArrows() {
    		throw new Error("<Scrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showArrows(value) {
    		throw new Error("<Scrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/UserSetupBlock.svelte generated by Svelte v3.32.1 */

    const { console: console_1$1 } = globals;
    const file$j = "src/components/UserSetupBlock.svelte";

    // (257:24) {#if dataFields }
    function create_if_block_1$5(ctx) {
    	let div0;
    	let select0;
    	let t0;
    	let div1;
    	let select1;
    	let t1;
    	let div2;
    	let select2;
    	let current;

    	select0 = new Select({
    			props: {
    				label: translations[/*LANG*/ ctx[3]].setup.label_1,
    				dataInputRole: "name",
    				optionObject: /*dataFields*/ ctx[4],
    				name: "location"
    			},
    			$$inline: true
    		});

    	select1 = new Select({
    			props: {
    				label: translations[/*LANG*/ ctx[3]].setup.label_2,
    				dataInputRole: "name",
    				optionObject: /*dataFields*/ ctx[4],
    				name: "industry"
    			},
    			$$inline: true
    		});

    	select2 = new Select({
    			props: {
    				label: translations[/*LANG*/ ctx[3]].setup.label_3,
    				dataInputRole: "name",
    				optionObject: /*dataFields*/ ctx[4],
    				name: "name"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(select0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(select1.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(select2.$$.fragment);
    			attr_dev(div0, "class", "input-wrap svelte-1nmxmic");
    			add_location(div0, file$j, 257, 28, 8838);
    			attr_dev(div1, "class", "input-wrap svelte-1nmxmic");
    			add_location(div1, file$j, 263, 28, 9195);
    			attr_dev(div2, "class", "input-wrap svelte-1nmxmic");
    			add_location(div2, file$j, 269, 28, 9552);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(select0, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(select1, div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(select2, div2, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select0.$$.fragment, local);
    			transition_in(select1.$$.fragment, local);
    			transition_in(select2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select0.$$.fragment, local);
    			transition_out(select1.$$.fragment, local);
    			transition_out(select2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(select0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(select1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(select2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(257:24) {#if dataFields }",
    		ctx
    	});

    	return block;
    }

    // (282:24) {#if dataFields }
    function create_if_block$7(ctx) {
    	let div0;
    	let select0;
    	let t0;
    	let div1;
    	let select1;
    	let t1;
    	let div2;
    	let select2;
    	let current;

    	select0 = new Select({
    			props: {
    				label: translations[/*LANG*/ ctx[3]].setup.label_4,
    				dataInputRole: "name",
    				optionObject: /*dataFields*/ ctx[4],
    				name: "organization"
    			},
    			$$inline: true
    		});

    	select1 = new Select({
    			props: {
    				label: translations[/*LANG*/ ctx[3]].setup.label_5,
    				dataInputRole: "name",
    				optionObject: /*dataFields*/ ctx[4],
    				name: "title"
    			},
    			$$inline: true
    		});

    	select2 = new Select({
    			props: {
    				label: translations[/*LANG*/ ctx[3]].setup.label_6,
    				dataInputRole: "email",
    				optionObject: /*dataFields*/ ctx[4],
    				name: "email"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(select0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(select1.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(select2.$$.fragment);
    			attr_dev(div0, "class", "input-wrap svelte-1nmxmic");
    			add_location(div0, file$j, 282, 28, 10126);
    			attr_dev(div1, "class", "input-wrap svelte-1nmxmic");
    			add_location(div1, file$j, 288, 28, 10487);
    			attr_dev(div2, "class", "input-wrap svelte-1nmxmic");
    			add_location(div2, file$j, 294, 28, 10841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(select0, div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(select1, div1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(select2, div2, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select0.$$.fragment, local);
    			transition_in(select1.$$.fragment, local);
    			transition_in(select2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select0.$$.fragment, local);
    			transition_out(select1.$$.fragment, local);
    			transition_out(select2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(select0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			destroy_component(select1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(select2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(282:24) {#if dataFields }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div8;
    	let div7;
    	let div0;
    	let heading;
    	let t0;
    	let hr0;
    	let t1;
    	let form;
    	let div4;
    	let div3;
    	let div1;
    	let t2;
    	let hr1;
    	let t3;
    	let div2;
    	let t4;
    	let hr2;
    	let t5;
    	let div5;
    	let btnstandart;
    	let t6;
    	let scrollbar;
    	let t7;
    	let div6;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[3]]?.setup?.heading
    			},
    			$$inline: true
    		});

    	let if_block0 = /*dataFields*/ ctx[4] && create_if_block_1$5(ctx);
    	let if_block1 = /*dataFields*/ ctx[4] && create_if_block$7(ctx);

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[3]].setup.btn,
    				color: "purple",
    				btnType: /*submitBtnType*/ ctx[0]
    			},
    			$$inline: true
    		});

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[1],
    				scrollArea: /*iAmScrollArea*/ ctx[2],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "user-import-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[5]);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div7 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			hr0 = element("hr");
    			t1 = space();
    			form = element("form");
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t2 = space();
    			hr1 = element("hr");
    			t3 = space();
    			div2 = element("div");
    			if (if_block1) if_block1.c();
    			t4 = space();
    			hr2 = element("hr");
    			t5 = space();
    			div5 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t6 = space();
    			create_component(scrollbar.$$.fragment);
    			t7 = space();
    			div6 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$j, 244, 8, 8282);
    			attr_dev(hr0, "class", "hr-top");
    			add_location(hr0, file$j, 247, 8, 8394);
    			attr_dev(div1, "class", "d-flex justify-content-center flex-wrap");
    			add_location(div1, file$j, 255, 20, 8714);
    			attr_dev(hr1, "class", "hr-top mt-15");
    			add_location(hr1, file$j, 278, 20, 9955);
    			attr_dev(div2, "class", "d-flex justify-content-center flex-wrap");
    			add_location(div2, file$j, 280, 20, 10002);
    			attr_dev(div3, "class", "dynamic-content");
    			add_location(div3, file$j, 254, 16, 8634);
    			attr_dev(div4, "class", "my-scroller svelte-1nmxmic");
    			add_location(div4, file$j, 253, 12, 8564);
    			attr_dev(hr2, "class", "hr-top mt-15");
    			add_location(hr2, file$j, 304, 12, 11279);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$j, 305, 12, 11317);
    			attr_dev(form, "data-role", "user-setup");
    			attr_dev(form, "data-step", "user-preview-step");
    			add_location(form, file$j, 249, 8, 8423);
    			attr_dev(div6, "class", "mt-30");
    			add_location(div6, file$j, 321, 8, 11793);
    			attr_dev(div7, "class", "center-block__inner center-block__inner-mod svelte-1nmxmic");
    			add_location(div7, file$j, 243, 4, 8216);
    			attr_dev(div8, "class", "center-block__content center-block__content-mod svelte-1nmxmic");
    			add_location(div8, file$j, 242, 0, 8150);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, div0);
    			mount_component(heading, div0, null);
    			append_dev(div7, t0);
    			append_dev(div7, hr0);
    			append_dev(div7, t1);
    			append_dev(div7, form);
    			append_dev(form, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div3, t2);
    			append_dev(div3, hr1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			if (if_block1) if_block1.m(div2, null);
    			/*div3_binding*/ ctx[7](div3);
    			/*div4_binding*/ ctx[8](div4);
    			append_dev(form, t4);
    			append_dev(form, hr2);
    			append_dev(form, t5);
    			append_dev(form, div5);
    			mount_component(btnstandart, div5, null);
    			append_dev(form, t6);
    			mount_component(scrollbar, form, null);
    			append_dev(div7, t7);
    			append_dev(div7, div6);
    			mount_component(btnback, div6, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[6]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*dataFields*/ ctx[4]) if_block0.p(ctx, dirty);
    			if (/*dataFields*/ ctx[4]) if_block1.p(ctx, dirty);
    			const btnstandart_changes = {};
    			if (dirty & /*submitBtnType*/ 1) btnstandart_changes.btnType = /*submitBtnType*/ ctx[0];
    			btnstandart.$set(btnstandart_changes);
    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 2) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[1];
    			if (dirty & /*iAmScrollArea*/ 4) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[2];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(heading);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			/*div3_binding*/ ctx[7](null);
    			/*div4_binding*/ ctx[8](null);
    			destroy_component(btnstandart);
    			destroy_component(scrollbar);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $responseFieldsData;
    	let $previewTagsData;
    	validate_store(responseFieldsData, "responseFieldsData");
    	component_subscribe($$self, responseFieldsData, $$value => $$invalidate(9, $responseFieldsData = $$value));
    	validate_store(previewTagsData, "previewTagsData");
    	component_subscribe($$self, previewTagsData, $$value => $$invalidate(10, $previewTagsData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserSetupBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let submitBtnType = "submit";
    	console.log("$responseFieldsData", $responseFieldsData);
    	let dataFields = JSON.parse($responseFieldsData);
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		let nextStep = event.target.dataset.step;
    		if (!checkStepFields("user-setup")) return false;

    		// Update localStorage with users data
    		saveEnteredUserData("user-setup");

    		(async () => {
    			new Cookies();

    			/*if ( IS_DEV !== 'true') {
    	// Prevent access for user if he doesn't authorized
    	if ( !LARAVEL_SESSION ) {
    		nextStep = 'login-step';
    		return;
    	}
    }*/
    			const PREVIEW_TAGS_ENDPOINT = ({
    				"env": {
    					"isProd": false,
    					"CURRENT_LANG": "en",
    					"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    					"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    					"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    					"GET_POST_ENDPOINT": "/community/posts/12",
    					"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    					"SEARCH_POST_ENDPOINT": "/community/search/16",
    					"DELETE_POST_ENDPOINT": "/post/delete/15",
    					"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    					"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    					"GET_USER_PROFILE_ENDPOINT": "/profile",
    					"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    					"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    					"LIST_TAGS_ENDPOINT": "/community/tags/12",
    					"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    					"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    					"GET_COMMUNITIES_ENDPOINT": "/community",
    					"GET_DRIVERS_ENDPOINT": "/export/drivers",
    					"GET_FIELDS_ENDPOINT": "/export/fields",
    					"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    					"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    					"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    					"EXPORT_RULES_ENDPOINT": "/export"
    				}
    			}).env.PREVIEW_TAGS_ENDPOINT;

    			$$invalidate(0, submitBtnType = "loader");
    			let res = await makeRequestToBackend($previewTagsData, PREVIEW_TAGS_ENDPOINT, "POST");
    			$$invalidate(0, submitBtnType = "submit");

    			// Access isn't authorized
    			if (res.status === 401) {
    				nextStep = "login-step";
    				return;
    			}

    			previewTagsResponseData.update(n => res);
    			dispatch("goToStep", { step: nextStep });
    		})();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<UserSetupBlock> was created with unknown prop '${key}'`);
    	});

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(1, iChangeMyHeight);
    		});
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(2, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		makeRequestToBackend,
    		saveEnteredUserData,
    		createEventDispatcher,
    		translations,
    		BtnBack,
    		BtnStandart,
    		Heading,
    		Select,
    		Scrollbar,
    		responseFieldsData,
    		previewTagsData,
    		previewTagsResponseData,
    		exportFieldsData,
    		Cookies,
    		dispatch,
    		LANG,
    		submitBtnType,
    		dataFields,
    		iChangeMyHeight,
    		iAmScrollArea,
    		goToBack,
    		goToNextStep,
    		$responseFieldsData,
    		$previewTagsData
    	});

    	$$self.$inject_state = $$props => {
    		if ("submitBtnType" in $$props) $$invalidate(0, submitBtnType = $$props.submitBtnType);
    		if ("dataFields" in $$props) $$invalidate(4, dataFields = $$props.dataFields);
    		if ("iChangeMyHeight" in $$props) $$invalidate(1, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(2, iAmScrollArea = $$props.iAmScrollArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		submitBtnType,
    		iChangeMyHeight,
    		iAmScrollArea,
    		LANG,
    		dataFields,
    		goToBack,
    		goToNextStep,
    		div3_binding,
    		div4_binding
    	];
    }

    class UserSetupBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserSetupBlock",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src/components/inputs/SelectMultiple.svelte generated by Svelte v3.32.1 */
    const file$k = "src/components/inputs/SelectMultiple.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (353:4) {#if label}
    function create_if_block_1$6(ctx) {
    	let label_1;

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			attr_dev(label_1, "for", /*id*/ ctx[1]);
    			attr_dev(label_1, "class", "form-control__label svelte-tcklhe");
    			add_location(label_1, file$k, 353, 8, 10767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			label_1.innerHTML = /*label*/ ctx[4];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 16) label_1.innerHTML = /*label*/ ctx[4];
    			if (dirty & /*id*/ 2) {
    				attr_dev(label_1, "for", /*id*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(353:4) {#if label}",
    		ctx
    	});

    	return block;
    }

    // (367:8) {#if optionObject}
    function create_if_block$8(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let each_value = /*optionObject*/ ctx[5];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*name*/ ctx[9];
    	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$2(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*optionObject*/ 32) {
    				each_value = /*optionObject*/ ctx[5];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$2, each_1_anchor, get_each_context$2);
    			}
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(367:8) {#if optionObject}",
    		ctx
    	});

    	return block;
    }

    // (368:12) {#each optionObject as name (name)}
    function create_each_block$2(key_1, ctx) {
    	let option;
    	let t_value = /*name*/ ctx[9] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*name*/ ctx[9];
    			option.value = option.__value;
    			add_location(option, file$k, 368, 16, 11222);
    			this.first = option;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*optionObject*/ 32 && t_value !== (t_value = /*name*/ ctx[9] + "")) set_data_dev(t, t_value);

    			if (dirty & /*optionObject*/ 32 && option_value_value !== (option_value_value = /*name*/ ctx[9])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(368:12) {#each optionObject as name (name)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let t;
    	let select;
    	let select_class_value;
    	let div_class_value;
    	let mounted;
    	let dispose;
    	let if_block0 = /*label*/ ctx[4] && create_if_block_1$6(ctx);
    	let if_block1 = /*optionObject*/ ctx[5] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			select = element("select");
    			if (if_block1) if_block1.c();
    			attr_dev(select, "name", /*name*/ ctx[9]);
    			attr_dev(select, "id", /*id*/ ctx[1]);
    			attr_dev(select, "class", select_class_value = "" + (null_to_empty(/*className*/ ctx[2] + " " + /*valueReadOnly*/ ctx[7]) + " svelte-tcklhe"));
    			attr_dev(select, "data-input-role", /*dataInputRole*/ ctx[6]);
    			select.multiple = true;
    			attr_dev(select, "data-group-index", /*groupIndex*/ ctx[8]);
    			if (/*selectedValue*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[10].call(select));
    			add_location(select, file$k, 356, 4, 10854);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`form-control ${/*wrapperClass*/ ctx[3]}`) + " svelte-tcklhe"));
    			add_location(div, file$k, 351, 0, 10698);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			append_dev(div, select);
    			if (if_block1) if_block1.m(select, null);
    			select_options(select, /*selectedValue*/ ctx[0]);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[10]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*label*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$6(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*optionObject*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					if_block1.m(select, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*name*/ 512) {
    				attr_dev(select, "name", /*name*/ ctx[9]);
    			}

    			if (dirty & /*id*/ 2) {
    				attr_dev(select, "id", /*id*/ ctx[1]);
    			}

    			if (dirty & /*className, valueReadOnly*/ 132 && select_class_value !== (select_class_value = "" + (null_to_empty(/*className*/ ctx[2] + " " + /*valueReadOnly*/ ctx[7]) + " svelte-tcklhe"))) {
    				attr_dev(select, "class", select_class_value);
    			}

    			if (dirty & /*dataInputRole*/ 64) {
    				attr_dev(select, "data-input-role", /*dataInputRole*/ ctx[6]);
    			}

    			if (dirty & /*groupIndex*/ 256) {
    				attr_dev(select, "data-group-index", /*groupIndex*/ ctx[8]);
    			}

    			if (dirty & /*selectedValue, optionObject*/ 33) {
    				select_options(select, /*selectedValue*/ ctx[0]);
    			}

    			if (dirty & /*wrapperClass*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(`form-control ${/*wrapperClass*/ ctx[3]}`) + " svelte-tcklhe"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SelectMultiple", slots, []);
    	const dispatch = createEventDispatcher();
    	let { id = "" } = $$props;
    	let { name = "" } = $$props;
    	let { className = "select" } = $$props;
    	let { wrapperClass = "" } = $$props;
    	let { label = "" } = $$props;
    	let { optionObject = [] } = $$props;
    	let { dataInputRole = "" } = $$props;
    	let { valueReadOnly = "" } = $$props;
    	let { groupIndex = "" } = $$props;
    	let { selectedValue = "" } = $$props;

    	const writable_props = [
    		"id",
    		"name",
    		"className",
    		"wrapperClass",
    		"label",
    		"optionObject",
    		"dataInputRole",
    		"valueReadOnly",
    		"groupIndex",
    		"selectedValue"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SelectMultiple> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		selectedValue = select_multiple_value(this);
    		$$invalidate(0, selectedValue);
    		$$invalidate(5, optionObject);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("name" in $$props) $$invalidate(9, name = $$props.name);
    		if ("className" in $$props) $$invalidate(2, className = $$props.className);
    		if ("wrapperClass" in $$props) $$invalidate(3, wrapperClass = $$props.wrapperClass);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("optionObject" in $$props) $$invalidate(5, optionObject = $$props.optionObject);
    		if ("dataInputRole" in $$props) $$invalidate(6, dataInputRole = $$props.dataInputRole);
    		if ("valueReadOnly" in $$props) $$invalidate(7, valueReadOnly = $$props.valueReadOnly);
    		if ("groupIndex" in $$props) $$invalidate(8, groupIndex = $$props.groupIndex);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		id,
    		name,
    		className,
    		wrapperClass,
    		label,
    		optionObject,
    		dataInputRole,
    		valueReadOnly,
    		groupIndex,
    		selectedValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("name" in $$props) $$invalidate(9, name = $$props.name);
    		if ("className" in $$props) $$invalidate(2, className = $$props.className);
    		if ("wrapperClass" in $$props) $$invalidate(3, wrapperClass = $$props.wrapperClass);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("optionObject" in $$props) $$invalidate(5, optionObject = $$props.optionObject);
    		if ("dataInputRole" in $$props) $$invalidate(6, dataInputRole = $$props.dataInputRole);
    		if ("valueReadOnly" in $$props) $$invalidate(7, valueReadOnly = $$props.valueReadOnly);
    		if ("groupIndex" in $$props) $$invalidate(8, groupIndex = $$props.groupIndex);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedValue,
    		id,
    		className,
    		wrapperClass,
    		label,
    		optionObject,
    		dataInputRole,
    		valueReadOnly,
    		groupIndex,
    		name,
    		select_change_handler
    	];
    }

    class SelectMultiple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			id: 1,
    			name: 9,
    			className: 2,
    			wrapperClass: 3,
    			label: 4,
    			optionObject: 5,
    			dataInputRole: 6,
    			valueReadOnly: 7,
    			groupIndex: 8,
    			selectedValue: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectMultiple",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get id() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapperClass() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapperClass(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionObject() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionObject(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataInputRole() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataInputRole(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueReadOnly() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueReadOnly(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupIndex() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupIndex(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<SelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<SelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/UserPreviewBlock.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1 } = globals;
    const file$l = "src/components/UserPreviewBlock.svelte";

    function create_fragment$m(ctx) {
    	let div14;
    	let div13;
    	let div0;
    	let heading;
    	let t0;
    	let hr0;
    	let t1;
    	let form;
    	let div10;
    	let div9;
    	let div4;
    	let div1;
    	let selectmultiple0;
    	let t2;
    	let div2;
    	let selectmultiple1;
    	let t3;
    	let div3;
    	let selectmultiple2;
    	let t4;
    	let div8;
    	let div5;
    	let selectmultiple3;
    	let t5;
    	let div6;
    	let selectmultiple4;
    	let t6;
    	let div7;
    	let selectmultiple5;
    	let t7;
    	let hr1;
    	let t8;
    	let div11;
    	let btnstandart;
    	let t9;
    	let scrollbar;
    	let t10;
    	let div12;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[4]]?.preview?.heading
    			},
    			$$inline: true
    		});

    	selectmultiple0 = new SelectMultiple({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].preview.label_1,
    				dataInputRole: "name",
    				optionObject: /*previewFormattedData*/ ctx[3]["Location"],
    				name: "location[]",
    				className: "select prevent-selecting select-multiple js-location-select"
    			},
    			$$inline: true
    		});

    	selectmultiple1 = new SelectMultiple({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].preview.label_2,
    				dataInputRole: "name",
    				optionObject: /*previewFormattedData*/ ctx[3]["Industry"],
    				name: "industry[]",
    				className: "select prevent-selecting select-multiple js-industry-select"
    			},
    			$$inline: true
    		});

    	selectmultiple2 = new SelectMultiple({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].preview.label_3,
    				dataInputRole: "name",
    				optionObject: /*previewFormattedData*/ ctx[3]["Name"],
    				name: "name[]",
    				className: "select prevent-selecting select-multiple js-name-select"
    			},
    			$$inline: true
    		});

    	selectmultiple3 = new SelectMultiple({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].preview.label_4,
    				dataInputRole: "name",
    				optionObject: /*previewFormattedData*/ ctx[3]["Organization"],
    				name: "organization[]",
    				className: "select prevent-selecting select-multiple js-organization-select"
    			},
    			$$inline: true
    		});

    	selectmultiple4 = new SelectMultiple({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].preview.label_5,
    				dataInputRole: "name",
    				optionObject: /*previewFormattedData*/ ctx[3]["Title"],
    				name: "title[]",
    				className: "select prevent-selecting select-multiple js-title-select"
    			},
    			$$inline: true
    		});

    	selectmultiple5 = new SelectMultiple({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].preview.label_6,
    				dataInputRole: "email",
    				optionObject: /*previewFormattedData*/ ctx[3]["Email"],
    				name: "email[]",
    				className: "select prevent-selecting select-multiple js-email-select"
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[4]].preview.btn,
    				color: "purple",
    				btnType: /*submitBtnType*/ ctx[0]
    			},
    			$$inline: true
    		});

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[1],
    				scrollArea: /*iAmScrollArea*/ ctx[2],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "user-setup-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[5]);

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div13 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			hr0 = element("hr");
    			t1 = space();
    			form = element("form");
    			div10 = element("div");
    			div9 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			create_component(selectmultiple0.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(selectmultiple1.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(selectmultiple2.$$.fragment);
    			t4 = space();
    			div8 = element("div");
    			div5 = element("div");
    			create_component(selectmultiple3.$$.fragment);
    			t5 = space();
    			div6 = element("div");
    			create_component(selectmultiple4.$$.fragment);
    			t6 = space();
    			div7 = element("div");
    			create_component(selectmultiple5.$$.fragment);
    			t7 = space();
    			hr1 = element("hr");
    			t8 = space();
    			div11 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t9 = space();
    			create_component(scrollbar.$$.fragment);
    			t10 = space();
    			div12 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$l, 255, 8, 8596);
    			attr_dev(hr0, "class", "hr-top");
    			add_location(hr0, file$l, 258, 8, 8710);
    			attr_dev(div1, "class", "input-wrap svelte-8w2odt");
    			add_location(div1, file$l, 267, 24, 9131);
    			attr_dev(div2, "class", "input-wrap svelte-8w2odt");
    			add_location(div2, file$l, 274, 24, 9605);
    			attr_dev(div3, "class", "input-wrap svelte-8w2odt");
    			add_location(div3, file$l, 281, 24, 10079);
    			attr_dev(div4, "class", "d-flex justify-content-center flex-wrap");
    			add_location(div4, file$l, 266, 20, 9053);
    			attr_dev(div5, "class", "input-wrap svelte-8w2odt");
    			add_location(div5, file$l, 290, 24, 10642);
    			attr_dev(div6, "class", "input-wrap svelte-8w2odt");
    			add_location(div6, file$l, 297, 24, 11128);
    			attr_dev(div7, "class", "input-wrap svelte-8w2odt");
    			add_location(div7, file$l, 304, 24, 11593);
    			attr_dev(div8, "class", "d-flex justify-content-center flex-wrap");
    			add_location(div8, file$l, 289, 20, 10564);
    			attr_dev(div9, "class", "dynamic-content");
    			add_location(div9, file$l, 264, 16, 8972);
    			attr_dev(div10, "class", "my-scroller svelte-8w2odt");
    			add_location(div10, file$l, 263, 12, 8902);
    			attr_dev(hr1, "class", "hr-top");
    			add_location(hr1, file$l, 316, 12, 12118);
    			attr_dev(div11, "class", "mt-30");
    			add_location(div11, file$l, 317, 12, 12150);
    			attr_dev(form, "data-role", "user-preview-step");
    			attr_dev(form, "data-step", "willYouReadThisBlock-step");
    			add_location(form, file$l, 259, 8, 8738);
    			attr_dev(div12, "class", "mt-30");
    			add_location(div12, file$l, 332, 8, 12603);
    			attr_dev(div13, "class", "center-block__inner center-block__inner-mod svelte-8w2odt");
    			add_location(div13, file$l, 254, 4, 8530);
    			attr_dev(div14, "class", "center-block__content center-block__content-mod svelte-8w2odt");
    			add_location(div14, file$l, 253, 0, 8464);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div13);
    			append_dev(div13, div0);
    			mount_component(heading, div0, null);
    			append_dev(div13, t0);
    			append_dev(div13, hr0);
    			append_dev(div13, t1);
    			append_dev(div13, form);
    			append_dev(form, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div4);
    			append_dev(div4, div1);
    			mount_component(selectmultiple0, div1, null);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			mount_component(selectmultiple1, div2, null);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			mount_component(selectmultiple2, div3, null);
    			append_dev(div9, t4);
    			append_dev(div9, div8);
    			append_dev(div8, div5);
    			mount_component(selectmultiple3, div5, null);
    			append_dev(div8, t5);
    			append_dev(div8, div6);
    			mount_component(selectmultiple4, div6, null);
    			append_dev(div8, t6);
    			append_dev(div8, div7);
    			mount_component(selectmultiple5, div7, null);
    			/*div9_binding*/ ctx[7](div9);
    			/*div10_binding*/ ctx[8](div10);
    			append_dev(form, t7);
    			append_dev(form, hr1);
    			append_dev(form, t8);
    			append_dev(form, div11);
    			mount_component(btnstandart, div11, null);
    			append_dev(div13, t9);
    			mount_component(scrollbar, div13, null);
    			append_dev(div13, t10);
    			append_dev(div13, div12);
    			mount_component(btnback, div12, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[6]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const selectmultiple0_changes = {};
    			if (dirty & /*previewFormattedData*/ 8) selectmultiple0_changes.optionObject = /*previewFormattedData*/ ctx[3]["Location"];
    			selectmultiple0.$set(selectmultiple0_changes);
    			const selectmultiple1_changes = {};
    			if (dirty & /*previewFormattedData*/ 8) selectmultiple1_changes.optionObject = /*previewFormattedData*/ ctx[3]["Industry"];
    			selectmultiple1.$set(selectmultiple1_changes);
    			const selectmultiple2_changes = {};
    			if (dirty & /*previewFormattedData*/ 8) selectmultiple2_changes.optionObject = /*previewFormattedData*/ ctx[3]["Name"];
    			selectmultiple2.$set(selectmultiple2_changes);
    			const selectmultiple3_changes = {};
    			if (dirty & /*previewFormattedData*/ 8) selectmultiple3_changes.optionObject = /*previewFormattedData*/ ctx[3]["Organization"];
    			selectmultiple3.$set(selectmultiple3_changes);
    			const selectmultiple4_changes = {};
    			if (dirty & /*previewFormattedData*/ 8) selectmultiple4_changes.optionObject = /*previewFormattedData*/ ctx[3]["Title"];
    			selectmultiple4.$set(selectmultiple4_changes);
    			const selectmultiple5_changes = {};
    			if (dirty & /*previewFormattedData*/ 8) selectmultiple5_changes.optionObject = /*previewFormattedData*/ ctx[3]["Email"];
    			selectmultiple5.$set(selectmultiple5_changes);
    			const btnstandart_changes = {};
    			if (dirty & /*submitBtnType*/ 1) btnstandart_changes.btnType = /*submitBtnType*/ ctx[0];
    			btnstandart.$set(btnstandart_changes);
    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 2) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[1];
    			if (dirty & /*iAmScrollArea*/ 4) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[2];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(selectmultiple0.$$.fragment, local);
    			transition_in(selectmultiple1.$$.fragment, local);
    			transition_in(selectmultiple2.$$.fragment, local);
    			transition_in(selectmultiple3.$$.fragment, local);
    			transition_in(selectmultiple4.$$.fragment, local);
    			transition_in(selectmultiple5.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(selectmultiple0.$$.fragment, local);
    			transition_out(selectmultiple1.$$.fragment, local);
    			transition_out(selectmultiple2.$$.fragment, local);
    			transition_out(selectmultiple3.$$.fragment, local);
    			transition_out(selectmultiple4.$$.fragment, local);
    			transition_out(selectmultiple5.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    			destroy_component(heading);
    			destroy_component(selectmultiple0);
    			destroy_component(selectmultiple1);
    			destroy_component(selectmultiple2);
    			destroy_component(selectmultiple3);
    			destroy_component(selectmultiple4);
    			destroy_component(selectmultiple5);
    			/*div9_binding*/ ctx[7](null);
    			/*div10_binding*/ ctx[8](null);
    			destroy_component(btnstandart);
    			destroy_component(scrollbar);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $previewTagsData;
    	let $previewTagsResponseData;
    	validate_store(previewTagsData, "previewTagsData");
    	component_subscribe($$self, previewTagsData, $$value => $$invalidate(9, $previewTagsData = $$value));
    	validate_store(previewTagsResponseData, "previewTagsResponseData");
    	component_subscribe($$self, previewTagsResponseData, $$value => $$invalidate(10, $previewTagsResponseData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserPreviewBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let submitBtnType = "submit";
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		let nextStep = event.target.dataset.step;

    		(async () => {
    			new Cookies();

    			/*if ( IS_DEV !== 'true') {
    	// Prevent access for user if he doesn't authorized
    	if ( !LARAVEL_SESSION ) {
    		nextStep = 'login-step';
    		return;
    	}
    }*/
    			const LOAD_PREVIEW_PARAMETERS_ENDPOINT = ({
    				"env": {
    					"isProd": false,
    					"CURRENT_LANG": "en",
    					"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    					"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    					"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    					"GET_POST_ENDPOINT": "/community/posts/12",
    					"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    					"SEARCH_POST_ENDPOINT": "/community/search/16",
    					"DELETE_POST_ENDPOINT": "/post/delete/15",
    					"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    					"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    					"GET_USER_PROFILE_ENDPOINT": "/profile",
    					"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    					"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    					"LIST_TAGS_ENDPOINT": "/community/tags/12",
    					"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    					"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    					"GET_COMMUNITIES_ENDPOINT": "/community",
    					"GET_DRIVERS_ENDPOINT": "/export/drivers",
    					"GET_FIELDS_ENDPOINT": "/export/fields",
    					"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    					"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    					"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    					"EXPORT_RULES_ENDPOINT": "/export"
    				}
    			}).env.LOAD_PREVIEW_PARAMETERS_ENDPOINT;

    			$$invalidate(0, submitBtnType = "loader");
    			let res = await makeRequestToBackend($previewTagsData, LOAD_PREVIEW_PARAMETERS_ENDPOINT, "POST");
    			$$invalidate(0, submitBtnType = "submit");

    			// Access isn't authorized
    			if (res.status === 401) {
    				nextStep = "login-step";
    				return;
    			}

    			dispatch("goToStep", { step: nextStep });
    		})();
    	};

    	//let previewData = JSON.parse($previewTagsResponseData);
    	let previewData = JSON.parse($previewTagsResponseData);

    	let previewFormattedData = {};

    	previewData && previewData.forEach((row, index) => {
    		let keys = Object.keys(row);

    		keys.forEach(key => {
    			if (typeof previewFormattedData[key] === "undefined") {
    				$$invalidate(3, previewFormattedData[key] = [row[key]], previewFormattedData);
    				return;
    			}

    			$$invalidate(3, previewFormattedData[key] = [...previewFormattedData[key], row[key]], previewFormattedData);
    		});
    	});

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserPreviewBlock> was created with unknown prop '${key}'`);
    	});

    	function div9_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(1, iChangeMyHeight);
    		});
    	}

    	function div10_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(2, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		makeRequestToBackend,
    		createEventDispatcher,
    		translations,
    		BtnBack,
    		BtnStandart,
    		Heading,
    		SelectMultiple,
    		Scrollbar,
    		previewTagsData,
    		previewTagsResponseData,
    		Cookies,
    		dispatch,
    		LANG,
    		submitBtnType,
    		iChangeMyHeight,
    		iAmScrollArea,
    		goToBack,
    		goToNextStep,
    		previewData,
    		previewFormattedData,
    		$previewTagsData,
    		$previewTagsResponseData
    	});

    	$$self.$inject_state = $$props => {
    		if ("submitBtnType" in $$props) $$invalidate(0, submitBtnType = $$props.submitBtnType);
    		if ("iChangeMyHeight" in $$props) $$invalidate(1, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(2, iAmScrollArea = $$props.iAmScrollArea);
    		if ("previewData" in $$props) previewData = $$props.previewData;
    		if ("previewFormattedData" in $$props) $$invalidate(3, previewFormattedData = $$props.previewFormattedData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		submitBtnType,
    		iChangeMyHeight,
    		iAmScrollArea,
    		previewFormattedData,
    		LANG,
    		goToBack,
    		goToNextStep,
    		div9_binding,
    		div10_binding
    	];
    }

    class UserPreviewBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserPreviewBlock",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* src/components/ImportConfirmation.svelte generated by Svelte v3.32.1 */

    const { console: console_1$2 } = globals;
    const file$m = "src/components/ImportConfirmation.svelte";

    function create_fragment$n(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let heading;
    	let t0;
    	let hr0;
    	let t1;
    	let form;
    	let div3;
    	let div1;
    	let input0;
    	let t2;
    	let div2;
    	let input1;
    	let t3;
    	let hr1;
    	let t4;
    	let div4;
    	let btnstandart;
    	let t5;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[4]]?.importConfirmation?.heading
    			},
    			$$inline: true
    		});

    	input0 = new Input({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].importConfirmation.label_1,
    				dataInputRole: "subject",
    				value: /*$exportFieldsData*/ ctx[3].base,
    				name: "user_import_base",
    				className: "form-control__input-text js-user-community-base",
    				errorText: /*messageError*/ ctx[1],
    				placeholder: translations[/*LANG*/ ctx[4]].importConfirmation.placeholder_1
    			},
    			$$inline: true
    		});

    	input0.$on("input", /*changeInputHandler*/ ctx[6]);

    	input1 = new Input({
    			props: {
    				label: translations[/*LANG*/ ctx[4]].importConfirmation.label_2,
    				dataInputRole: "subject",
    				value: /*$exportFieldsData*/ ctx[3].table,
    				name: "user_import_table",
    				className: "form-control__input-text js-user-community-table",
    				errorText: /*messageError*/ ctx[1],
    				placeholder: translations[/*LANG*/ ctx[4]].importConfirmation.placeholder_2
    			},
    			$$inline: true
    		});

    	input1.$on("input", /*changeInputHandler*/ ctx[6]);

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[4]].importConfirmation.btn,
    				color: "purple",
    				btnType: /*submitBtnType*/ ctx[0],
    				disabled: /*isNextBtnDisabled*/ ctx[2]
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "user-setApiKey-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[5]);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			hr0 = element("hr");
    			t1 = space();
    			form = element("form");
    			div3 = element("div");
    			div1 = element("div");
    			create_component(input0.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(input1.$$.fragment);
    			t3 = space();
    			hr1 = element("hr");
    			t4 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t5 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$m, 267, 8, 9205);
    			attr_dev(hr0, "class", "hr-top");
    			add_location(hr0, file$m, 270, 8, 9330);
    			attr_dev(div1, "class", "input-wrap svelte-7yha38");
    			add_location(div1, file$m, 277, 16, 9572);
    			attr_dev(div2, "class", "input-wrap svelte-7yha38");
    			add_location(div2, file$m, 287, 16, 10172);
    			attr_dev(div3, "class", "d-flex justify-content-center");
    			add_location(div3, file$m, 276, 12, 9512);
    			attr_dev(hr1, "class", "hr-top mt-15");
    			add_location(hr1, file$m, 298, 12, 10790);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$m, 299, 12, 10828);
    			attr_dev(form, "data-role", "user-import-step");
    			attr_dev(form, "data-step", "user-setup-step");
    			add_location(form, file$m, 271, 8, 9358);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$m, 308, 8, 11146);
    			attr_dev(div6, "class", "center-block__inner center-block__inner-mod svelte-7yha38");
    			add_location(div6, file$m, 266, 4, 9139);
    			attr_dev(div7, "class", "center-block__content center-block__content-mod svelte-7yha38");
    			add_location(div7, file$m, 265, 0, 9073);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			mount_component(heading, div0, null);
    			append_dev(div6, t0);
    			append_dev(div6, hr0);
    			append_dev(div6, t1);
    			append_dev(div6, form);
    			append_dev(form, div3);
    			append_dev(div3, div1);
    			mount_component(input0, div1, null);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			mount_component(input1, div2, null);
    			append_dev(form, t3);
    			append_dev(form, hr1);
    			append_dev(form, t4);
    			append_dev(form, div4);
    			mount_component(btnstandart, div4, null);
    			append_dev(div6, t5);
    			append_dev(div6, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[7]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const input0_changes = {};
    			if (dirty & /*$exportFieldsData*/ 8) input0_changes.value = /*$exportFieldsData*/ ctx[3].base;
    			if (dirty & /*messageError*/ 2) input0_changes.errorText = /*messageError*/ ctx[1];
    			input0.$set(input0_changes);
    			const input1_changes = {};
    			if (dirty & /*$exportFieldsData*/ 8) input1_changes.value = /*$exportFieldsData*/ ctx[3].table;
    			if (dirty & /*messageError*/ 2) input1_changes.errorText = /*messageError*/ ctx[1];
    			input1.$set(input1_changes);
    			const btnstandart_changes = {};
    			if (dirty & /*submitBtnType*/ 1) btnstandart_changes.btnType = /*submitBtnType*/ ctx[0];
    			if (dirty & /*isNextBtnDisabled*/ 4) btnstandart_changes.disabled = /*isNextBtnDisabled*/ ctx[2];
    			btnstandart.$set(btnstandart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(input0.$$.fragment, local);
    			transition_in(input1.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(heading);
    			destroy_component(input0);
    			destroy_component(input1);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $exportFieldsData;
    	validate_store(exportFieldsData, "exportFieldsData");
    	component_subscribe($$self, exportFieldsData, $$value => $$invalidate(3, $exportFieldsData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ImportConfirmation", slots, []);

    	let user_import_base = exportFieldsData.user_import_base
    	? exportFieldsData.user_import_base
    	: "";

    	let user_import_table = exportFieldsData.user_import_table
    	? exportFieldsData.user_import_table
    	: "";

    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let dataForSetup = [];
    	let submitBtnType = "submit";
    	let messageError = "";

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	//checking for the presence of the entered data
    	let isNextBtnDisabled = true;

    	const changeInputHandler = () => {
    		const baseInput = document.querySelector(".js-user-community-base");
    		const tableInput = document.querySelector(".js-user-community-table");
    		$$invalidate(2, isNextBtnDisabled = !(!!baseInput.value && !!tableInput.value));
    	};

    	const goToNextStep = event => {
    		let nextStep = event.target.dataset.step;
    		if (!checkStepFields("user-import-step")) return false;

    		// Update localStorage with users data
    		saveEnteredUserData("user-import-step");

    		(async () => {
    			new Cookies();

    			/*if ( IS_DEV !== 'true') {
    	// Prevent access for user if he doesn't authorized
    	if ( !LARAVEL_SESSION ) {
    		nextStep = 'login-step';
    		return;
    	}
    }*/
    			console.log("GET_FIELDS_ENDPOINT $exportFieldsData", $exportFieldsData);

    			const GET_FIELDS_ENDPOINT = ({
    				"env": {
    					"isProd": false,
    					"CURRENT_LANG": "en",
    					"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    					"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    					"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    					"GET_POST_ENDPOINT": "/community/posts/12",
    					"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    					"SEARCH_POST_ENDPOINT": "/community/search/16",
    					"DELETE_POST_ENDPOINT": "/post/delete/15",
    					"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    					"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    					"GET_USER_PROFILE_ENDPOINT": "/profile",
    					"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    					"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    					"LIST_TAGS_ENDPOINT": "/community/tags/12",
    					"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    					"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    					"GET_COMMUNITIES_ENDPOINT": "/community",
    					"GET_DRIVERS_ENDPOINT": "/export/drivers",
    					"GET_FIELDS_ENDPOINT": "/export/fields",
    					"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    					"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    					"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    					"EXPORT_RULES_ENDPOINT": "/export"
    				}
    			}).env.GET_FIELDS_ENDPOINT;

    			$$invalidate(0, submitBtnType = "loader");
    			let res = await makeRequestToBackend($exportFieldsData, GET_FIELDS_ENDPOINT, "POST");
    			$$invalidate(0, submitBtnType = "submit");
    			console.log("res==", res);

    			// Access isn't authorized
    			if (res.status === 401) {
    				nextStep = "login-step";
    				return;
    			}

    			if (res.status === 411) {
    				$$invalidate(1, messageError = res.message);
    				let inputBase = document.querySelector(".js-user-community-base");
    				let inputTable = document.querySelector(".js-user-community-table");
    				if (inputBase) inputBase.classList.add("error");
    				if (inputTable) inputTable.classList.add("error");
    				return;
    			}

    			responseFieldsData.update(n => res);
    			dispatch("goToStep", { step: nextStep });
    		})();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<ImportConfirmation> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		makeRequestToBackend,
    		saveEnteredUserData,
    		createEventDispatcher,
    		translations,
    		BtnBack,
    		BtnStandart,
    		Input,
    		Heading,
    		exportFieldsData,
    		responseFieldsData,
    		Cookies,
    		user_import_base,
    		user_import_table,
    		dispatch,
    		LANG,
    		dataForSetup,
    		submitBtnType,
    		messageError,
    		goToBack,
    		isNextBtnDisabled,
    		changeInputHandler,
    		goToNextStep,
    		$exportFieldsData
    	});

    	$$self.$inject_state = $$props => {
    		if ("user_import_base" in $$props) user_import_base = $$props.user_import_base;
    		if ("user_import_table" in $$props) user_import_table = $$props.user_import_table;
    		if ("dataForSetup" in $$props) dataForSetup = $$props.dataForSetup;
    		if ("submitBtnType" in $$props) $$invalidate(0, submitBtnType = $$props.submitBtnType);
    		if ("messageError" in $$props) $$invalidate(1, messageError = $$props.messageError);
    		if ("isNextBtnDisabled" in $$props) $$invalidate(2, isNextBtnDisabled = $$props.isNextBtnDisabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		submitBtnType,
    		messageError,
    		isNextBtnDisabled,
    		$exportFieldsData,
    		LANG,
    		goToBack,
    		changeInputHandler,
    		goToNextStep
    	];
    }

    class ImportConfirmation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImportConfirmation",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /* src/components/WillYouReadThisBlock.svelte generated by Svelte v3.32.1 */
    const file$n = "src/components/WillYouReadThisBlock.svelte";

    function create_fragment$o(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[0]].willYouReadThisBlock.description + "";
    	let t1;
    	let div1;
    	let btnstandart;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.willYouReadThisBlock?.heading
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "willYouReadThisBlock2-step",
    				text: translations[/*LANG*/ ctx[0]].willYouReadThisBlock.willYouReadThisBlock_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*goToNextStep*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$n, 18, 8, 1613);
    			html_tag = new HtmlTag(t1);
    			attr_dev(div1, "class", "mt-30");
    			add_location(div1, file$n, 23, 8, 1817);
    			attr_dev(div2, "class", "center-block__inner lh-large");
    			add_location(div2, file$n, 17, 4, 1562);
    			attr_dev(div3, "class", "center-block__content");
    			add_location(div3, file$n, 16, 0, 1522);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(heading, div0, null);
    			append_dev(div2, t0);
    			html_tag.m(raw_value, div2);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(btnstandart, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(heading);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WillYouReadThisBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WillYouReadThisBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep
    	});

    	return [LANG, goToNextStep];
    }

    class WillYouReadThisBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WillYouReadThisBlock",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src/components/WillYouReadThisBlock2.svelte generated by Svelte v3.32.1 */
    const file$o = "src/components/WillYouReadThisBlock2.svelte";

    function create_fragment$p(ctx) {
    	let div6;
    	let div5;
    	let div0;
    	let heading;
    	let t0;
    	let div3;
    	let div2;
    	let div1;
    	let html_tag;
    	let raw0_value = translations[/*LANG*/ ctx[2]].willYouReadThisBlock2.description + "";
    	let t1;
    	let html_tag_1;
    	let raw1_value = translations[/*LANG*/ ctx[2]].willYouReadThisBlock2.description + "";
    	let t2;
    	let scrollbar;
    	let t3;
    	let div4;
    	let btnstandart;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[2]]?.willYouReadThisBlock2?.heading
    			},
    			$$inline: true
    		});

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "shallWeStartBlock-step",
    				text: translations[/*LANG*/ ctx[2]].willYouReadThisBlock2.willYouReadThisBlock2_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*goToNextStep*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div5 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			t1 = space();
    			t2 = space();
    			create_component(scrollbar.$$.fragment);
    			t3 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$o, 224, 8, 5647);
    			html_tag = new HtmlTag(t1);
    			html_tag_1 = new HtmlTag(null);
    			attr_dev(div1, "class", "dynamic-content");
    			add_location(div1, file$o, 229, 16, 5883);
    			attr_dev(div2, "class", "my-scroller svelte-or70jv");
    			add_location(div2, file$o, 228, 12, 5813);
    			attr_dev(div3, "class", "wrap-scroll svelte-or70jv");
    			add_location(div3, file$o, 227, 8, 5775);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$o, 244, 8, 6430);
    			attr_dev(div5, "class", "center-block__inner read-block svelte-or70jv");
    			add_location(div5, file$o, 223, 4, 5594);
    			attr_dev(div6, "class", "center-block__content");
    			add_location(div6, file$o, 222, 0, 5554);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			mount_component(heading, div0, null);
    			append_dev(div5, t0);
    			append_dev(div5, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			html_tag.m(raw0_value, div1);
    			append_dev(div1, t1);
    			html_tag_1.m(raw1_value, div1);
    			/*div1_binding*/ ctx[4](div1);
    			/*div2_binding*/ ctx[5](div2);
    			append_dev(div3, t2);
    			mount_component(scrollbar, div3, null);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			mount_component(btnstandart, div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(heading);
    			/*div1_binding*/ ctx[4](null);
    			/*div2_binding*/ ctx[5](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WillYouReadThisBlock2", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WillYouReadThisBlock2> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnStandart,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep,
    		iChangeMyHeight,
    		iAmScrollArea
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [iChangeMyHeight, iAmScrollArea, LANG, goToNextStep, div1_binding, div2_binding];
    }

    class WillYouReadThisBlock2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WillYouReadThisBlock2",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src/components/ShallWeStartBlock.svelte generated by Svelte v3.32.1 */
    const file$p = "src/components/ShallWeStartBlock.svelte";

    function create_fragment$q(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[0]].shallWeStart.description + "";
    	let t1;
    	let div1;
    	let btnstandart;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.shallWeStart?.heading
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "createAccessRulesBlock-step",
    				text: translations[/*LANG*/ ctx[0]].shallWeStart.shallWeStart_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*goToNextStep*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$p, 19, 8, 1612);
    			html_tag = new HtmlTag(t1);
    			attr_dev(div1, "class", "mt-30");
    			add_location(div1, file$p, 23, 8, 1791);
    			attr_dev(div2, "class", "center-block__inner mod-ol");
    			add_location(div2, file$p, 18, 4, 1563);
    			attr_dev(div3, "class", "center-block__content");
    			add_location(div3, file$p, 17, 0, 1523);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(heading, div0, null);
    			append_dev(div2, t0);
    			html_tag.m(raw_value, div2);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(btnstandart, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(heading);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ShallWeStartBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ShallWeStartBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep
    	});

    	return [LANG, goToNextStep];
    }

    class ShallWeStartBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ShallWeStartBlock",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src/components/CreateAccessRulesBlock.svelte generated by Svelte v3.32.1 */
    const file$q = "src/components/CreateAccessRulesBlock.svelte";

    function create_fragment$r(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[0]].createAccessRules.description + "";
    	let t1;
    	let div1;
    	let btnstandart;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.createAccessRules?.heading
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "addRulesBlock-step",
    				text: translations[/*LANG*/ ctx[0]].createAccessRules.createAccessRules_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*goToNextStep*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$q, 20, 8, 1606);
    			html_tag = new HtmlTag(t1);
    			attr_dev(div1, "class", "mt-30");
    			add_location(div1, file$q, 26, 8, 1813);
    			attr_dev(div2, "class", "center-block__inner");
    			add_location(div2, file$q, 19, 4, 1564);
    			attr_dev(div3, "class", "center-block__content");
    			add_location(div3, file$q, 17, 0, 1523);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(heading, div0, null);
    			append_dev(div2, t0);
    			html_tag.m(raw_value, div2);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(btnstandart, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(heading);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CreateAccessRulesBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CreateAccessRulesBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep
    	});

    	return [LANG, goToNextStep];
    }

    class CreateAccessRulesBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CreateAccessRulesBlock",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src/components/buttons/BtnSymbol.svelte generated by Svelte v3.32.1 */
    const file$r = "src/components/buttons/BtnSymbol.svelte";

    function create_fragment$s(ctx) {
    	let button;
    	let i;
    	let i_class_value;
    	let button_class_value;
    	let button_data_role_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "btn-" + /*symbol*/ ctx[0] + " svelte-1jl4k3k");
    			add_location(i, file$r, 362, 4, 19604);
    			attr_dev(button, "class", button_class_value = "btn-small " + /*size*/ ctx[5] + " " + /*addClass*/ ctx[4] + " " + /*color*/ ctx[6] + " svelte-1jl4k3k");
    			attr_dev(button, "data-role", button_data_role_value = /*dataRole*/ ctx[2] ?? "");
    			attr_dev(button, "data-index", /*dataIndex*/ ctx[1]);
    			button.disabled = /*disabled*/ ctx[3];
    			add_location(button, file$r, 357, 0, 19428);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, i);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*click_handler*/ ctx[7]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*symbol*/ 1 && i_class_value !== (i_class_value = "btn-" + /*symbol*/ ctx[0] + " svelte-1jl4k3k")) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (dirty & /*size, addClass, color*/ 112 && button_class_value !== (button_class_value = "btn-small " + /*size*/ ctx[5] + " " + /*addClass*/ ctx[4] + " " + /*color*/ ctx[6] + " svelte-1jl4k3k")) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty & /*dataRole*/ 4 && button_data_role_value !== (button_data_role_value = /*dataRole*/ ctx[2] ?? "")) {
    				attr_dev(button, "data-role", button_data_role_value);
    			}

    			if (dirty & /*dataIndex*/ 2) {
    				attr_dev(button, "data-index", /*dataIndex*/ ctx[1]);
    			}

    			if (dirty & /*disabled*/ 8) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BtnSymbol", slots, []);
    	const dispatch = createEventDispatcher();
    	let { symbol = "" } = $$props;
    	let { dataIndex = 0 } = $$props;
    	let { dataRole = "" } = $$props;
    	let { disabled = "" } = $$props;
    	let { addClass = "" } = $$props;
    	let { size = "medium" } = $$props;
    	let { color = "purple" } = $$props;
    	const writable_props = ["symbol", "dataIndex", "dataRole", "disabled", "addClass", "size", "color"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BtnSymbol> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("symbol" in $$props) $$invalidate(0, symbol = $$props.symbol);
    		if ("dataIndex" in $$props) $$invalidate(1, dataIndex = $$props.dataIndex);
    		if ("dataRole" in $$props) $$invalidate(2, dataRole = $$props.dataRole);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("addClass" in $$props) $$invalidate(4, addClass = $$props.addClass);
    		if ("size" in $$props) $$invalidate(5, size = $$props.size);
    		if ("color" in $$props) $$invalidate(6, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		symbol,
    		dataIndex,
    		dataRole,
    		disabled,
    		addClass,
    		size,
    		color
    	});

    	$$self.$inject_state = $$props => {
    		if ("symbol" in $$props) $$invalidate(0, symbol = $$props.symbol);
    		if ("dataIndex" in $$props) $$invalidate(1, dataIndex = $$props.dataIndex);
    		if ("dataRole" in $$props) $$invalidate(2, dataRole = $$props.dataRole);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("addClass" in $$props) $$invalidate(4, addClass = $$props.addClass);
    		if ("size" in $$props) $$invalidate(5, size = $$props.size);
    		if ("color" in $$props) $$invalidate(6, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [symbol, dataIndex, dataRole, disabled, addClass, size, color, click_handler];
    }

    class BtnSymbol extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
    			symbol: 0,
    			dataIndex: 1,
    			dataRole: 2,
    			disabled: 3,
    			addClass: 4,
    			size: 5,
    			color: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BtnSymbol",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get symbol() {
    		throw new Error("<BtnSymbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set symbol(value) {
    		throw new Error("<BtnSymbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataIndex() {
    		throw new Error("<BtnSymbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataIndex(value) {
    		throw new Error("<BtnSymbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataRole() {
    		throw new Error("<BtnSymbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRole(value) {
    		throw new Error("<BtnSymbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<BtnSymbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<BtnSymbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addClass() {
    		throw new Error("<BtnSymbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set addClass(value) {
    		throw new Error("<BtnSymbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<BtnSymbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<BtnSymbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<BtnSymbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<BtnSymbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Rule.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$1, console: console_1$3 } = globals;
    const file$s = "src/components/Rule.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (577:8) {#if isAutoCompleteOpen}
    function create_if_block$9(ctx) {
    	let ul;
    	let if_block = /*autoCompleteValues*/ ctx[4] && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (if_block) if_block.c();
    			attr_dev(ul, "class", "autocomplete-values svelte-19p1024");
    			add_location(ul, file$s, 577, 12, 27904);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			if (if_block) if_block.m(ul, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*autoCompleteValues*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					if_block.m(ul, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(577:8) {#if isAutoCompleteOpen}",
    		ctx
    	});

    	return block;
    }

    // (579:16) {#if autoCompleteValues}
    function create_if_block_1$7(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let each_value = /*autoCompleteValues*/ ctx[4];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[18];
    	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selectAutocompleteValueHandler, autoCompleteValues*/ 1040) {
    				each_value = /*autoCompleteValues*/ ctx[4];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$3, each_1_anchor, get_each_context$3);
    			}
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(579:16) {#if autoCompleteValues}",
    		ctx
    	});

    	return block;
    }

    // (580:20) {#each autoCompleteValues as value, index (index)}
    function create_each_block$3(key_1, ctx) {
    	let li;
    	let t_value = /*value*/ ctx[16] + "";
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			t = text(t_value);
    			attr_dev(li, "class", "svelte-19p1024");
    			add_location(li, file$s, 580, 25, 28074);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t);

    			if (!mounted) {
    				dispose = listen_dev(li, "click", /*selectAutocompleteValueHandler*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*autoCompleteValues*/ 16 && t_value !== (t_value = /*value*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(580:20) {#each autoCompleteValues as value, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div2;
    	let select0;
    	let t0;
    	let select1;
    	let t1;
    	let div0;
    	let input;
    	let t2;
    	let t3;
    	let div1;
    	let btnsymbol0;
    	let t4;
    	let btnsymbol1;
    	let current;

    	select0 = new Select({
    			props: {
    				wrapperClass: "rules__elem",
    				className: "select js-rule-name",
    				label: translations[/*LANG*/ ctx[7]]?.addRules?.label_text_1,
    				name: "rules[name]",
    				groupIndex: /*keyIndex*/ ctx[1],
    				optionObject: /*ruleOptions*/ ctx[9]
    			},
    			$$inline: true
    		});

    	select1 = new Select({
    			props: {
    				wrapperClass: "rules__elem",
    				dataInputRole: "name",
    				label: translations[/*LANG*/ ctx[7]]?.addRules?.label_text_2,
    				name: "rules[compare]",
    				optionObject: /*operators*/ ctx[8],
    				groupIndex: /*keyIndex*/ ctx[1]
    			},
    			$$inline: true
    		});

    	input = new Input({
    			props: {
    				wrapperClass: "",
    				dataInputRole: "anyText",
    				className: "form-control__input-text form-control__rule-input",
    				label: translations[/*LANG*/ ctx[7]]?.addRules?.label_text_3,
    				name: "rules[value]",
    				groupIndex: /*keyIndex*/ ctx[1],
    				value: /*computedValue*/ ctx[5]
    			},
    			$$inline: true
    		});

    	input.$on("input", /*autocompleteHandler*/ ctx[11]);
    	let if_block = /*isAutoCompleteOpen*/ ctx[6] && create_if_block$9(ctx);

    	btnsymbol0 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "add",
    				addClass: "mr-10",
    				dataRole: /*dataRolePlus*/ ctx[0]
    			},
    			$$inline: true
    		});

    	btnsymbol0.$on("click", /*click_handler*/ ctx[13]);

    	btnsymbol1 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "del",
    				dataRole: /*dataRoleRemove*/ ctx[2],
    				addClass: "mr-10",
    				dataIndex: /*keyIndex*/ ctx[1],
    				disabled: /*disableStatus*/ ctx[3]
    			},
    			$$inline: true
    		});

    	btnsymbol1.$on("click", /*click_handler_1*/ ctx[14]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			create_component(select0.$$.fragment);
    			t0 = space();
    			create_component(select1.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			create_component(input.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			t3 = space();
    			div1 = element("div");
    			create_component(btnsymbol0.$$.fragment);
    			t4 = space();
    			create_component(btnsymbol1.$$.fragment);
    			attr_dev(div0, "class", "rule-value-wrapper rules__elem svelte-19p1024");
    			add_location(div0, file$s, 565, 4, 27434);
    			attr_dev(div1, "class", "rules__inputs svelte-19p1024");
    			add_location(div1, file$s, 586, 4, 28230);
    			attr_dev(div2, "class", "rules__block border-tb js-rule-item svelte-19p1024");
    			attr_dev(div2, "data-index", /*keyIndex*/ ctx[1]);
    			add_location(div2, file$s, 546, 0, 26863);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			mount_component(select0, div2, null);
    			append_dev(div2, t0);
    			mount_component(select1, div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			mount_component(input, div0, null);
    			append_dev(div0, t2);
    			if (if_block) if_block.m(div0, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(btnsymbol0, div1, null);
    			append_dev(div1, t4);
    			mount_component(btnsymbol1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const select0_changes = {};
    			if (dirty & /*keyIndex*/ 2) select0_changes.groupIndex = /*keyIndex*/ ctx[1];
    			select0.$set(select0_changes);
    			const select1_changes = {};
    			if (dirty & /*keyIndex*/ 2) select1_changes.groupIndex = /*keyIndex*/ ctx[1];
    			select1.$set(select1_changes);
    			const input_changes = {};
    			if (dirty & /*keyIndex*/ 2) input_changes.groupIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*computedValue*/ 32) input_changes.value = /*computedValue*/ ctx[5];
    			input.$set(input_changes);

    			if (/*isAutoCompleteOpen*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const btnsymbol0_changes = {};
    			if (dirty & /*dataRolePlus*/ 1) btnsymbol0_changes.dataRole = /*dataRolePlus*/ ctx[0];
    			btnsymbol0.$set(btnsymbol0_changes);
    			const btnsymbol1_changes = {};
    			if (dirty & /*dataRoleRemove*/ 4) btnsymbol1_changes.dataRole = /*dataRoleRemove*/ ctx[2];
    			if (dirty & /*keyIndex*/ 2) btnsymbol1_changes.dataIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*disableStatus*/ 8) btnsymbol1_changes.disabled = /*disableStatus*/ ctx[3];
    			btnsymbol1.$set(btnsymbol1_changes);

    			if (!current || dirty & /*keyIndex*/ 2) {
    				attr_dev(div2, "data-index", /*keyIndex*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select0.$$.fragment, local);
    			transition_in(select1.$$.fragment, local);
    			transition_in(input.$$.fragment, local);
    			transition_in(btnsymbol0.$$.fragment, local);
    			transition_in(btnsymbol1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select0.$$.fragment, local);
    			transition_out(select1.$$.fragment, local);
    			transition_out(input.$$.fragment, local);
    			transition_out(btnsymbol0.$$.fragment, local);
    			transition_out(btnsymbol1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(select0);
    			destroy_component(select1);
    			destroy_component(input);
    			if (if_block) if_block.d();
    			destroy_component(btnsymbol0);
    			destroy_component(btnsymbol1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Rule", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const dispatch = createEventDispatcher();
    	let { dataRolePlus = "" } = $$props;
    	let { keyIndex = "" } = $$props;
    	let { dataRoleRemove = "" } = $$props;
    	let { readOnly = "" } = $$props;
    	let { disableStatus = "disabled" } = $$props;
    	let autoCompleteValues = [];
    	let computedValue = "";
    	let isAutoCompleteOpen = !autoCompleteValues.length;
    	const operators = ["<", ">", "<>", "=", "like", "not like"];
    	const ruleOptions = ["Email", "Name", "Location", "Organization", "Title", "Industry"];

    	/**
     * Select some autocomplete value
     * @param event
     */
    	const selectAutocompleteValueHandler = event => {
    		$$invalidate(5, computedValue = event.target.innerText);
    		$$invalidate(6, isAutoCompleteOpen = false);
    	};

    	/**
     * Make request for autocomplete values
     * @type {function(...[*]=)}
     */
    	const autocompleteHandler = debounce(
    		event => {
    			// Skip request if entered value is empty
    			if (!event.target.value) return;

    			// Checking what page should we open on start app
    			(async () => {
    				const AUTOCOMPLETE_VALUES_ENDPOINT = ({
    					"env": {
    						"isProd": false,
    						"CURRENT_LANG": "en",
    						"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    						"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    						"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    						"GET_POST_ENDPOINT": "/community/posts/12",
    						"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    						"SEARCH_POST_ENDPOINT": "/community/search/16",
    						"DELETE_POST_ENDPOINT": "/post/delete/15",
    						"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    						"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    						"GET_USER_PROFILE_ENDPOINT": "/profile",
    						"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    						"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    						"LIST_TAGS_ENDPOINT": "/community/tags/12",
    						"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    						"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    						"GET_COMMUNITIES_ENDPOINT": "/community",
    						"GET_DRIVERS_ENDPOINT": "/export/drivers",
    						"GET_FIELDS_ENDPOINT": "/export/fields",
    						"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    						"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    						"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    						"EXPORT_RULES_ENDPOINT": "/export"
    					}
    				}).env.AUTOCOMPLETE_VALUES_ENDPOINT;

    				const RULE_ITEM = event.target.closest(".js-rule-item");
    				const RULE_NAME = RULE_ITEM.querySelector(".js-rule-name");

    				const data = {
    					"field": RULE_NAME.value,
    					"text": event.target.value
    				};

    				const queryString = Object.keys(data).map(key => `${key}=${data[key]}`).join("&");
    				let res = await makeRequestToBackend(false, AUTOCOMPLETE_VALUES_ENDPOINT + "?" + queryString, "GET");
    				console.log("AUTOCOMPLETE_VALUES_ENDPOINT res", res);

    				// Access isn't authorized
    				if (res.status === 401) {
    					dispatch("goToStep", { step: "login-step" });
    					return;
    				}

    				// convert received autocomplete data
    				$$invalidate(4, autoCompleteValues = JSON.parse(res));
    			})();
    		},
    		700
    	);

    	const writable_props = ["dataRolePlus", "keyIndex", "dataRoleRemove", "readOnly", "disableStatus"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Rule> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataRolePlus" in $$props) $$invalidate(0, dataRolePlus = $$props.dataRolePlus);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("readOnly" in $$props) $$invalidate(12, readOnly = $$props.readOnly);
    		if ("disableStatus" in $$props) $$invalidate(3, disableStatus = $$props.disableStatus);
    	};

    	$$self.$capture_state = () => ({
    		translations,
    		BtnSymbol,
    		Input,
    		Select,
    		makeRequestToBackend,
    		debounce,
    		createEventDispatcher,
    		LANG,
    		dispatch,
    		dataRolePlus,
    		keyIndex,
    		dataRoleRemove,
    		readOnly,
    		disableStatus,
    		autoCompleteValues,
    		computedValue,
    		isAutoCompleteOpen,
    		operators,
    		ruleOptions,
    		selectAutocompleteValueHandler,
    		autocompleteHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataRolePlus" in $$props) $$invalidate(0, dataRolePlus = $$props.dataRolePlus);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("readOnly" in $$props) $$invalidate(12, readOnly = $$props.readOnly);
    		if ("disableStatus" in $$props) $$invalidate(3, disableStatus = $$props.disableStatus);
    		if ("autoCompleteValues" in $$props) $$invalidate(4, autoCompleteValues = $$props.autoCompleteValues);
    		if ("computedValue" in $$props) $$invalidate(5, computedValue = $$props.computedValue);
    		if ("isAutoCompleteOpen" in $$props) $$invalidate(6, isAutoCompleteOpen = $$props.isAutoCompleteOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dataRolePlus,
    		keyIndex,
    		dataRoleRemove,
    		disableStatus,
    		autoCompleteValues,
    		computedValue,
    		isAutoCompleteOpen,
    		LANG,
    		operators,
    		ruleOptions,
    		selectAutocompleteValueHandler,
    		autocompleteHandler,
    		readOnly,
    		click_handler,
    		click_handler_1
    	];
    }

    class Rule extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			dataRolePlus: 0,
    			keyIndex: 1,
    			dataRoleRemove: 2,
    			readOnly: 12,
    			disableStatus: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rule",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get dataRolePlus() {
    		throw new Error("<Rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRolePlus(value) {
    		throw new Error("<Rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keyIndex() {
    		throw new Error("<Rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keyIndex(value) {
    		throw new Error("<Rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataRoleRemove() {
    		throw new Error("<Rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRoleRemove(value) {
    		throw new Error("<Rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error("<Rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<Rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disableStatus() {
    		throw new Error("<Rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disableStatus(value) {
    		throw new Error("<Rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/AddRulesBlock.svelte generated by Svelte v3.32.1 */

    const { console: console_1$4 } = globals;

    const file$t = "src/components/AddRulesBlock.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[16] = i;
    	return child_ctx;
    }

    // (425:20) {#each itemsCount as component , index}
    function create_each_block$4(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[14];

    	function switch_props(ctx) {
    		return {
    			props: {
    				keyIndex: /*index*/ ctx[16],
    				disableStatus: "disabled",
    				dataRoleRemove: "remove-elem",
    				dataRolePlus: "create-new-elem"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*component*/ ctx[14])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(425:20) {#each itemsCount as component , index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let div6;
    	let form;
    	let div0;
    	let heading;
    	let t0;
    	let div3;
    	let div2;
    	let div1;
    	let t1;
    	let scrollbar;
    	let t2;
    	let div4;
    	let btnstandart;
    	let t3;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[3]]?.addRules?.heading
    			},
    			$$inline: true
    		});

    	let each_value = /*itemsCount*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[1],
    				scrollArea: /*iAmScrollArea*/ ctx[2],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[3]].addRules.addRules_btn,
    				btnType: "submit",
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "createAccessRulesBlock-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			form = element("form");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(scrollbar.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t3 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$t, 418, 8, 12708);
    			attr_dev(div1, "class", "wrap-rules-blocks");
    			add_location(div1, file$t, 423, 16, 12965);
    			attr_dev(div2, "class", "dynamic-content");
    			add_location(div2, file$t, 422, 12, 12889);
    			attr_dev(div3, "class", "my-scroller svelte-9gdgb6");
    			add_location(div3, file$t, 421, 8, 12823);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$t, 442, 8, 13750);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$t, 449, 8, 13966);
    			attr_dev(form, "data-role", "addRulesBlock-step");
    			attr_dev(form, "data-step", "editRulesBlock-step");
    			attr_dev(form, "name", "add-rules-form");
    			add_location(form, file$t, 413, 4, 12533);
    			attr_dev(div6, "class", "center-block__content rules svelte-9gdgb6");
    			add_location(div6, file$t, 412, 0, 12487);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, form);
    			append_dev(form, div0);
    			mount_component(heading, div0, null);
    			append_dev(form, t0);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			/*div2_binding*/ ctx[7](div2);
    			/*div3_binding*/ ctx[8](div3);
    			append_dev(form, t1);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t2);
    			append_dev(form, div4);
    			mount_component(btnstandart, div4, null);
    			append_dev(form, t3);
    			append_dev(form, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[5]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*itemsCount, elemBehaviourHandler*/ 65) {
    				each_value = /*itemsCount*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 2) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[1];
    			if (dirty & /*iAmScrollArea*/ 4) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[2];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(heading);
    			destroy_each(each_blocks, detaching);
    			/*div2_binding*/ ctx[7](null);
    			/*div3_binding*/ ctx[8](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let $previewTagsData;
    	let $createdAudienceData;
    	let $createdCommunityData;
    	validate_store(previewTagsData, "previewTagsData");
    	component_subscribe($$self, previewTagsData, $$value => $$invalidate(9, $previewTagsData = $$value));
    	validate_store(createdAudienceData, "createdAudienceData");
    	component_subscribe($$self, createdAudienceData, $$value => $$invalidate(10, $createdAudienceData = $$value));
    	validate_store(createdCommunityData, "createdCommunityData");
    	component_subscribe($$self, createdCommunityData, $$value => $$invalidate(11, $createdCommunityData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AddRulesBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [Rule];
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	let autoCompleteValuesFormatted = [];

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	console.log("previewTagsData", $previewTagsData);

    	/**
     *  Go to next step
     */
    	const goToNextStep = event => {
    		if (!checkStepFields("addRulesBlock-step")) return false;

    		// Checking what page should we open on start app
    		(async () => {
    			const formData = new FormData(event.target);
    			let rules = {};
    			const names = formData.getAll("rules[name]");
    			const compare = formData.getAll("rules[compare]");
    			const values = formData.getAll("rules[value]");

    			for (let i = 0; i < names.length; i++) {
    				rules[`rules[${i}][name]`] = names[i];
    				rules[`rules[${i}][compare]`] = compare[i];
    				rules[`rules[${i}][value]`] = values[i];
    			}

    			console.log("createdAudienceData", $createdAudienceData);
    			console.log("$previewTagsData", $previewTagsData);

    			const generalData = {
    				"fields[Email]": $previewTagsData.fields["Email"],
    				"fields[Name]": $previewTagsData.fields["Name"],
    				"fields[Location]": $previewTagsData.fields["Location"],
    				"fields[Organization]": $previewTagsData.fields["Organization"],
    				"fields[Title]": $previewTagsData.fields["Title"],
    				"fields[Industry]": $previewTagsData.fields["Industry"]
    			};

    			const EXPORT_RULES_ENDPOINT = ({
    				"env": {
    					"isProd": false,
    					"CURRENT_LANG": "en",
    					"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    					"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    					"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    					"GET_POST_ENDPOINT": "/community/posts/12",
    					"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    					"SEARCH_POST_ENDPOINT": "/community/search/16",
    					"DELETE_POST_ENDPOINT": "/post/delete/15",
    					"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    					"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    					"GET_USER_PROFILE_ENDPOINT": "/profile",
    					"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    					"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    					"LIST_TAGS_ENDPOINT": "/community/tags/12",
    					"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    					"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    					"GET_COMMUNITIES_ENDPOINT": "/community",
    					"GET_DRIVERS_ENDPOINT": "/export/drivers",
    					"GET_FIELDS_ENDPOINT": "/export/fields",
    					"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    					"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    					"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    					"EXPORT_RULES_ENDPOINT": "/export"
    				}
    			}).env.EXPORT_RULES_ENDPOINT;

    			const data = {
    				...generalData,
    				...$previewTagsData,
    				//...temp,
    				...rules,
    				"community_id": $createdCommunityData.id
    			};

    			delete data.fields;
    			console.log("EXPORT_RULES_ENDPOINT data", data);
    			let res = await makeRequestToBackend(data, EXPORT_RULES_ENDPOINT, "POST");
    			console.log("EXPORT_RULES_ENDPOINT res", res);

    			// Access isn't authorized
    			if (res.status === 401) {
    				dispatch("goToStep", { step: "login-step" });
    				return;
    			}
    		})();
    	}; /*dispatch('goToStep', {
        step: event.target.dataset.step,
    });*/

    	/**
     * Create duplicate rule set / Remove existing rule set
     * @param event
     */
    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;
    		let rowsRules = "";

    		switch (ROLE) {
    			case "create-new-elem":
    				setTimeout(
    					function () {
    						rowsRules = document.querySelectorAll(".rules__block");

    						rowsRules.forEach(element => {
    							element.querySelectorAll("button")[1].disabled = false;
    						});
    					},
    					100
    				);
    				$$invalidate(0, itemsCount = [...itemsCount, Rule]);
    				break;
    			case "remove-elem":
    				setTimeout(
    					function () {
    						rowsRules = document.querySelectorAll(".rules__block");

    						if (rowsRules.length < 2) {
    							rowsRules.forEach(element => {
    								element.querySelectorAll("button")[1].disabled = true;
    							});
    						}
    					},
    					100
    				);
    				delete itemsCount[ITEM_INDEX];
    				$$invalidate(0, itemsCount);
    				break;
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<AddRulesBlock> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(1, iChangeMyHeight);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(2, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		saveEnteredRuleData,
    		makeRequestToBackend,
    		debounce,
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnBack,
    		BtnStandart,
    		Heading,
    		Rule,
    		previewTagsData,
    		createdCommunityData,
    		createdAudienceData,
    		dispatch,
    		LANG,
    		itemsCount,
    		iChangeMyHeight,
    		iAmScrollArea,
    		autoCompleteValuesFormatted,
    		goToBack,
    		goToNextStep,
    		elemBehaviourHandler,
    		$previewTagsData,
    		$createdAudienceData,
    		$createdCommunityData
    	});

    	$$self.$inject_state = $$props => {
    		if ("itemsCount" in $$props) $$invalidate(0, itemsCount = $$props.itemsCount);
    		if ("iChangeMyHeight" in $$props) $$invalidate(1, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(2, iAmScrollArea = $$props.iAmScrollArea);
    		if ("autoCompleteValuesFormatted" in $$props) autoCompleteValuesFormatted = $$props.autoCompleteValuesFormatted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		itemsCount,
    		iChangeMyHeight,
    		iAmScrollArea,
    		LANG,
    		goToBack,
    		goToNextStep,
    		elemBehaviourHandler,
    		div2_binding,
    		div3_binding
    	];
    }

    class AddRulesBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddRulesBlock",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src/components/RuleEdit.svelte generated by Svelte v3.32.1 */
    const file$u = "src/components/RuleEdit.svelte";

    function create_fragment$v(ctx) {
    	let div10;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let div8;
    	let div3;
    	let div2;
    	let input0;
    	let t3;
    	let div5;
    	let div4;
    	let select;
    	let t4;
    	let div7;
    	let div6;
    	let input1;
    	let t5;
    	let div9;
    	let btnsymbol0;
    	let t6;
    	let btnsymbol1;
    	let current;

    	input0 = new Input({
    			props: {
    				wrapperClass: "",
    				dataInputRole: "anyText",
    				className: "form-control__input-text form-control__rule-input",
    				label: translations[/*LANG*/ ctx[6]]?.addRules?.label_text_1,
    				name: "rule-field[]",
    				groupIndex: /*keyIndex*/ ctx[1],
    				value: /*data*/ ctx[5]["rule-field"],
    				valueReadOnly: /*isReadOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	select = new Select({
    			props: {
    				wrapperClass: "",
    				dataInputRole: "anyText",
    				label: translations[/*LANG*/ ctx[6]]?.addRules?.label_text_2,
    				name: "rule-operator[]",
    				groupIndex: /*keyIndex*/ ctx[1],
    				optionObject: /*operators*/ ctx[4],
    				selectedValue: /*data*/ ctx[5]["rule-operator"],
    				valueReadOnly: /*isReadOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	input1 = new Input({
    			props: {
    				wrapperClass: "",
    				dataInputRole: "anyText",
    				groupIndex: /*keyIndex*/ ctx[1],
    				className: "form-control__input-text form-control__rule-input",
    				label: translations[/*LANG*/ ctx[6]]?.addRules?.label_text_3,
    				name: "rule-value[]",
    				value: /*data*/ ctx[5]["rule-value"],
    				valueReadOnly: /*isReadOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	btnsymbol0 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "edit",
    				addClass: "mr-10",
    				dataRole: /*dataRoleEdit*/ ctx[0]
    			},
    			$$inline: true
    		});

    	btnsymbol0.$on("click", /*click_handler*/ ctx[7]);

    	btnsymbol1 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "del",
    				dataRole: /*dataRoleRemove*/ ctx[2],
    				addClass: "mr-10",
    				dataIndex: /*keyIndex*/ ctx[1]
    			},
    			$$inline: true
    		});

    	btnsymbol1.$on("click", /*click_handler_1*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text("Rule #");
    			t1 = text(/*keyIndex*/ ctx[1]);
    			t2 = space();
    			div8 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			create_component(input0.$$.fragment);
    			t3 = space();
    			div5 = element("div");
    			div4 = element("div");
    			create_component(select.$$.fragment);
    			t4 = space();
    			div7 = element("div");
    			div6 = element("div");
    			create_component(input1.$$.fragment);
    			t5 = space();
    			div9 = element("div");
    			create_component(btnsymbol0.$$.fragment);
    			t6 = space();
    			create_component(btnsymbol1.$$.fragment);
    			attr_dev(div0, "class", "rule-id svelte-lv448z");
    			add_location(div0, file$u, 520, 8, 27441);
    			attr_dev(div1, "class", "rules-edit__elem svelte-lv448z");
    			add_location(div1, file$u, 519, 4, 27402);
    			attr_dev(div2, "class", "rules-edit__mob svelte-lv448z");
    			add_location(div2, file$u, 524, 12, 27595);
    			attr_dev(div3, "class", "rules-group__item svelte-lv448z");
    			add_location(div3, file$u, 523, 8, 27551);
    			attr_dev(div4, "class", "rules-edit__mob svelte-lv448z");
    			add_location(div4, file$u, 537, 12, 28163);
    			attr_dev(div5, "class", "rules-group__item svelte-lv448z");
    			add_location(div5, file$u, 536, 8, 28119);
    			attr_dev(div6, "class", "rules-edit__mob svelte-lv448z");
    			add_location(div6, file$u, 551, 12, 28740);
    			attr_dev(div7, "class", "rules-group__item svelte-lv448z");
    			add_location(div7, file$u, 550, 8, 28696);
    			attr_dev(div8, "class", "rules-edit__elem rules-group svelte-lv448z");
    			add_location(div8, file$u, 522, 4, 27500);
    			attr_dev(div9, "class", "rules-edit__elem d-flex svelte-lv448z");
    			add_location(div9, file$u, 564, 4, 29271);
    			attr_dev(div10, "class", "rules-edit__block border-tb svelte-lv448z");
    			attr_dev(div10, "data-index", /*keyIndex*/ ctx[1]);
    			add_location(div10, file$u, 518, 0, 27333);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div10, t2);
    			append_dev(div10, div8);
    			append_dev(div8, div3);
    			append_dev(div3, div2);
    			mount_component(input0, div2, null);
    			append_dev(div8, t3);
    			append_dev(div8, div5);
    			append_dev(div5, div4);
    			mount_component(select, div4, null);
    			append_dev(div8, t4);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			mount_component(input1, div6, null);
    			append_dev(div10, t5);
    			append_dev(div10, div9);
    			mount_component(btnsymbol0, div9, null);
    			append_dev(div9, t6);
    			mount_component(btnsymbol1, div9, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*keyIndex*/ 2) set_data_dev(t1, /*keyIndex*/ ctx[1]);
    			const input0_changes = {};
    			if (dirty & /*keyIndex*/ 2) input0_changes.groupIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*data*/ 32) input0_changes.value = /*data*/ ctx[5]["rule-field"];
    			if (dirty & /*isReadOnly*/ 8) input0_changes.valueReadOnly = /*isReadOnly*/ ctx[3];
    			input0.$set(input0_changes);
    			const select_changes = {};
    			if (dirty & /*keyIndex*/ 2) select_changes.groupIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*operators*/ 16) select_changes.optionObject = /*operators*/ ctx[4];
    			if (dirty & /*data*/ 32) select_changes.selectedValue = /*data*/ ctx[5]["rule-operator"];
    			if (dirty & /*isReadOnly*/ 8) select_changes.valueReadOnly = /*isReadOnly*/ ctx[3];
    			select.$set(select_changes);
    			const input1_changes = {};
    			if (dirty & /*keyIndex*/ 2) input1_changes.groupIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*data*/ 32) input1_changes.value = /*data*/ ctx[5]["rule-value"];
    			if (dirty & /*isReadOnly*/ 8) input1_changes.valueReadOnly = /*isReadOnly*/ ctx[3];
    			input1.$set(input1_changes);
    			const btnsymbol0_changes = {};
    			if (dirty & /*dataRoleEdit*/ 1) btnsymbol0_changes.dataRole = /*dataRoleEdit*/ ctx[0];
    			btnsymbol0.$set(btnsymbol0_changes);
    			const btnsymbol1_changes = {};
    			if (dirty & /*dataRoleRemove*/ 4) btnsymbol1_changes.dataRole = /*dataRoleRemove*/ ctx[2];
    			if (dirty & /*keyIndex*/ 2) btnsymbol1_changes.dataIndex = /*keyIndex*/ ctx[1];
    			btnsymbol1.$set(btnsymbol1_changes);

    			if (!current || dirty & /*keyIndex*/ 2) {
    				attr_dev(div10, "data-index", /*keyIndex*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input0.$$.fragment, local);
    			transition_in(select.$$.fragment, local);
    			transition_in(input1.$$.fragment, local);
    			transition_in(btnsymbol0.$$.fragment, local);
    			transition_in(btnsymbol1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input0.$$.fragment, local);
    			transition_out(select.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(btnsymbol0.$$.fragment, local);
    			transition_out(btnsymbol1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			destroy_component(input0);
    			destroy_component(select);
    			destroy_component(input1);
    			destroy_component(btnsymbol0);
    			destroy_component(btnsymbol1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("RuleEdit", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let { dataRoleEdit = "" } = $$props;
    	let { keyIndex = "" } = $$props;
    	let { dataRoleRemove = "" } = $$props;
    	let { isReadOnly = "" } = $$props;
    	let { operators = "" } = $$props;
    	let { data = "" } = $$props;

    	const writable_props = [
    		"dataRoleEdit",
    		"keyIndex",
    		"dataRoleRemove",
    		"isReadOnly",
    		"operators",
    		"data"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RuleEdit> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataRoleEdit" in $$props) $$invalidate(0, dataRoleEdit = $$props.dataRoleEdit);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("isReadOnly" in $$props) $$invalidate(3, isReadOnly = $$props.isReadOnly);
    		if ("operators" in $$props) $$invalidate(4, operators = $$props.operators);
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		translations,
    		BtnSymbol,
    		Input,
    		Select,
    		LANG,
    		dataRoleEdit,
    		keyIndex,
    		dataRoleRemove,
    		isReadOnly,
    		operators,
    		data
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataRoleEdit" in $$props) $$invalidate(0, dataRoleEdit = $$props.dataRoleEdit);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("isReadOnly" in $$props) $$invalidate(3, isReadOnly = $$props.isReadOnly);
    		if ("operators" in $$props) $$invalidate(4, operators = $$props.operators);
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dataRoleEdit,
    		keyIndex,
    		dataRoleRemove,
    		isReadOnly,
    		operators,
    		data,
    		LANG,
    		click_handler,
    		click_handler_1
    	];
    }

    class RuleEdit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			dataRoleEdit: 0,
    			keyIndex: 1,
    			dataRoleRemove: 2,
    			isReadOnly: 3,
    			operators: 4,
    			data: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RuleEdit",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get dataRoleEdit() {
    		throw new Error("<RuleEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRoleEdit(value) {
    		throw new Error("<RuleEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keyIndex() {
    		throw new Error("<RuleEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keyIndex(value) {
    		throw new Error("<RuleEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataRoleRemove() {
    		throw new Error("<RuleEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRoleRemove(value) {
    		throw new Error("<RuleEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isReadOnly() {
    		throw new Error("<RuleEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isReadOnly(value) {
    		throw new Error("<RuleEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get operators() {
    		throw new Error("<RuleEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set operators(value) {
    		throw new Error("<RuleEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<RuleEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<RuleEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/EditRulesBlock.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$2 } = globals;
    const file$v = "src/components/EditRulesBlock.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (338:28) {#each Object.keys(parsedRulesData) as ruleItem (ruleItem)}
    function create_each_block$5(key_1, ctx) {
    	let first;
    	let ruleedit;
    	let current;

    	ruleedit = new RuleEdit({
    			props: {
    				keyIndex: /*ruleItem*/ ctx[14],
    				operators: /*operators*/ ctx[5],
    				dataRoleRemove: "remove-elem",
    				dataRoleEdit: "edit-rule",
    				isReadOnly: /*isReadOnly*/ ctx[2],
    				data: /*parsedRulesData*/ ctx[3][/*ruleItem*/ ctx[14]]
    			},
    			$$inline: true
    		});

    	ruleedit.$on("click", /*elemBehaviourHandler*/ ctx[6]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(ruleedit.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(ruleedit, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const ruleedit_changes = {};
    			if (dirty & /*parsedRulesData*/ 8) ruleedit_changes.keyIndex = /*ruleItem*/ ctx[14];
    			if (dirty & /*isReadOnly*/ 4) ruleedit_changes.isReadOnly = /*isReadOnly*/ ctx[2];
    			if (dirty & /*parsedRulesData*/ 8) ruleedit_changes.data = /*parsedRulesData*/ ctx[3][/*ruleItem*/ ctx[14]];
    			ruleedit.$set(ruleedit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ruleedit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ruleedit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(ruleedit, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(338:28) {#each Object.keys(parsedRulesData) as ruleItem (ruleItem)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div7;
    	let div6;
    	let div0;
    	let heading;
    	let t0;
    	let p;
    	let raw_value = translations[/*LANG*/ ctx[4]].editRules.description + "";
    	let t1;
    	let form;
    	let div3;
    	let div2;
    	let div1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t2;
    	let scrollbar;
    	let t3;
    	let div4;
    	let btnstandart;
    	let t4;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[4]]?.editRules?.heading
    			},
    			$$inline: true
    		});

    	let each_value = Object.keys(/*parsedRulesData*/ ctx[3]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*ruleItem*/ ctx[14];
    	validate_each_keys(ctx, each_value, get_each_context$5, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$5(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
    	}

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[4]].editRules.editRules_btn,
    				btnType: "submit",
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "addRulesBlock-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			p = element("p");
    			t1 = space();
    			form = element("form");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			create_component(scrollbar.$$.fragment);
    			t3 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t4 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$v, 322, 8, 8613);
    			attr_dev(p, "class", "mb-15");
    			add_location(p, file$v, 325, 8, 8729);
    			attr_dev(div1, "class", "wrap-rules-blocks");
    			add_location(div1, file$v, 336, 24, 9186);
    			attr_dev(div2, "class", "dynamic-content");
    			add_location(div2, file$v, 335, 20, 9102);
    			attr_dev(div3, "class", "my-scroller svelte-9gdgb6");
    			add_location(div3, file$v, 334, 16, 9028);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$v, 356, 12, 10143);
    			attr_dev(form, "name", "edit-rules");
    			attr_dev(form, "data-role", "editRulesBlock-step");
    			attr_dev(form, "data-step", "selectFieldsPull-step");
    			add_location(form, file$v, 329, 8, 8830);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$v, 364, 8, 10380);
    			add_location(div6, file$v, 321, 4, 8599);
    			attr_dev(div7, "class", "center-block__content rules svelte-9gdgb6");
    			add_location(div7, file$v, 320, 0, 8553);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			mount_component(heading, div0, null);
    			append_dev(div6, t0);
    			append_dev(div6, p);
    			p.innerHTML = raw_value;
    			append_dev(div6, t1);
    			append_dev(div6, form);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			/*div2_binding*/ ctx[9](div2);
    			/*div3_binding*/ ctx[10](div3);
    			append_dev(form, t2);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t3);
    			append_dev(form, div4);
    			mount_component(btnstandart, div4, null);
    			append_dev(div6, t4);
    			append_dev(div6, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[8]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Object, parsedRulesData, operators, isReadOnly, elemBehaviourHandler*/ 108) {
    				each_value = Object.keys(/*parsedRulesData*/ ctx[3]);
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(heading);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*div2_binding*/ ctx[9](null);
    			/*div3_binding*/ ctx[10](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EditRulesBlock", slots, []);
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [RuleEdit];
    	let isReadOnly = "readonly";

    	// Get rules data
    	const rulesData = localStorage.getItem("entered-rule-data");

    	let parsedRulesData = rulesData ? { ...JSON.parse(rulesData) } : {};

    	let operators = [
    		{ id: "0", name: "Equals" },
    		{ id: "1", name: "Plus" },
    		{ id: "2", name: "Minus" }
    	];

    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "edit-rule":
    				$$invalidate(3, parsedRulesData);
    				$$invalidate(2, isReadOnly = "");
    				break;
    			case "remove-elem":
    				delete parsedRulesData[ITEM_INDEX];
    				$$invalidate(3, parsedRulesData);
    				break;
    		}
    	};

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("editRulesBlock-step")) return false;

    		// Update localStorage with users data
    		saveEnteredRuleData("editRulesBlock-step");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EditRulesBlock> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnBack,
    		BtnStandart,
    		Heading,
    		RuleEdit,
    		checkStepFields,
    		saveEnteredRuleData,
    		iChangeMyHeight,
    		iAmScrollArea,
    		dispatch,
    		LANG,
    		itemsCount,
    		isReadOnly,
    		rulesData,
    		parsedRulesData,
    		operators,
    		elemBehaviourHandler,
    		goToBack,
    		goToNextStep
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    		if ("itemsCount" in $$props) itemsCount = $$props.itemsCount;
    		if ("isReadOnly" in $$props) $$invalidate(2, isReadOnly = $$props.isReadOnly);
    		if ("parsedRulesData" in $$props) $$invalidate(3, parsedRulesData = $$props.parsedRulesData);
    		if ("operators" in $$props) $$invalidate(5, operators = $$props.operators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		iChangeMyHeight,
    		iAmScrollArea,
    		isReadOnly,
    		parsedRulesData,
    		LANG,
    		operators,
    		elemBehaviourHandler,
    		goToBack,
    		goToNextStep,
    		div2_binding,
    		div3_binding
    	];
    }

    class EditRulesBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditRulesBlock",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src/components/SelectFieldsPull.svelte generated by Svelte v3.32.1 */
    const file$w = "src/components/SelectFieldsPull.svelte";

    function create_fragment$x(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let heading;
    	let t0;
    	let html_tag;
    	let raw_value = translations[/*LANG*/ ctx[0]].selectFieldsPull.description + "";
    	let t1;
    	let div1;
    	let btnstandart;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.selectFieldsPull?.heading
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "addTags-step",
    				text: translations[/*LANG*/ ctx[0]].selectFieldsPull.selectFieldsPull_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*goToNextStep*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			t1 = space();
    			div1 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$w, 19, 8, 1605);
    			html_tag = new HtmlTag(t1);
    			attr_dev(div1, "class", "mt-30");
    			add_location(div1, file$w, 25, 8, 1802);
    			attr_dev(div2, "class", "center-block__inner");
    			add_location(div2, file$w, 18, 4, 1563);
    			attr_dev(div3, "class", "center-block__content");
    			add_location(div3, file$w, 17, 0, 1523);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(heading, div0, null);
    			append_dev(div2, t0);
    			html_tag.m(raw_value, div2);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(btnstandart, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(heading);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SelectFieldsPull", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SelectFieldsPull> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep
    	});

    	return [LANG, goToNextStep];
    }

    class SelectFieldsPull extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectFieldsPull",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src/components/Tag.svelte generated by Svelte v3.32.1 */
    const file$x = "src/components/Tag.svelte";

    function create_fragment$y(ctx) {
    	let div5;
    	let div0;
    	let t0;
    	let div3;
    	let div1;
    	let input;
    	let t1;
    	let div2;
    	let select;
    	let t2;
    	let div4;
    	let btnsymbol0;
    	let t3;
    	let btnsymbol1;
    	let div5_class_value;
    	let current;

    	input = new Input({
    			props: {
    				wrapperClass: "input-text",
    				label: translations[/*LANG*/ ctx[4]]?.addTags?.select_1,
    				name: "tag-name[]",
    				dataInputRole: "anyText",
    				groupIndex: /*keyIndex*/ ctx[1],
    				search: "search",
    				readOnly: /*readOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	select = new Select({
    			props: {
    				dataInputRole: "name",
    				label: translations[/*LANG*/ ctx[4]]?.addTags?.select_2,
    				name: "tags-values[]",
    				id: "tags-values",
    				optionObject: /*values*/ ctx[5],
    				groupIndex: /*keyIndex*/ ctx[1]
    			},
    			$$inline: true
    		});

    	btnsymbol0 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "add",
    				addClass: "mr-10",
    				dataRole: /*dataRolePlus*/ ctx[0]
    			},
    			$$inline: true
    		});

    	btnsymbol0.$on("click", /*click_handler*/ ctx[6]);

    	btnsymbol1 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "del",
    				dataRole: /*dataRoleRemove*/ ctx[2],
    				addClass: "mr-10",
    				dataIndex: /*keyIndex*/ ctx[1]
    			},
    			$$inline: true
    		});

    	btnsymbol1.$on("click", /*click_handler_1*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			create_component(input.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(select.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			create_component(btnsymbol0.$$.fragment);
    			t3 = space();
    			create_component(btnsymbol1.$$.fragment);
    			attr_dev(div0, "class", "add-tags__controls mod svelte-x7loit");
    			add_location(div0, file$x, 409, 4, 21991);
    			attr_dev(div1, "class", "add-tags__item svelte-x7loit");
    			add_location(div1, file$x, 413, 8, 22081);
    			attr_dev(div2, "class", "add-tags__item svelte-x7loit");
    			add_location(div2, file$x, 423, 8, 22444);
    			attr_dev(div3, "class", "add-tags__form svelte-x7loit");
    			add_location(div3, file$x, 412, 4, 22044);
    			attr_dev(div4, "class", "add-tags__controls svelte-x7loit");
    			add_location(div4, file$x, 434, 4, 22807);
    			attr_dev(div5, "class", div5_class_value = "add-tags__block data-index=" + /*keyIndex*/ ctx[1] + " svelte-x7loit");
    			add_location(div5, file$x, 408, 0, 21935);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t0);
    			append_dev(div5, div3);
    			append_dev(div3, div1);
    			mount_component(input, div1, null);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			mount_component(select, div2, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			mount_component(btnsymbol0, div4, null);
    			append_dev(div4, t3);
    			mount_component(btnsymbol1, div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const input_changes = {};
    			if (dirty & /*keyIndex*/ 2) input_changes.groupIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*readOnly*/ 8) input_changes.readOnly = /*readOnly*/ ctx[3];
    			input.$set(input_changes);
    			const select_changes = {};
    			if (dirty & /*keyIndex*/ 2) select_changes.groupIndex = /*keyIndex*/ ctx[1];
    			select.$set(select_changes);
    			const btnsymbol0_changes = {};
    			if (dirty & /*dataRolePlus*/ 1) btnsymbol0_changes.dataRole = /*dataRolePlus*/ ctx[0];
    			btnsymbol0.$set(btnsymbol0_changes);
    			const btnsymbol1_changes = {};
    			if (dirty & /*dataRoleRemove*/ 4) btnsymbol1_changes.dataRole = /*dataRoleRemove*/ ctx[2];
    			if (dirty & /*keyIndex*/ 2) btnsymbol1_changes.dataIndex = /*keyIndex*/ ctx[1];
    			btnsymbol1.$set(btnsymbol1_changes);

    			if (!current || dirty & /*keyIndex*/ 2 && div5_class_value !== (div5_class_value = "add-tags__block data-index=" + /*keyIndex*/ ctx[1] + " svelte-x7loit")) {
    				attr_dev(div5, "class", div5_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(select.$$.fragment, local);
    			transition_in(btnsymbol0.$$.fragment, local);
    			transition_in(btnsymbol1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(select.$$.fragment, local);
    			transition_out(btnsymbol0.$$.fragment, local);
    			transition_out(btnsymbol1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(input);
    			destroy_component(select);
    			destroy_component(btnsymbol0);
    			destroy_component(btnsymbol1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tag", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let { dataRolePlus = "" } = $$props;
    	let { keyIndex = "" } = $$props;
    	let { dataRoleRemove = "" } = $$props;
    	let { readOnly = "" } = $$props;

    	let values = [
    		{ id: "0", name: "Target an audience" },
    		{ id: "1", name: "Target an audience 2" },
    		{ id: "2", name: "Target an audience 3" }
    	];

    	const writable_props = ["dataRolePlus", "keyIndex", "dataRoleRemove", "readOnly"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tag> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataRolePlus" in $$props) $$invalidate(0, dataRolePlus = $$props.dataRolePlus);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("readOnly" in $$props) $$invalidate(3, readOnly = $$props.readOnly);
    	};

    	$$self.$capture_state = () => ({
    		translations,
    		BtnSymbol,
    		Input,
    		Select,
    		LANG,
    		dataRolePlus,
    		keyIndex,
    		dataRoleRemove,
    		readOnly,
    		values
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataRolePlus" in $$props) $$invalidate(0, dataRolePlus = $$props.dataRolePlus);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("readOnly" in $$props) $$invalidate(3, readOnly = $$props.readOnly);
    		if ("values" in $$props) $$invalidate(5, values = $$props.values);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dataRolePlus,
    		keyIndex,
    		dataRoleRemove,
    		readOnly,
    		LANG,
    		values,
    		click_handler,
    		click_handler_1
    	];
    }

    class Tag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			dataRolePlus: 0,
    			keyIndex: 1,
    			dataRoleRemove: 2,
    			readOnly: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tag",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get dataRolePlus() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRolePlus(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keyIndex() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keyIndex(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataRoleRemove() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRoleRemove(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readOnly() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readOnly(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/AddTagsBlock.svelte generated by Svelte v3.32.1 */
    const file$y = "src/components/AddTagsBlock.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (258:20) {#if itemsCount}
    function create_if_block$a(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*itemsCount*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*itemsCount, elemBehaviourHandler*/ 65) {
    				each_value = /*itemsCount*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(258:20) {#if itemsCount}",
    		ctx
    	});

    	return block;
    }

    // (259:24) {#each itemsCount as component , index}
    function create_each_block$6(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[10];

    	function switch_props(ctx) {
    		return {
    			props: {
    				keyIndex: /*index*/ ctx[12],
    				dataRoleRemove: "remove-elem",
    				dataRolePlus: "create-new-elem"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*component*/ ctx[10])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(259:24) {#each itemsCount as component , index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div6;
    	let form;
    	let div0;
    	let heading;
    	let t0;
    	let div3;
    	let div2;
    	let div1;
    	let t1;
    	let scrollbar;
    	let t2;
    	let div4;
    	let btnstandart;
    	let t3;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[3]]?.addTags?.heading
    			},
    			$$inline: true
    		});

    	let if_block = /*itemsCount*/ ctx[0] && create_if_block$a(ctx);

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[1],
    				scrollArea: /*iAmScrollArea*/ ctx[2],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "editTags-step",
    				text: translations[/*LANG*/ ctx[3]].addTags.addTags_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*goToNextStep*/ ctx[5]);

    	btnback = new BtnBack({
    			props: { dataStep: "selectFieldsPull-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			form = element("form");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(scrollbar.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t3 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$y, 251, 8, 6615);
    			attr_dev(div1, "class", "hr-top hr-bottom");
    			add_location(div1, file$y, 256, 16, 6871);
    			attr_dev(div2, "class", "dynamic-content");
    			add_location(div2, file$y, 255, 12, 6795);
    			attr_dev(div3, "class", "my-scroller svelte-15u8ma4");
    			add_location(div3, file$y, 254, 8, 6729);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$y, 276, 8, 7693);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$y, 283, 8, 7950);
    			attr_dev(form, "data-role", "addTagsBlock");
    			attr_dev(form, "data-step", "editTags-step");
    			add_location(form, file$y, 247, 4, 6484);
    			attr_dev(div6, "class", "center-block__content add-tags svelte-15u8ma4");
    			add_location(div6, file$y, 246, 0, 6435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, form);
    			append_dev(form, div0);
    			mount_component(heading, div0, null);
    			append_dev(form, t0);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			/*div2_binding*/ ctx[7](div2);
    			/*div3_binding*/ ctx[8](div3);
    			append_dev(form, t1);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t2);
    			append_dev(form, div4);
    			mount_component(btnstandart, div4, null);
    			append_dev(form, t3);
    			append_dev(form, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[5]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*itemsCount*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*itemsCount*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 2) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[1];
    			if (dirty & /*iAmScrollArea*/ 4) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[2];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(heading);
    			if (if_block) if_block.d();
    			/*div2_binding*/ ctx[7](null);
    			/*div3_binding*/ ctx[8](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AddTagsBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [Tag];

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("addTagsBlock")) return false;

    		// Update localStorage with users data
    		saveEnteredTagData("addTagsBlock");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;

    	/**
     *
     * @param event
     */
    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "create-new-elem":
    				$$invalidate(0, itemsCount = [...itemsCount, Tag]);
    				break;
    			case "remove-elem":
    				delete itemsCount[ITEM_INDEX];
    				$$invalidate(0, itemsCount);
    				break;
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AddTagsBlock> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(1, iChangeMyHeight);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(2, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		saveEnteredTagData,
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnBack,
    		BtnStandart,
    		Heading,
    		Tag,
    		dispatch,
    		LANG,
    		itemsCount,
    		goToBack,
    		goToNextStep,
    		iChangeMyHeight,
    		iAmScrollArea,
    		elemBehaviourHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("itemsCount" in $$props) $$invalidate(0, itemsCount = $$props.itemsCount);
    		if ("iChangeMyHeight" in $$props) $$invalidate(1, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(2, iAmScrollArea = $$props.iAmScrollArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		itemsCount,
    		iChangeMyHeight,
    		iAmScrollArea,
    		LANG,
    		goToBack,
    		goToNextStep,
    		elemBehaviourHandler,
    		div2_binding,
    		div3_binding
    	];
    }

    class AddTagsBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddTagsBlock",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* src/components/TagEdit.svelte generated by Svelte v3.32.1 */
    const file$z = "src/components/TagEdit.svelte";

    function create_fragment$A(ctx) {
    	let div5;
    	let div0;
    	let t0;
    	let div3;
    	let div1;
    	let input;
    	let t1;
    	let div2;
    	let select;
    	let t2;
    	let div4;
    	let btnsymbol0;
    	let t3;
    	let btnsymbol1;
    	let current;

    	input = new Input({
    			props: {
    				wrapperClass: "",
    				dataInputRole: "anyText",
    				label: translations[/*LANG*/ ctx[6]]?.editTags?.title_1,
    				name: "tag-name[]",
    				groupIndex: /*keyIndex*/ ctx[1],
    				value: /*data*/ ctx[5]["tag-name"],
    				valueReadOnly: /*isReadOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	select = new Select({
    			props: {
    				wrapperClass: "",
    				dataInputRole: "anyText",
    				label: translations[/*LANG*/ ctx[6]]?.editTags?.title_2,
    				name: "tags-values[]",
    				groupIndex: /*keyIndex*/ ctx[1],
    				optionObject: /*values*/ ctx[4],
    				selectedValue: /*data*/ ctx[5]["tags-values"],
    				valueReadOnly: /*isReadOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	btnsymbol0 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "edit",
    				addClass: "mr-10",
    				dataRole: /*dataRoleEdit*/ ctx[0]
    			},
    			$$inline: true
    		});

    	btnsymbol0.$on("click", /*click_handler*/ ctx[7]);

    	btnsymbol1 = new BtnSymbol({
    			props: {
    				size: "small",
    				symbol: "del",
    				dataRole: /*dataRoleRemove*/ ctx[2],
    				addClass: "mr-10",
    				dataIndex: /*keyIndex*/ ctx[1]
    			},
    			$$inline: true
    		});

    	btnsymbol1.$on("click", /*click_handler_1*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			create_component(input.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(select.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			create_component(btnsymbol0.$$.fragment);
    			t3 = space();
    			create_component(btnsymbol1.$$.fragment);
    			attr_dev(div0, "class", "tags-edit__control svelte-agjaib");
    			add_location(div0, file$z, 483, 4, 24587);
    			attr_dev(div1, "class", "tags-group__item svelte-agjaib");
    			add_location(div1, file$z, 487, 8, 24685);
    			attr_dev(div2, "class", "tags-group__item svelte-agjaib");
    			add_location(div2, file$z, 497, 8, 25065);
    			attr_dev(div3, "class", "tags-edit__elem tags-group svelte-agjaib");
    			add_location(div3, file$z, 486, 4, 24636);
    			attr_dev(div4, "class", "tags-edit__control svelte-agjaib");
    			add_location(div4, file$z, 510, 4, 25535);
    			attr_dev(div5, "class", "tags-edit__block svelte-agjaib");
    			attr_dev(div5, "data-index", /*keyIndex*/ ctx[1]);
    			add_location(div5, file$z, 482, 0, 24530);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t0);
    			append_dev(div5, div3);
    			append_dev(div3, div1);
    			mount_component(input, div1, null);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			mount_component(select, div2, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			mount_component(btnsymbol0, div4, null);
    			append_dev(div4, t3);
    			mount_component(btnsymbol1, div4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const input_changes = {};
    			if (dirty & /*keyIndex*/ 2) input_changes.groupIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*data*/ 32) input_changes.value = /*data*/ ctx[5]["tag-name"];
    			if (dirty & /*isReadOnly*/ 8) input_changes.valueReadOnly = /*isReadOnly*/ ctx[3];
    			input.$set(input_changes);
    			const select_changes = {};
    			if (dirty & /*keyIndex*/ 2) select_changes.groupIndex = /*keyIndex*/ ctx[1];
    			if (dirty & /*values*/ 16) select_changes.optionObject = /*values*/ ctx[4];
    			if (dirty & /*data*/ 32) select_changes.selectedValue = /*data*/ ctx[5]["tags-values"];
    			if (dirty & /*isReadOnly*/ 8) select_changes.valueReadOnly = /*isReadOnly*/ ctx[3];
    			select.$set(select_changes);
    			const btnsymbol0_changes = {};
    			if (dirty & /*dataRoleEdit*/ 1) btnsymbol0_changes.dataRole = /*dataRoleEdit*/ ctx[0];
    			btnsymbol0.$set(btnsymbol0_changes);
    			const btnsymbol1_changes = {};
    			if (dirty & /*dataRoleRemove*/ 4) btnsymbol1_changes.dataRole = /*dataRoleRemove*/ ctx[2];
    			if (dirty & /*keyIndex*/ 2) btnsymbol1_changes.dataIndex = /*keyIndex*/ ctx[1];
    			btnsymbol1.$set(btnsymbol1_changes);

    			if (!current || dirty & /*keyIndex*/ 2) {
    				attr_dev(div5, "data-index", /*keyIndex*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(select.$$.fragment, local);
    			transition_in(btnsymbol0.$$.fragment, local);
    			transition_in(btnsymbol1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(select.$$.fragment, local);
    			transition_out(btnsymbol0.$$.fragment, local);
    			transition_out(btnsymbol1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(input);
    			destroy_component(select);
    			destroy_component(btnsymbol0);
    			destroy_component(btnsymbol1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TagEdit", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let { dataRoleEdit = "" } = $$props;
    	let { keyIndex = "" } = $$props;
    	let { dataRoleRemove = "" } = $$props;
    	let { isReadOnly = "" } = $$props;
    	let { values = "" } = $$props;
    	let { data = "" } = $$props;
    	const writable_props = ["dataRoleEdit", "keyIndex", "dataRoleRemove", "isReadOnly", "values", "data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TagEdit> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataRoleEdit" in $$props) $$invalidate(0, dataRoleEdit = $$props.dataRoleEdit);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("isReadOnly" in $$props) $$invalidate(3, isReadOnly = $$props.isReadOnly);
    		if ("values" in $$props) $$invalidate(4, values = $$props.values);
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		translations,
    		BtnSymbol,
    		Input,
    		Select,
    		LANG,
    		dataRoleEdit,
    		keyIndex,
    		dataRoleRemove,
    		isReadOnly,
    		values,
    		data
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataRoleEdit" in $$props) $$invalidate(0, dataRoleEdit = $$props.dataRoleEdit);
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(2, dataRoleRemove = $$props.dataRoleRemove);
    		if ("isReadOnly" in $$props) $$invalidate(3, isReadOnly = $$props.isReadOnly);
    		if ("values" in $$props) $$invalidate(4, values = $$props.values);
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dataRoleEdit,
    		keyIndex,
    		dataRoleRemove,
    		isReadOnly,
    		values,
    		data,
    		LANG,
    		click_handler,
    		click_handler_1
    	];
    }

    class TagEdit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
    			dataRoleEdit: 0,
    			keyIndex: 1,
    			dataRoleRemove: 2,
    			isReadOnly: 3,
    			values: 4,
    			data: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagEdit",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get dataRoleEdit() {
    		throw new Error("<TagEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRoleEdit(value) {
    		throw new Error("<TagEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keyIndex() {
    		throw new Error("<TagEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keyIndex(value) {
    		throw new Error("<TagEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataRoleRemove() {
    		throw new Error("<TagEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRoleRemove(value) {
    		throw new Error("<TagEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isReadOnly() {
    		throw new Error("<TagEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isReadOnly(value) {
    		throw new Error("<TagEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get values() {
    		throw new Error("<TagEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set values(value) {
    		throw new Error("<TagEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<TagEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<TagEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/EditTagsBlock.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$3 } = globals;
    const file$A = "src/components/EditTagsBlock.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (346:20) {#if parsedTagsData}
    function create_if_block$b(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = Object.keys(/*parsedTagsData*/ ctx[3]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*tagItem*/ ctx[14];
    	validate_each_keys(ctx, each_value, get_each_context$7, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$7(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, parsedTagsData, values, isReadOnly, elemBehaviourHandler*/ 108) {
    				each_value = Object.keys(/*parsedTagsData*/ ctx[3]);
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$7, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$7, each_1_anchor, get_each_context$7);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(346:20) {#if parsedTagsData}",
    		ctx
    	});

    	return block;
    }

    // (347:24) {#each Object.keys(parsedTagsData) as tagItem (tagItem)}
    function create_each_block$7(key_1, ctx) {
    	let first;
    	let tagedit;
    	let current;

    	tagedit = new TagEdit({
    			props: {
    				keyIndex: /*tagItem*/ ctx[14],
    				values: /*values*/ ctx[5],
    				dataRoleRemove: "remove-elem",
    				dataRoleEdit: "edit-elem",
    				isReadOnly: /*isReadOnly*/ ctx[2],
    				data: /*parsedTagsData*/ ctx[3][/*tagItem*/ ctx[14]]
    			},
    			$$inline: true
    		});

    	tagedit.$on("click", /*elemBehaviourHandler*/ ctx[6]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(tagedit.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(tagedit, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const tagedit_changes = {};
    			if (dirty & /*parsedTagsData*/ 8) tagedit_changes.keyIndex = /*tagItem*/ ctx[14];
    			if (dirty & /*isReadOnly*/ 4) tagedit_changes.isReadOnly = /*isReadOnly*/ ctx[2];
    			if (dirty & /*parsedTagsData*/ 8) tagedit_changes.data = /*parsedTagsData*/ ctx[3][/*tagItem*/ ctx[14]];
    			tagedit.$set(tagedit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagedit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagedit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(tagedit, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(347:24) {#each Object.keys(parsedTagsData) as tagItem (tagItem)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div6;
    	let div0;
    	let heading;
    	let t0;
    	let form;
    	let div3;
    	let div2;
    	let div1;
    	let t1;
    	let scrollbar;
    	let t2;
    	let div4;
    	let btnstandart;
    	let t3;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[4]]?.editTags?.heading
    			},
    			$$inline: true
    		});

    	let if_block = /*parsedTagsData*/ ctx[3] && create_if_block$b(ctx);

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[4]].editTags.editTags_btn,
    				btnType: "submit",
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "addTags-step" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			form = element("form");
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(scrollbar.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t3 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$A, 334, 4, 9373);
    			attr_dev(div1, "class", "wrap-edit-blocks");
    			add_location(div1, file$A, 344, 16, 9779);
    			attr_dev(div2, "class", "dynamic-content");
    			add_location(div2, file$A, 343, 12, 9703);
    			attr_dev(div3, "class", "my-scroller svelte-11s7k7g");
    			add_location(div3, file$A, 342, 8, 9637);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$A, 367, 8, 10700);
    			attr_dev(form, "name", "edit-rules");
    			attr_dev(form, "data-role", "editTagsBlock-step");
    			attr_dev(form, "data-step", "addAdmin-step");
    			add_location(form, file$A, 337, 4, 9476);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$A, 374, 4, 10910);
    			attr_dev(div6, "class", "center-block__content edit-tags svelte-11s7k7g");
    			add_location(div6, file$A, 332, 0, 9322);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			mount_component(heading, div0, null);
    			append_dev(div6, t0);
    			append_dev(div6, form);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			/*div2_binding*/ ctx[9](div2);
    			/*div3_binding*/ ctx[10](div3);
    			append_dev(form, t1);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t2);
    			append_dev(form, div4);
    			mount_component(btnstandart, div4, null);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[8]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*parsedTagsData*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*parsedTagsData*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(heading);
    			if (if_block) if_block.d();
    			/*div2_binding*/ ctx[9](null);
    			/*div3_binding*/ ctx[10](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EditTagsBlock", slots, []);
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [TagEdit];
    	let isReadOnly = "readonly";

    	// Get rules data
    	const tagsData = localStorage.getItem("entered-tag-data");

    	let parsedTagsData = tagsData ? { ...JSON.parse(tagsData) } : {};

    	let values = [
    		{ id: "0", name: "Target an audience" },
    		{ id: "1", name: "Target an audience 2" },
    		{ id: "2", name: "Target an audience 3" }
    	];

    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "edit-elem":
    				$$invalidate(3, parsedTagsData);
    				$$invalidate(2, isReadOnly = "");
    				break;
    			case "remove-elem":
    				delete parsedTagsData[ITEM_INDEX];
    				$$invalidate(3, parsedTagsData);
    				break;
    		}
    	};

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("editTagsBlock-step")) return false;

    		// Update localStorage with users data
    		saveEnteredTagData("editTagsBlock-step");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EditTagsBlock> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnBack,
    		BtnStandart,
    		Heading,
    		TagEdit,
    		checkStepFields,
    		saveEnteredTagData,
    		iChangeMyHeight,
    		iAmScrollArea,
    		dispatch,
    		LANG,
    		itemsCount,
    		isReadOnly,
    		tagsData,
    		parsedTagsData,
    		values,
    		elemBehaviourHandler,
    		goToBack,
    		goToNextStep
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    		if ("itemsCount" in $$props) itemsCount = $$props.itemsCount;
    		if ("isReadOnly" in $$props) $$invalidate(2, isReadOnly = $$props.isReadOnly);
    		if ("parsedTagsData" in $$props) $$invalidate(3, parsedTagsData = $$props.parsedTagsData);
    		if ("values" in $$props) $$invalidate(5, values = $$props.values);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		iChangeMyHeight,
    		iAmScrollArea,
    		isReadOnly,
    		parsedTagsData,
    		LANG,
    		values,
    		elemBehaviourHandler,
    		goToBack,
    		goToNextStep,
    		div2_binding,
    		div3_binding
    	];
    }

    class EditTagsBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditTagsBlock",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src/components/AddAdminBlock.svelte generated by Svelte v3.32.1 */
    const file$B = "src/components/AddAdminBlock.svelte";

    function create_fragment$C(ctx) {
    	let div4;
    	let div3;
    	let div0;
    	let heading;
    	let t0;
    	let div1;
    	let raw_value = translations[/*LANG*/ ctx[0]]?.addAdmin?.description + "";
    	let t1;
    	let div2;
    	let btnstandart0;
    	let t2;
    	let btnstandart1;
    	let current;

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[0]]?.addAdmin?.heading
    			},
    			$$inline: true
    		});

    	btnstandart0 = new BtnStandart({
    			props: {
    				dataStep: "StepsAdminWindow",
    				text: translations[/*LANG*/ ctx[0]]?.addAdmin?.addAdmin_btn_1,
    				color: "purple",
    				className: "m-5"
    			},
    			$$inline: true
    		});

    	btnstandart0.$on("click", /*goToNextStep*/ ctx[1]);

    	btnstandart1 = new BtnStandart({
    			props: {
    				dataStep: "StepsAdminWindow",
    				text: translations[/*LANG*/ ctx[0]]?.addAdmin?.addAdmin_btn_2,
    				color: "orange",
    				className: "m-5"
    			},
    			$$inline: true
    		});

    	btnstandart1.$on("click", /*goToNextStep*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			create_component(btnstandart0.$$.fragment);
    			t2 = space();
    			create_component(btnstandart1.$$.fragment);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$B, 173, 8, 4536);
    			add_location(div1, file$B, 177, 8, 4652);
    			attr_dev(div2, "class", "admin-buttons");
    			add_location(div2, file$B, 179, 8, 4722);
    			attr_dev(div3, "class", "center-block__inner");
    			add_location(div3, file$B, 172, 4, 4494);
    			attr_dev(div4, "class", "center-block__content");
    			add_location(div4, file$B, 170, 0, 4453);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			mount_component(heading, div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			div1.innerHTML = raw_value;
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			mount_component(btnstandart0, div2, null);
    			append_dev(div2, t2);
    			mount_component(btnstandart1, div2, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heading.$$.fragment, local);
    			transition_in(btnstandart0.$$.fragment, local);
    			transition_in(btnstandart1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heading.$$.fragment, local);
    			transition_out(btnstandart0.$$.fragment, local);
    			transition_out(btnstandart1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(heading);
    			destroy_component(btnstandart0);
    			destroy_component(btnstandart1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AddAdminBlock", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const goToNextStep = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AddAdminBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		Heading,
    		dispatch,
    		LANG,
    		goToNextStep
    	});

    	return [LANG, goToNextStep];
    }

    class AddAdminBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddAdminBlock",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* src/components/admin/HeaderMessage.svelte generated by Svelte v3.32.1 */
    const file$C = "src/components/admin/HeaderMessage.svelte";

    function create_fragment$D(ctx) {
    	let div;
    	let i;
    	let i_class_value;
    	let t0;
    	let p;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			i = element("i");
    			t0 = space();
    			p = element("p");
    			t1 = text(/*textMessage*/ ctx[1]);
    			attr_dev(i, "class", i_class_value = "header-message__icon icon-" + /*iconType*/ ctx[0] + " svelte-1h2g2jc");
    			add_location(i, file$C, 196, 4, 7540);
    			attr_dev(p, "class", "header-message__text svelte-1h2g2jc");
    			add_location(p, file$C, 197, 4, 7597);
    			attr_dev(div, "class", "header-message__item svelte-1h2g2jc");
    			add_location(div, file$C, 195, 0, 7501);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, i);
    			append_dev(div, t0);
    			append_dev(div, p);
    			append_dev(p, t1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*iconType*/ 1 && i_class_value !== (i_class_value = "header-message__icon icon-" + /*iconType*/ ctx[0] + " svelte-1h2g2jc")) {
    				attr_dev(i, "class", i_class_value);
    			}

    			if (dirty & /*textMessage*/ 2) set_data_dev(t1, /*textMessage*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HeaderMessage", slots, []);
    	const dispatch = createEventDispatcher();
    	let { iconType = "" } = $$props;
    	let { textMessage = "" } = $$props;
    	const writable_props = ["iconType", "textMessage"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderMessage> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("iconType" in $$props) $$invalidate(0, iconType = $$props.iconType);
    		if ("textMessage" in $$props) $$invalidate(1, textMessage = $$props.textMessage);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		iconType,
    		textMessage
    	});

    	$$self.$inject_state = $$props => {
    		if ("iconType" in $$props) $$invalidate(0, iconType = $$props.iconType);
    		if ("textMessage" in $$props) $$invalidate(1, textMessage = $$props.textMessage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [iconType, textMessage];
    }

    class HeaderMessage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { iconType: 0, textMessage: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderMessage",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get iconType() {
    		throw new Error("<HeaderMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconType(value) {
    		throw new Error("<HeaderMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textMessage() {
    		throw new Error("<HeaderMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textMessage(value) {
    		throw new Error("<HeaderMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/MainHeader.svelte generated by Svelte v3.32.1 */
    const file$D = "src/components/MainHeader.svelte";

    // (324:12) {#if headerMessage.haveMessage}
    function create_if_block$c(ctx) {
    	let div;
    	let headermessage0;
    	let t;
    	let headermessage1;
    	let current;

    	headermessage0 = new HeaderMessage({
    			props: {
    				iconType: "alert",
    				textMessage: "Adipiscing at in tellus integer feugiat varius morbi. Neque vitae tempus quam aliquam."
    			},
    			$$inline: true
    		});

    	headermessage1 = new HeaderMessage({
    			props: {
    				iconType: "message",
    				textMessage: "Adipiscing at in tellus integer feugiat varius morbi. Neque vitae tempus quam aliquam."
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(headermessage0.$$.fragment);
    			t = space();
    			create_component(headermessage1.$$.fragment);
    			attr_dev(div, "class", "header-message svelte-g4wy6s");
    			add_location(div, file$D, 324, 16, 16197);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(headermessage0, div, null);
    			append_dev(div, t);
    			mount_component(headermessage1, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headermessage0.$$.fragment, local);
    			transition_in(headermessage1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headermessage0.$$.fragment, local);
    			transition_out(headermessage1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(headermessage0);
    			destroy_component(headermessage1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(324:12) {#if headerMessage.haveMessage}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let div10;
    	let div2;
    	let div0;
    	let button0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let button1;
    	let i0;
    	let t1;
    	let div9;
    	let div3;
    	let button2;
    	let i1;
    	let t2;
    	let span0;
    	let t4;
    	let t5;
    	let div8;
    	let div6;
    	let div4;
    	let span1;
    	let t7;
    	let div5;
    	let t9;
    	let div7;
    	let button3;
    	let i2;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*headerMessage*/ ctx[0].haveMessage && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			button1 = element("button");
    			i0 = element("i");
    			t1 = space();
    			div9 = element("div");
    			div3 = element("div");
    			button2 = element("button");
    			i1 = element("i");
    			t2 = space();
    			span0 = element("span");
    			span0.textContent = "1";
    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();
    			div8 = element("div");
    			div6 = element("div");
    			div4 = element("div");
    			span1 = element("span");
    			span1.textContent = "SJ";
    			t7 = space();
    			div5 = element("div");
    			div5.textContent = "John Doe";
    			t9 = space();
    			div7 = element("div");
    			button3 = element("button");
    			i2 = element("i");
    			if (img.src !== (img_src_value = "images/main-logo.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "header__logo svelte-g4wy6s");
    			add_location(img, file$D, 307, 16, 15555);
    			attr_dev(button0, "class", "header__logo-link svelte-g4wy6s");
    			attr_dev(button0, "data-step", "analytics-window");
    			add_location(button0, file$D, 303, 12, 15380);
    			add_location(div0, file$D, 302, 8, 15362);
    			attr_dev(i0, "class", "settings-icon svelte-g4wy6s");
    			add_location(i0, file$D, 313, 16, 15828);
    			attr_dev(button1, "data-step", "analytics-window");
    			attr_dev(button1, "class", "svelte-g4wy6s");
    			add_location(button1, file$D, 311, 12, 15719);
    			attr_dev(div1, "class", "d-flex align-items-center");
    			add_location(div1, file$D, 310, 8, 15667);
    			attr_dev(div2, "class", "header__left svelte-g4wy6s");
    			add_location(div2, file$D, 301, 4, 15327);
    			attr_dev(i1, "class", "icon-notification svelte-g4wy6s");
    			add_location(i1, file$D, 320, 16, 16021);
    			attr_dev(span0, "class", "notif__message-count svelte-g4wy6s");
    			add_location(span0, file$D, 321, 16, 16071);
    			attr_dev(button2, "class", "svelte-g4wy6s");
    			add_location(button2, file$D, 319, 12, 15978);
    			attr_dev(div3, "class", "notif svelte-g4wy6s");
    			add_location(div3, file$D, 318, 8, 15946);
    			add_location(span1, file$D, 340, 20, 16902);
    			attr_dev(div4, "class", "user-block__avatar svelte-g4wy6s");
    			add_location(div4, file$D, 339, 16, 16849);
    			attr_dev(div5, "class", "user-block__name svelte-g4wy6s");
    			add_location(div5, file$D, 343, 16, 17063);
    			attr_dev(div6, "class", "d-flex align-items-center");
    			attr_dev(div6, "data-role", "open-profile");
    			add_location(div6, file$D, 335, 12, 16712);
    			attr_dev(i2, "class", "logout-icon svelte-g4wy6s");
    			add_location(i2, file$D, 350, 20, 17263);
    			attr_dev(button3, "class", "svelte-g4wy6s");
    			add_location(button3, file$D, 349, 16, 17234);
    			attr_dev(div7, "class", "d-flex align-items-center");
    			add_location(div7, file$D, 348, 12, 17178);
    			attr_dev(div8, "class", "user-block svelte-g4wy6s");
    			add_location(div8, file$D, 334, 8, 16675);
    			attr_dev(div9, "class", "header__right svelte-g4wy6s");
    			add_location(div9, file$D, 317, 4, 15910);
    			attr_dev(div10, "class", "header svelte-g4wy6s");
    			add_location(div10, file$D, 300, 0, 15302);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div2);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			append_dev(button0, img);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, button1);
    			append_dev(button1, i0);
    			append_dev(div10, t1);
    			append_dev(div10, div9);
    			append_dev(div9, div3);
    			append_dev(div3, button2);
    			append_dev(button2, i1);
    			append_dev(button2, t2);
    			append_dev(button2, span0);
    			append_dev(div3, t4);
    			if (if_block) if_block.m(div3, null);
    			append_dev(div9, t5);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			append_dev(div6, div4);
    			append_dev(div4, span1);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			append_dev(div8, t9);
    			append_dev(div8, div7);
    			append_dev(div7, button3);
    			append_dev(button3, i2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", prevent_default(/*goToHome*/ ctx[1]), false, true, false),
    					listen_dev(button1, "click", prevent_default(/*goToHome*/ ctx[1]), false, true, false),
    					listen_dev(button2, "click", /*toggle*/ ctx[2], false, false, false),
    					listen_dev(div6, "click", /*click_handler*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*headerMessage*/ ctx[0].haveMessage) {
    				if (if_block) {
    					if (dirty & /*headerMessage*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div3, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MainHeader", slots, []);
    	const dispatch = createEventDispatcher();

    	const goToHome = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let avatarStatus = false;

    	function onAvatar() {
    		avatarStatus = !avatarStatus;
    		dispatch("status", { text: avatarStatus });
    	}

    	let headerMessage = { haveMessage: false };

    	function toggle() {
    		$$invalidate(0, headerMessage.haveMessage = !headerMessage.haveMessage, headerMessage);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MainHeader> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		HeaderMessage,
    		dispatch,
    		goToHome,
    		avatarStatus,
    		onAvatar,
    		headerMessage,
    		toggle
    	});

    	$$self.$inject_state = $$props => {
    		if ("avatarStatus" in $$props) avatarStatus = $$props.avatarStatus;
    		if ("headerMessage" in $$props) $$invalidate(0, headerMessage = $$props.headerMessage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [headerMessage, goToHome, toggle, click_handler];
    }

    class MainHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MainHeader",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/components/admin/AnalyticsColorBlock.svelte generated by Svelte v3.32.1 */

    const file$E = "src/components/admin/AnalyticsColorBlock.svelte";

    // (229:8) {#if header}
    function create_if_block_2$1(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*header*/ ctx[1]);
    			attr_dev(div, "class", "analytics-block__header svelte-bj14yj");
    			add_location(div, file$E, 229, 12, 4840);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*header*/ 2) set_data_dev(t, /*header*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(229:8) {#if header}",
    		ctx
    	});

    	return block;
    }

    // (234:8) {#if description}
    function create_if_block_1$8(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*description*/ ctx[2]);
    			attr_dev(div, "class", "analytics-block__description svelte-bj14yj");
    			add_location(div, file$E, 234, 12, 4974);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*description*/ 4) set_data_dev(t, /*description*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(234:8) {#if description}",
    		ctx
    	});

    	return block;
    }

    // (239:8) {#if count}
    function create_if_block$d(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*count*/ ctx[3]);
    			attr_dev(div, "class", "analytics-block__count svelte-bj14yj");
    			add_location(div, file$E, 239, 12, 5112);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*count*/ 8) set_data_dev(t, /*count*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(239:8) {#if count}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div1_class_value;
    	let if_block0 = /*header*/ ctx[1] && create_if_block_2$1(ctx);
    	let if_block1 = /*description*/ ctx[2] && create_if_block_1$8(ctx);
    	let if_block2 = /*count*/ ctx[3] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			add_location(div0, file$E, 227, 4, 4801);
    			attr_dev(div1, "class", div1_class_value = "analytics-block__item analytics-block-" + /*type*/ ctx[0] + " svelte-bj14yj");
    			add_location(div1, file$E, 226, 0, 4738);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t1);
    			if (if_block2) if_block2.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*header*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*description*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$8(ctx);
    					if_block1.c();
    					if_block1.m(div0, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*count*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$d(ctx);
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*type*/ 1 && div1_class_value !== (div1_class_value = "analytics-block__item analytics-block-" + /*type*/ ctx[0] + " svelte-bj14yj")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AnalyticsColorBlock", slots, []);
    	let { type = "" } = $$props;
    	let { header = "" } = $$props;
    	let { description = "" } = $$props;
    	let { count = "" } = $$props;
    	const writable_props = ["type", "header", "description", "count"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnalyticsColorBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("type" in $$props) $$invalidate(0, type = $$props.type);
    		if ("header" in $$props) $$invalidate(1, header = $$props.header);
    		if ("description" in $$props) $$invalidate(2, description = $$props.description);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    	};

    	$$self.$capture_state = () => ({ type, header, description, count });

    	$$self.$inject_state = $$props => {
    		if ("type" in $$props) $$invalidate(0, type = $$props.type);
    		if ("header" in $$props) $$invalidate(1, header = $$props.header);
    		if ("description" in $$props) $$invalidate(2, description = $$props.description);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [type, header, description, count];
    }

    class AnalyticsColorBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			type: 0,
    			header: 1,
    			description: 2,
    			count: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnalyticsColorBlock",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get type() {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<AnalyticsColorBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/admin/AnalyticsOverall.svelte generated by Svelte v3.32.1 */
    const file$F = "src/components/admin/AnalyticsOverall.svelte";

    function create_fragment$G(ctx) {
    	let div0;
    	let analyticscolorblock0;
    	let t0;
    	let analyticscolorblock1;
    	let t1;
    	let analyticscolorblock2;
    	let t2;
    	let hr;
    	let t3;
    	let div1;
    	let table;
    	let tr0;
    	let th;
    	let t5;
    	let tr1;
    	let td0;
    	let t7;
    	let td1;
    	let t9;
    	let td2;
    	let t11;
    	let tr2;
    	let td3;
    	let t13;
    	let td4;
    	let t15;
    	let td5;
    	let t17;
    	let tr3;
    	let td6;
    	let t19;
    	let td7;
    	let t21;
    	let td8;
    	let current;

    	analyticscolorblock0 = new AnalyticsColorBlock({
    			props: {
    				type: "average",
    				header: "Average",
    				description: "",
    				count: "2.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock1 = new AnalyticsColorBlock({
    			props: {
    				type: "heighest",
    				header: "Highest",
    				description: "CEO",
    				count: "2.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock2 = new AnalyticsColorBlock({
    			props: {
    				type: "lowest",
    				header: "Lowest",
    				description: "Boston",
    				count: "0.6"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(analyticscolorblock0.$$.fragment);
    			t0 = space();
    			create_component(analyticscolorblock1.$$.fragment);
    			t1 = space();
    			create_component(analyticscolorblock2.$$.fragment);
    			t2 = space();
    			hr = element("hr");
    			t3 = space();
    			div1 = element("div");
    			table = element("table");
    			tr0 = element("tr");
    			th = element("th");
    			th.textContent = "Invited users";
    			t5 = space();
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "Williams Johnson";
    			t7 = space();
    			td1 = element("td");
    			td1.textContent = "williamsjohnson@gmail.com";
    			t9 = space();
    			td2 = element("td");
    			td2.textContent = "Joined";
    			t11 = space();
    			tr2 = element("tr");
    			td3 = element("td");
    			td3.textContent = "Williams Johnson";
    			t13 = space();
    			td4 = element("td");
    			td4.textContent = "williamsjohnson@gmail.com";
    			t15 = space();
    			td5 = element("td");
    			td5.textContent = "Not joined";
    			t17 = space();
    			tr3 = element("tr");
    			td6 = element("td");
    			td6.textContent = "Williams Johnson";
    			t19 = space();
    			td7 = element("td");
    			td7.textContent = "williamsjohnson@gmail.com";
    			t21 = space();
    			td8 = element("td");
    			td8.textContent = "Joined";
    			attr_dev(div0, "class", "analytics-block mt-30 svelte-8o11ka");
    			add_location(div0, file$F, 195, 0, 3842);
    			attr_dev(hr, "class", "hr-top mt-15 mb-15");
    			add_location(hr, file$F, 218, 0, 4297);
    			attr_dev(th, "colspan", "3");
    			attr_dev(th, "class", "svelte-8o11ka");
    			add_location(th, file$F, 223, 12, 4424);
    			attr_dev(tr0, "class", "svelte-8o11ka");
    			add_location(tr0, file$F, 222, 8, 4407);
    			attr_dev(td0, "class", "invited-users__name svelte-8o11ka");
    			add_location(td0, file$F, 226, 12, 4498);
    			attr_dev(td1, "class", "invited-users__email svelte-8o11ka");
    			add_location(td1, file$F, 227, 12, 4565);
    			attr_dev(td2, "class", "invited-users__status joined svelte-8o11ka");
    			add_location(td2, file$F, 228, 12, 4641);
    			attr_dev(tr1, "class", "svelte-8o11ka");
    			add_location(tr1, file$F, 225, 8, 4481);
    			attr_dev(td3, "class", "invited-users__name svelte-8o11ka");
    			add_location(td3, file$F, 231, 12, 4733);
    			attr_dev(td4, "class", "invited-users__email svelte-8o11ka");
    			add_location(td4, file$F, 232, 12, 4800);
    			attr_dev(td5, "class", "invited-users__status svelte-8o11ka");
    			add_location(td5, file$F, 233, 12, 4876);
    			attr_dev(tr2, "class", "svelte-8o11ka");
    			add_location(tr2, file$F, 230, 8, 4716);
    			attr_dev(td6, "class", "invited-users__name svelte-8o11ka");
    			add_location(td6, file$F, 236, 12, 4965);
    			attr_dev(td7, "class", "invited-users__email svelte-8o11ka");
    			add_location(td7, file$F, 237, 12, 5032);
    			attr_dev(td8, "class", "invited-users__status joined svelte-8o11ka");
    			add_location(td8, file$F, 238, 12, 5108);
    			attr_dev(tr3, "class", "svelte-8o11ka");
    			add_location(tr3, file$F, 235, 8, 4948);
    			attr_dev(table, "class", "invited-users__table svelte-8o11ka");
    			add_location(table, file$F, 221, 4, 4362);
    			attr_dev(div1, "class", "invited-users");
    			add_location(div1, file$F, 220, 0, 4330);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(analyticscolorblock0, div0, null);
    			append_dev(div0, t0);
    			mount_component(analyticscolorblock1, div0, null);
    			append_dev(div0, t1);
    			mount_component(analyticscolorblock2, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, table);
    			append_dev(table, tr0);
    			append_dev(tr0, th);
    			append_dev(table, t5);
    			append_dev(table, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t7);
    			append_dev(tr1, td1);
    			append_dev(tr1, t9);
    			append_dev(tr1, td2);
    			append_dev(table, t11);
    			append_dev(table, tr2);
    			append_dev(tr2, td3);
    			append_dev(tr2, t13);
    			append_dev(tr2, td4);
    			append_dev(tr2, t15);
    			append_dev(tr2, td5);
    			append_dev(table, t17);
    			append_dev(table, tr3);
    			append_dev(tr3, td6);
    			append_dev(tr3, t19);
    			append_dev(tr3, td7);
    			append_dev(tr3, t21);
    			append_dev(tr3, td8);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticscolorblock0.$$.fragment, local);
    			transition_in(analyticscolorblock1.$$.fragment, local);
    			transition_in(analyticscolorblock2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticscolorblock0.$$.fragment, local);
    			transition_out(analyticscolorblock1.$$.fragment, local);
    			transition_out(analyticscolorblock2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(analyticscolorblock0);
    			destroy_component(analyticscolorblock1);
    			destroy_component(analyticscolorblock2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AnalyticsOverall", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnalyticsOverall> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ AnalyticsColorBlock });
    	return [];
    }

    class AnalyticsOverall extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnalyticsOverall",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    /* src/components/admin/AnalyticsTitle.svelte generated by Svelte v3.32.1 */
    const file$G = "src/components/admin/AnalyticsTitle.svelte";

    function create_fragment$H(ctx) {
    	let div;
    	let analyticscolorblock0;
    	let t0;
    	let analyticscolorblock1;
    	let t1;
    	let analyticscolorblock2;
    	let current;

    	analyticscolorblock0 = new AnalyticsColorBlock({
    			props: {
    				type: "average",
    				header: "Average",
    				description: "",
    				count: "3.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock1 = new AnalyticsColorBlock({
    			props: {
    				type: "heighest",
    				header: "Highest",
    				description: "CEO",
    				count: "4.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock2 = new AnalyticsColorBlock({
    			props: {
    				type: "lowest",
    				header: "Lowest",
    				description: "Boston",
    				count: "5.6"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(analyticscolorblock0.$$.fragment);
    			t0 = space();
    			create_component(analyticscolorblock1.$$.fragment);
    			t1 = space();
    			create_component(analyticscolorblock2.$$.fragment);
    			attr_dev(div, "class", "analytics-block mt-30 svelte-138y743");
    			add_location(div, file$G, 164, 0, 3102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(analyticscolorblock0, div, null);
    			append_dev(div, t0);
    			mount_component(analyticscolorblock1, div, null);
    			append_dev(div, t1);
    			mount_component(analyticscolorblock2, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticscolorblock0.$$.fragment, local);
    			transition_in(analyticscolorblock1.$$.fragment, local);
    			transition_in(analyticscolorblock2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticscolorblock0.$$.fragment, local);
    			transition_out(analyticscolorblock1.$$.fragment, local);
    			transition_out(analyticscolorblock2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(analyticscolorblock0);
    			destroy_component(analyticscolorblock1);
    			destroy_component(analyticscolorblock2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AnalyticsTitle", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnalyticsTitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ AnalyticsColorBlock });
    	return [];
    }

    class AnalyticsTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnalyticsTitle",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src/components/admin/AnalyticsGeography.svelte generated by Svelte v3.32.1 */
    const file$H = "src/components/admin/AnalyticsGeography.svelte";

    function create_fragment$I(ctx) {
    	let div;
    	let analyticscolorblock0;
    	let t0;
    	let analyticscolorblock1;
    	let t1;
    	let analyticscolorblock2;
    	let current;

    	analyticscolorblock0 = new AnalyticsColorBlock({
    			props: {
    				type: "average",
    				header: "Average",
    				description: "",
    				count: "6.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock1 = new AnalyticsColorBlock({
    			props: {
    				type: "heighest",
    				header: "Highest",
    				description: "CEO",
    				count: "7.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock2 = new AnalyticsColorBlock({
    			props: {
    				type: "lowest",
    				header: "Lowest",
    				description: "Boston",
    				count: "8.6"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(analyticscolorblock0.$$.fragment);
    			t0 = space();
    			create_component(analyticscolorblock1.$$.fragment);
    			t1 = space();
    			create_component(analyticscolorblock2.$$.fragment);
    			attr_dev(div, "class", "analytics-block mt-30 svelte-138y743");
    			add_location(div, file$H, 164, 0, 3102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(analyticscolorblock0, div, null);
    			append_dev(div, t0);
    			mount_component(analyticscolorblock1, div, null);
    			append_dev(div, t1);
    			mount_component(analyticscolorblock2, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticscolorblock0.$$.fragment, local);
    			transition_in(analyticscolorblock1.$$.fragment, local);
    			transition_in(analyticscolorblock2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticscolorblock0.$$.fragment, local);
    			transition_out(analyticscolorblock1.$$.fragment, local);
    			transition_out(analyticscolorblock2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(analyticscolorblock0);
    			destroy_component(analyticscolorblock1);
    			destroy_component(analyticscolorblock2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AnalyticsGeography", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnalyticsGeography> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ AnalyticsColorBlock });
    	return [];
    }

    class AnalyticsGeography extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnalyticsGeography",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* src/components/admin/AnalyticsIndustry.svelte generated by Svelte v3.32.1 */
    const file$I = "src/components/admin/AnalyticsIndustry.svelte";

    function create_fragment$J(ctx) {
    	let div;
    	let analyticscolorblock0;
    	let t0;
    	let analyticscolorblock1;
    	let t1;
    	let analyticscolorblock2;
    	let current;

    	analyticscolorblock0 = new AnalyticsColorBlock({
    			props: {
    				type: "average",
    				header: "Average",
    				description: "",
    				count: "9.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock1 = new AnalyticsColorBlock({
    			props: {
    				type: "heighest",
    				header: "Highest",
    				description: "CEO",
    				count: "10.3"
    			},
    			$$inline: true
    		});

    	analyticscolorblock2 = new AnalyticsColorBlock({
    			props: {
    				type: "lowest",
    				header: "Lowest",
    				description: "Boston",
    				count: "11.6"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(analyticscolorblock0.$$.fragment);
    			t0 = space();
    			create_component(analyticscolorblock1.$$.fragment);
    			t1 = space();
    			create_component(analyticscolorblock2.$$.fragment);
    			attr_dev(div, "class", "analytics-block mt-30 svelte-138y743");
    			add_location(div, file$I, 164, 0, 3102);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(analyticscolorblock0, div, null);
    			append_dev(div, t0);
    			mount_component(analyticscolorblock1, div, null);
    			append_dev(div, t1);
    			mount_component(analyticscolorblock2, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticscolorblock0.$$.fragment, local);
    			transition_in(analyticscolorblock1.$$.fragment, local);
    			transition_in(analyticscolorblock2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticscolorblock0.$$.fragment, local);
    			transition_out(analyticscolorblock1.$$.fragment, local);
    			transition_out(analyticscolorblock2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(analyticscolorblock0);
    			destroy_component(analyticscolorblock1);
    			destroy_component(analyticscolorblock2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AnalyticsIndustry", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnalyticsIndustry> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ AnalyticsColorBlock });
    	return [];
    }

    class AnalyticsIndustry extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnalyticsIndustry",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src/components/admin/AnalyticsWindow.svelte generated by Svelte v3.32.1 */
    const file$J = "src/components/admin/AnalyticsWindow.svelte";

    // (665:4) {#if currentStepWindow === 'analyticsOverall-window'}
    function create_if_block_3$1(ctx) {
    	let analyticsoverall;
    	let current;
    	analyticsoverall = new AnalyticsOverall({ $$inline: true });
    	analyticsoverall.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(analyticsoverall.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(analyticsoverall, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticsoverall.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticsoverall.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(analyticsoverall, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(665:4) {#if currentStepWindow === 'analyticsOverall-window'}",
    		ctx
    	});

    	return block;
    }

    // (668:4) {#if currentStepWindow === 'analyticsTitle-window'}
    function create_if_block_2$2(ctx) {
    	let analyticstitle;
    	let current;
    	analyticstitle = new AnalyticsTitle({ $$inline: true });
    	analyticstitle.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(analyticstitle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(analyticstitle, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticstitle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticstitle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(analyticstitle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(668:4) {#if currentStepWindow === 'analyticsTitle-window'}",
    		ctx
    	});

    	return block;
    }

    // (671:4) {#if currentStepWindow === 'analyticsGeography-window'}
    function create_if_block_1$9(ctx) {
    	let analyticsgeography;
    	let current;
    	analyticsgeography = new AnalyticsGeography({ $$inline: true });
    	analyticsgeography.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(analyticsgeography.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(analyticsgeography, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticsgeography.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticsgeography.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(analyticsgeography, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(671:4) {#if currentStepWindow === 'analyticsGeography-window'}",
    		ctx
    	});

    	return block;
    }

    // (674:4) {#if currentStepWindow === 'analyticsIndustry-window'}
    function create_if_block$e(ctx) {
    	let analyticsindustry;
    	let current;
    	analyticsindustry = new AnalyticsIndustry({ $$inline: true });
    	analyticsindustry.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(analyticsindustry.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(analyticsindustry, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticsindustry.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticsindustry.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(analyticsindustry, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(674:4) {#if currentStepWindow === 'analyticsIndustry-window'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let button0;
    	let raw0_value = translations[/*LANG*/ ctx[1]]?.analytics?.menu_1 + "";
    	let t0;
    	let button1;
    	let raw1_value = translations[/*LANG*/ ctx[1]]?.analytics?.menu_2 + "";
    	let t1;
    	let button2;
    	let raw2_value = translations[/*LANG*/ ctx[1]]?.analytics?.menu_3 + "";
    	let t2;
    	let button3;
    	let raw3_value = translations[/*LANG*/ ctx[1]]?.analytics?.menu_4 + "";
    	let t3;
    	let div1;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*currentStepWindow*/ ctx[0] === "analyticsOverall-window" && create_if_block_3$1(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "analyticsTitle-window" && create_if_block_2$2(ctx);
    	let if_block2 = /*currentStepWindow*/ ctx[0] === "analyticsGeography-window" && create_if_block_1$9(ctx);
    	let if_block3 = /*currentStepWindow*/ ctx[0] === "analyticsIndustry-window" && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			t0 = space();
    			button1 = element("button");
    			t1 = space();
    			button2 = element("button");
    			t2 = space();
    			button3 = element("button");
    			t3 = space();
    			div1 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Logins per Week";
    			option1 = element("option");
    			option1.textContent = "Logins per Week";
    			option2 = element("option");
    			option2.textContent = "Logins per Week";
    			t7 = space();
    			if (if_block0) if_block0.c();
    			t8 = space();
    			if (if_block1) if_block1.c();
    			t9 = space();
    			if (if_block2) if_block2.c();
    			t10 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(button0, "class", "analytics-menu__item btn btn-gray active svelte-12gn47i");
    			attr_dev(button0, "data-step", "analyticsOverall-window");
    			add_location(button0, file$J, 625, 12, 29936);
    			attr_dev(button1, "class", "analytics-menu__item btn btn-gray svelte-12gn47i");
    			attr_dev(button1, "data-step", "analyticsTitle-window");
    			add_location(button1, file$J, 631, 12, 30219);
    			attr_dev(button2, "class", "analytics-menu__item btn btn-gray svelte-12gn47i");
    			attr_dev(button2, "data-step", "analyticsGeography-window");
    			add_location(button2, file$J, 637, 12, 30493);
    			attr_dev(button3, "class", "analytics-menu__item btn btn-gray svelte-12gn47i");
    			attr_dev(button3, "data-step", "analyticsIndustry-window");
    			add_location(button3, file$J, 643, 12, 30771);
    			attr_dev(div0, "class", "analytics-menu svelte-12gn47i");
    			add_location(div0, file$J, 624, 8, 29895);
    			option0.__value = "1";
    			option0.value = option0.__value;
    			add_location(option0, file$J, 657, 16, 31374);
    			option1.__value = "2";
    			option1.value = option1.__value;
    			add_location(option1, file$J, 658, 16, 31433);
    			option2.__value = "3";
    			option2.value = option2.__value;
    			add_location(option2, file$J, 659, 16, 31492);
    			attr_dev(select, "name", "");
    			attr_dev(select, "id", "");
    			attr_dev(select, "class", "analytics-menu-sort__select svelte-12gn47i");
    			add_location(select, file$J, 656, 12, 31299);
    			attr_dev(div1, "class", "analytics-menu-sort svelte-12gn47i");
    			add_location(div1, file$J, 650, 8, 31059);
    			attr_dev(div2, "class", "wrap-analytics-menu svelte-12gn47i");
    			add_location(div2, file$J, 623, 4, 29853);
    			add_location(div3, file$J, 622, 0, 29843);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, button0);
    			button0.innerHTML = raw0_value;
    			append_dev(div0, t0);
    			append_dev(div0, button1);
    			button1.innerHTML = raw1_value;
    			append_dev(div0, t1);
    			append_dev(div0, button2);
    			button2.innerHTML = raw2_value;
    			append_dev(div0, t2);
    			append_dev(div0, button3);
    			button3.innerHTML = raw3_value;
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(div3, t7);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t8);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t9);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div3, t10);
    			if (if_block3) if_block3.m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button1, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button2, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button3, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "analyticsOverall-window") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div3, t8);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "analyticsTitle-window") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t9);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "analyticsGeography-window") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$9(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div3, t10);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "analyticsIndustry-window") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$e(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div3, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AnalyticsWindow", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	// let currentStepWindow = 'analytics-window';
    	let currentStepWindow = "analyticsOverall-window";

    	// Define what step should be displayed
    	const windowHandler = event => {
    		$$invalidate(0, currentStepWindow = event.target.dataset.step);
    		let elementsMenu = document.querySelectorAll(".analytics-menu__item");

    		elementsMenu.forEach(function (el) {
    			el.classList.remove("active");
    		});

    		event.target.classList.add("active");
    	};

    	let operators = [
    		{ id: "1", name: "Logins per Week" },
    		{ id: "2", name: "Logins per Week" },
    		{ id: "3", name: "Logins per Week" }
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnalyticsWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		AnalyticsOverall,
    		AnalyticsTitle,
    		AnalyticsGeography,
    		AnalyticsIndustry,
    		Select,
    		dispatch,
    		LANG,
    		currentStepWindow,
    		windowHandler,
    		operators
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    		if ("operators" in $$props) operators = $$props.operators;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, LANG, windowHandler];
    }

    class AnalyticsWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnalyticsWindow",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src/components/admin/Admin.svelte generated by Svelte v3.32.1 */
    const file$K = "src/components/admin/Admin.svelte";

    function create_fragment$L(ctx) {
    	let div1;
    	let div0;
    	let t0_value = /*adminName*/ ctx[2]["admin-name"] + "";
    	let t0;
    	let t1;
    	let btnsymbol;
    	let current;

    	btnsymbol = new BtnSymbol({
    			props: {
    				symbol: "del",
    				dataRole: /*dataRoleRemove*/ ctx[1],
    				color: "gray",
    				dataIndex: /*keyIndex*/ ctx[0]
    			},
    			$$inline: true
    		});

    	btnsymbol.$on("click", /*click_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(btnsymbol.$$.fragment);
    			attr_dev(div0, "class", "list-admins__name svelte-1np5li5");
    			add_location(div0, file$K, 192, 4, 4881);
    			attr_dev(div1, "class", "list-admins__item svelte-1np5li5");
    			attr_dev(div1, "data-index", /*keyIndex*/ ctx[0]);
    			add_location(div1, file$K, 191, 0, 4822);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			mount_component(btnsymbol, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*adminName*/ 4) && t0_value !== (t0_value = /*adminName*/ ctx[2]["admin-name"] + "")) set_data_dev(t0, t0_value);
    			const btnsymbol_changes = {};
    			if (dirty & /*dataRoleRemove*/ 2) btnsymbol_changes.dataRole = /*dataRoleRemove*/ ctx[1];
    			if (dirty & /*keyIndex*/ 1) btnsymbol_changes.dataIndex = /*keyIndex*/ ctx[0];
    			btnsymbol.$set(btnsymbol_changes);

    			if (!current || dirty & /*keyIndex*/ 1) {
    				attr_dev(div1, "data-index", /*keyIndex*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(btnsymbol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(btnsymbol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(btnsymbol);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Admin", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let { dataRolePlus = "" } = $$props;
    	let { keyIndex = "" } = $$props;
    	let { dataRoleRemove = "" } = $$props;
    	let { adminName = "" } = $$props;
    	const writable_props = ["dataRolePlus", "keyIndex", "dataRoleRemove", "adminName"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Admin> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("dataRolePlus" in $$props) $$invalidate(3, dataRolePlus = $$props.dataRolePlus);
    		if ("keyIndex" in $$props) $$invalidate(0, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(1, dataRoleRemove = $$props.dataRoleRemove);
    		if ("adminName" in $$props) $$invalidate(2, adminName = $$props.adminName);
    	};

    	$$self.$capture_state = () => ({
    		BtnSymbol,
    		LANG,
    		dataRolePlus,
    		keyIndex,
    		dataRoleRemove,
    		adminName
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataRolePlus" in $$props) $$invalidate(3, dataRolePlus = $$props.dataRolePlus);
    		if ("keyIndex" in $$props) $$invalidate(0, keyIndex = $$props.keyIndex);
    		if ("dataRoleRemove" in $$props) $$invalidate(1, dataRoleRemove = $$props.dataRoleRemove);
    		if ("adminName" in $$props) $$invalidate(2, adminName = $$props.adminName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [keyIndex, dataRoleRemove, adminName, dataRolePlus, click_handler];
    }

    class Admin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
    			dataRolePlus: 3,
    			keyIndex: 0,
    			dataRoleRemove: 1,
    			adminName: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Admin",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get dataRolePlus() {
    		throw new Error("<Admin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRolePlus(value) {
    		throw new Error("<Admin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keyIndex() {
    		throw new Error("<Admin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keyIndex(value) {
    		throw new Error("<Admin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dataRoleRemove() {
    		throw new Error("<Admin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dataRoleRemove(value) {
    		throw new Error("<Admin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get adminName() {
    		throw new Error("<Admin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set adminName(value) {
    		throw new Error("<Admin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/admin/AdminsWindowAllAdmin.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$4 } = globals;
    const file$L = "src/components/admin/AdminsWindowAllAdmin.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (213:16) {#if parsedAdminsData}
    function create_if_block$f(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = Object.keys(/*parsedAdminsData*/ ctx[2]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*adminItem*/ ctx[10];
    	validate_each_keys(ctx, each_value, get_each_context$8, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$8(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, parsedAdminsData, elemBehaviourHandler*/ 36) {
    				each_value = Object.keys(/*parsedAdminsData*/ ctx[2]);
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$8, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$8, each_1_anchor, get_each_context$8);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(213:16) {#if parsedAdminsData}",
    		ctx
    	});

    	return block;
    }

    // (214:20) {#each Object.keys(parsedAdminsData) as adminItem (adminItem)}
    function create_each_block$8(key_1, ctx) {
    	let first;
    	let admin;
    	let current;

    	admin = new Admin({
    			props: {
    				keyIndex: /*adminItem*/ ctx[10],
    				dataRoleRemove: "remove-elem",
    				adminName: /*parsedAdminsData*/ ctx[2][/*adminItem*/ ctx[10]]
    			},
    			$$inline: true
    		});

    	admin.$on("click", /*elemBehaviourHandler*/ ctx[5]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(admin.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(admin, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const admin_changes = {};
    			if (dirty & /*parsedAdminsData*/ 4) admin_changes.keyIndex = /*adminItem*/ ctx[10];
    			if (dirty & /*parsedAdminsData*/ 4) admin_changes.adminName = /*parsedAdminsData*/ ctx[2][/*adminItem*/ ctx[10]];
    			admin.$set(admin_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(admin.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(admin.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(admin, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(214:20) {#each Object.keys(parsedAdminsData) as adminItem (adminItem)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let div4;
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let scrollbar;
    	let t1;
    	let div3;
    	let btnstandart;
    	let current;
    	let if_block = /*parsedAdminsData*/ ctx[2] && create_if_block$f(ctx);

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				dataStep: "adminsWindowAddAdmin-window",
    				text: translations[/*LANG*/ ctx[3]]?.adminAllAdmins?.adminAllAdmins_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*windowHandler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(scrollbar.$$.fragment);
    			t1 = space();
    			div3 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "list-admins svelte-1gy29bh");
    			add_location(div0, file$L, 211, 12, 5668);
    			attr_dev(div1, "class", "dynamic-content");
    			add_location(div1, file$L, 210, 8, 5596);
    			attr_dev(div2, "class", "my-scroller svelte-1gy29bh");
    			add_location(div2, file$L, 209, 4, 5534);
    			attr_dev(div3, "class", "mt-30");
    			add_location(div3, file$L, 232, 4, 6380);
    			add_location(div4, file$L, 207, 0, 5523);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    			/*div1_binding*/ ctx[6](div1);
    			/*div2_binding*/ ctx[7](div2);
    			append_dev(div4, t0);
    			mount_component(scrollbar, div4, null);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			mount_component(btnstandart, div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*parsedAdminsData*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*parsedAdminsData*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block) if_block.d();
    			/*div1_binding*/ ctx[6](null);
    			/*div2_binding*/ ctx[7](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AdminsWindowAllAdmin", slots, []);
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const windowHandler = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	// Get admins data
    	const adminsData = localStorage.getItem("entered-admin-data");

    	let parsedAdminsData = adminsData ? { ...JSON.parse(adminsData) } : {};

    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "remove-elem":
    				delete parsedAdminsData[ITEM_INDEX];
    				$$invalidate(2, parsedAdminsData);
    				break;
    		}

    		if (!checkStepFields("editAdminBlock")) return false;

    		// Update localStorage with users data
    		saveEnteredAdminData("editAdminBlock");
    	};

    	const writable_props = [];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AdminsWindowAllAdmin> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnStandart,
    		Admin,
    		checkStepFields,
    		saveEnteredAdminData,
    		iChangeMyHeight,
    		iAmScrollArea,
    		dispatch,
    		LANG,
    		windowHandler,
    		adminsData,
    		parsedAdminsData,
    		elemBehaviourHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    		if ("parsedAdminsData" in $$props) $$invalidate(2, parsedAdminsData = $$props.parsedAdminsData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		iChangeMyHeight,
    		iAmScrollArea,
    		parsedAdminsData,
    		LANG,
    		windowHandler,
    		elemBehaviourHandler,
    		div1_binding,
    		div2_binding
    	];
    }

    class AdminsWindowAllAdmin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AdminsWindowAllAdmin",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* src/components/admin/AdminsWindowAddAdmin.svelte generated by Svelte v3.32.1 */
    const file$M = "src/components/admin/AdminsWindowAddAdmin.svelte";

    function create_fragment$N(ctx) {
    	let div2;
    	let form;
    	let input;
    	let t0;
    	let div0;
    	let btnstandart;
    	let t1;
    	let div1;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;

    	input = new Input({
    			props: {
    				dataInputRole: "email",
    				name: "admin-name",
    				groupIndex: /*keyIndex*/ ctx[1],
    				label: translations[/*LANG*/ ctx[0]]?.adminAddAdmins?.adminAddAdmins_input
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[0]]?.adminAddAdmins?.adminAddAdmins_btn,
    				btnType: "submit",
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "adminsWindowAllAdmin-window" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[2]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			form = element("form");
    			create_component(input.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(div0, "class", "mt-30");
    			add_location(div0, file$M, 41, 8, 2300);
    			attr_dev(div1, "class", "mt-30");
    			add_location(div1, file$M, 47, 8, 2518);
    			attr_dev(form, "data-role", "addAdminBlock");
    			attr_dev(form, "data-step", "adminsWindowAllAdmin-window");
    			add_location(form, file$M, 32, 4, 1957);
    			attr_dev(div2, "class", "mt-30");
    			add_location(div2, file$M, 31, 0, 1933);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, form);
    			mount_component(input, form, null);
    			append_dev(form, t0);
    			append_dev(form, div0);
    			mount_component(btnstandart, div0, null);
    			append_dev(form, t1);
    			append_dev(form, div1);
    			mount_component(btnback, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[3]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(input);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AdminsWindowAddAdmin", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let keyIndex = "";

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("addAdminBlock")) return false;

    		// Update localStorage with users data
    		saveEnteredAdminData("addAdminBlock");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AdminsWindowAddAdmin> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		saveEnteredAdminData,
    		createEventDispatcher,
    		translations,
    		BtnStandart,
    		BtnBack,
    		Input,
    		dispatch,
    		LANG,
    		keyIndex,
    		goToBack,
    		goToNextStep
    	});

    	$$self.$inject_state = $$props => {
    		if ("keyIndex" in $$props) $$invalidate(1, keyIndex = $$props.keyIndex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [LANG, keyIndex, goToBack, goToNextStep];
    }

    class AdminsWindowAddAdmin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AdminsWindowAddAdmin",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src/components/admin/AdminsWindow.svelte generated by Svelte v3.32.1 */
    const file$N = "src/components/admin/AdminsWindow.svelte";

    // (15:4) {#if currentStepWindow === 'adminsWindowAllAdmin-window'}
    function create_if_block_1$a(ctx) {
    	let adminswindowalladmin;
    	let current;
    	adminswindowalladmin = new AdminsWindowAllAdmin({ $$inline: true });
    	adminswindowalladmin.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(adminswindowalladmin.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(adminswindowalladmin, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(adminswindowalladmin.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(adminswindowalladmin.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(adminswindowalladmin, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(15:4) {#if currentStepWindow === 'adminsWindowAllAdmin-window'}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if currentStepWindow === 'adminsWindowAddAdmin-window'}
    function create_if_block$g(ctx) {
    	let adminswindowaddadmin;
    	let current;
    	adminswindowaddadmin = new AdminsWindowAddAdmin({ $$inline: true });
    	adminswindowaddadmin.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(adminswindowaddadmin.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(adminswindowaddadmin, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(adminswindowaddadmin.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(adminswindowaddadmin.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(adminswindowaddadmin, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(18:4) {#if currentStepWindow === 'adminsWindowAddAdmin-window'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*currentStepWindow*/ ctx[0] === "adminsWindowAllAdmin-window" && create_if_block_1$a(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "adminsWindowAddAdmin-window" && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			add_location(div, file$N, 12, 0, 321);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "adminsWindowAllAdmin-window") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$a(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "adminsWindowAddAdmin-window") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$g(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AdminsWindow", slots, []);
    	let currentStepWindow = "adminsWindowAllAdmin-window";

    	const windowHandler = event => {
    		$$invalidate(0, currentStepWindow = event.detail.step);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AdminsWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AdminsWindowAllAdmin,
    		AdminsWindowAddAdmin,
    		currentStepWindow,
    		windowHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, windowHandler];
    }

    class AdminsWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AdminsWindow",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/components/admin/TagsWindowAllTags.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$5 } = globals;
    const file$O = "src/components/admin/TagsWindowAllTags.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (72:20) {#if parsedTagsData}
    function create_if_block$h(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = Object.keys(/*parsedTagsData*/ ctx[3]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*tagItem*/ ctx[13];
    	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, parsedTagsData, values, isReadOnly, elemBehaviourHandler*/ 108) {
    				each_value = Object.keys(/*parsedTagsData*/ ctx[3]);
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$9, each_1_anchor, get_each_context$9);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(72:20) {#if parsedTagsData}",
    		ctx
    	});

    	return block;
    }

    // (73:24) {#each Object.keys(parsedTagsData) as tagItem (tagItem)}
    function create_each_block$9(key_1, ctx) {
    	let first;
    	let tagedit;
    	let current;

    	tagedit = new TagEdit({
    			props: {
    				keyIndex: /*tagItem*/ ctx[13],
    				values: /*values*/ ctx[5],
    				dataRoleRemove: "remove-elem",
    				dataRoleEdit: "edit-elem",
    				isReadOnly: /*isReadOnly*/ ctx[2],
    				data: /*parsedTagsData*/ ctx[3][/*tagItem*/ ctx[13]]
    			},
    			$$inline: true
    		});

    	tagedit.$on("click", /*elemBehaviourHandler*/ ctx[6]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(tagedit.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(tagedit, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const tagedit_changes = {};
    			if (dirty & /*parsedTagsData*/ 8) tagedit_changes.keyIndex = /*tagItem*/ ctx[13];
    			if (dirty & /*isReadOnly*/ 4) tagedit_changes.isReadOnly = /*isReadOnly*/ ctx[2];
    			if (dirty & /*parsedTagsData*/ 8) tagedit_changes.data = /*parsedTagsData*/ ctx[3][/*tagItem*/ ctx[13]];
    			tagedit.$set(tagedit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagedit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagedit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(tagedit, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(73:24) {#each Object.keys(parsedTagsData) as tagItem (tagItem)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let div4;
    	let form;
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let scrollbar;
    	let t1;
    	let div3;
    	let btnstandart;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*parsedTagsData*/ ctx[3] && create_if_block$h(ctx);

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				btnType: "submit",
    				text: translations[/*LANG*/ ctx[4]].adminAllTags.adminAllTags_btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			form = element("form");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(scrollbar.$$.fragment);
    			t1 = space();
    			div3 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "wrap-edit-blocks");
    			add_location(div0, file$O, 70, 16, 3086);
    			attr_dev(div1, "class", "dynamic-content");
    			add_location(div1, file$O, 69, 12, 3010);
    			attr_dev(div2, "class", "my-scroller svelte-166u8r3");
    			add_location(div2, file$O, 68, 8, 2944);
    			attr_dev(div3, "class", "mt-30");
    			add_location(div3, file$O, 92, 8, 4006);
    			attr_dev(form, "name", "edit-tags");
    			attr_dev(form, "data-role", "editTagsBlock-step");
    			attr_dev(form, "data-step", "tagsWindowAddTags-window");
    			add_location(form, file$O, 63, 4, 2773);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$O, 61, 0, 2748);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, form);
    			append_dev(form, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    			/*div1_binding*/ ctx[8](div1);
    			/*div2_binding*/ ctx[9](div2);
    			append_dev(form, t0);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t1);
    			append_dev(form, div3);
    			mount_component(btnstandart, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[7]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*parsedTagsData*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*parsedTagsData*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block) if_block.d();
    			/*div1_binding*/ ctx[8](null);
    			/*div2_binding*/ ctx[9](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TagsWindowAllTags", slots, []);
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [TagEdit];
    	let isReadOnly = "readonly";

    	// Get rules data
    	const tagsData = localStorage.getItem("entered-tag-data");

    	let parsedTagsData = tagsData ? { ...JSON.parse(tagsData) } : {};

    	let values = [
    		{ id: "0", name: "Target an audience" },
    		{ id: "1", name: "Target an audience 2" },
    		{ id: "2", name: "Target an audience 3" }
    	];

    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "edit-elem":
    				$$invalidate(3, parsedTagsData);
    				$$invalidate(2, isReadOnly = "");
    				break;
    			case "remove-elem":
    				delete parsedTagsData[ITEM_INDEX];
    				$$invalidate(3, parsedTagsData);
    				break;
    		}
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("editTagsBlock-step")) return false;

    		// Update localStorage with users data
    		saveEnteredTagData("editTagsBlock-step");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TagsWindowAllTags> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnStandart,
    		TagEdit,
    		checkStepFields,
    		saveEnteredTagData,
    		iChangeMyHeight,
    		iAmScrollArea,
    		dispatch,
    		LANG,
    		itemsCount,
    		isReadOnly,
    		tagsData,
    		parsedTagsData,
    		values,
    		elemBehaviourHandler,
    		goToNextStep
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    		if ("itemsCount" in $$props) itemsCount = $$props.itemsCount;
    		if ("isReadOnly" in $$props) $$invalidate(2, isReadOnly = $$props.isReadOnly);
    		if ("parsedTagsData" in $$props) $$invalidate(3, parsedTagsData = $$props.parsedTagsData);
    		if ("values" in $$props) $$invalidate(5, values = $$props.values);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		iChangeMyHeight,
    		iAmScrollArea,
    		isReadOnly,
    		parsedTagsData,
    		LANG,
    		values,
    		elemBehaviourHandler,
    		goToNextStep,
    		div1_binding,
    		div2_binding
    	];
    }

    class TagsWindowAllTags extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagsWindowAllTags",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* src/components/admin/TagsWindowAddTags.svelte generated by Svelte v3.32.1 */
    const file$P = "src/components/admin/TagsWindowAddTags.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (258:20) {#if itemsCount}
    function create_if_block$i(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*itemsCount*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*itemsCount, elemBehaviourHandler*/ 65) {
    				each_value = /*itemsCount*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(258:20) {#if itemsCount}",
    		ctx
    	});

    	return block;
    }

    // (259:24) {#each itemsCount as component , index}
    function create_each_block$a(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[10];

    	function switch_props(ctx) {
    		return {
    			props: {
    				keyIndex: /*index*/ ctx[12],
    				dataRoleRemove: "remove-elem",
    				dataRolePlus: "create-new-elem"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*component*/ ctx[10])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(259:24) {#each itemsCount as component , index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let div6;
    	let div0;
    	let h2;
    	let t1;
    	let form;
    	let hr0;
    	let t2;
    	let div3;
    	let div2;
    	let div1;
    	let t3;
    	let scrollbar;
    	let t4;
    	let hr1;
    	let t5;
    	let div4;
    	let btnstandart;
    	let t6;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*itemsCount*/ ctx[0] && create_if_block$i(ctx);

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[1],
    				scrollArea: /*iAmScrollArea*/ ctx[2],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[3]]?.adminAddTags?.adminAddTags_btn,
    				btnType: "submit",
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "tagsWindowAllTags-window" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToNextWindow*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = `${translations[/*LANG*/ ctx[3]]?.adminAddTags?.adminAddTags_heading}`;
    			t1 = space();
    			form = element("form");
    			hr0 = element("hr");
    			t2 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t3 = space();
    			create_component(scrollbar.$$.fragment);
    			t4 = space();
    			hr1 = element("hr");
    			t5 = space();
    			div4 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t6 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			add_location(h2, file$P, 247, 8, 6341);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$P, 246, 4, 6313);
    			attr_dev(hr0, "class", "hr-top");
    			add_location(hr0, file$P, 253, 8, 6564);
    			attr_dev(div1, "class", "wrap-rules-blocks");
    			add_location(div1, file$P, 256, 16, 6734);
    			attr_dev(div2, "class", "dynamic-content");
    			add_location(div2, file$P, 255, 12, 6658);
    			attr_dev(div3, "class", "my-scroller svelte-15u8ma4");
    			add_location(div3, file$P, 254, 8, 6592);
    			attr_dev(hr1, "class", "hr-top");
    			add_location(hr1, file$P, 275, 8, 7556);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$P, 277, 8, 7585);
    			attr_dev(form, "data-role", "addTagsBlock");
    			attr_dev(form, "data-step", "tagsWindowAllTags-window");
    			add_location(form, file$P, 249, 4, 6422);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$P, 283, 4, 7806);
    			attr_dev(div6, "class", "mt-30");
    			add_location(div6, file$P, 245, 0, 6289);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			append_dev(div0, h2);
    			append_dev(div6, t1);
    			append_dev(div6, form);
    			append_dev(form, hr0);
    			append_dev(form, t2);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			/*div2_binding*/ ctx[7](div2);
    			/*div3_binding*/ ctx[8](div3);
    			append_dev(form, t3);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t4);
    			append_dev(form, hr1);
    			append_dev(form, t5);
    			append_dev(form, div4);
    			mount_component(btnstandart, div4, null);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[5]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*itemsCount*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*itemsCount*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 2) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[1];
    			if (dirty & /*iAmScrollArea*/ 4) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[2];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if (if_block) if_block.d();
    			/*div2_binding*/ ctx[7](null);
    			/*div3_binding*/ ctx[8](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TagsWindowAddTags", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [Tag];

    	const goToNextWindow = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("addTagsBlock")) return false;

    		// Update localStorage with users data
    		saveEnteredTagData("addTagsBlock");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;

    	/**
     *
     * @param event
     */
    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "create-new-elem":
    				$$invalidate(0, itemsCount = [...itemsCount, Tag]);
    				break;
    			case "remove-elem":
    				delete itemsCount[ITEM_INDEX];
    				$$invalidate(0, itemsCount);
    				break;
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TagsWindowAddTags> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(1, iChangeMyHeight);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(2, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		saveEnteredTagData,
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnStandart,
    		BtnBack,
    		Tag,
    		dispatch,
    		LANG,
    		itemsCount,
    		goToNextWindow,
    		goToNextStep,
    		iChangeMyHeight,
    		iAmScrollArea,
    		elemBehaviourHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("itemsCount" in $$props) $$invalidate(0, itemsCount = $$props.itemsCount);
    		if ("iChangeMyHeight" in $$props) $$invalidate(1, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(2, iAmScrollArea = $$props.iAmScrollArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		itemsCount,
    		iChangeMyHeight,
    		iAmScrollArea,
    		LANG,
    		goToNextWindow,
    		goToNextStep,
    		elemBehaviourHandler,
    		div2_binding,
    		div3_binding
    	];
    }

    class TagsWindowAddTags extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagsWindowAddTags",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src/components/admin/TagsWindow.svelte generated by Svelte v3.32.1 */
    const file$Q = "src/components/admin/TagsWindow.svelte";

    // (15:4) {#if currentStepWindow === 'tagsWindowAllTags-window'}
    function create_if_block_1$b(ctx) {
    	let adminswindowalladmin;
    	let current;
    	adminswindowalladmin = new TagsWindowAllTags({ $$inline: true });
    	adminswindowalladmin.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(adminswindowalladmin.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(adminswindowalladmin, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(adminswindowalladmin.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(adminswindowalladmin.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(adminswindowalladmin, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(15:4) {#if currentStepWindow === 'tagsWindowAllTags-window'}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if currentStepWindow === 'tagsWindowAddTags-window'}
    function create_if_block$j(ctx) {
    	let adminswindowaddadmin;
    	let current;
    	adminswindowaddadmin = new TagsWindowAddTags({ $$inline: true });
    	adminswindowaddadmin.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(adminswindowaddadmin.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(adminswindowaddadmin, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(adminswindowaddadmin.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(adminswindowaddadmin.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(adminswindowaddadmin, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(18:4) {#if currentStepWindow === 'tagsWindowAddTags-window'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*currentStepWindow*/ ctx[0] === "tagsWindowAllTags-window" && create_if_block_1$b(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "tagsWindowAddTags-window" && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			add_location(div, file$Q, 12, 0, 294);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "tagsWindowAllTags-window") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$b(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "tagsWindowAddTags-window") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$j(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TagsWindow", slots, []);
    	let currentStepWindow = "tagsWindowAllTags-window";

    	const windowHandler = event => {
    		$$invalidate(0, currentStepWindow = event.detail.step);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TagsWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AdminsWindowAllAdmin: TagsWindowAllTags,
    		AdminsWindowAddAdmin: TagsWindowAddTags,
    		currentStepWindow,
    		windowHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, windowHandler];
    }

    class TagsWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagsWindow",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* src/components/admin/AccessWindowAllRules.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$6 } = globals;
    const file$R = "src/components/admin/AccessWindowAllRules.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (326:20) {#if parsedRulesData}
    function create_if_block$k(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = Object.keys(/*parsedRulesData*/ ctx[3]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*ruleItem*/ ctx[13];
    	validate_each_keys(ctx, each_value, get_each_context$b, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$b(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*Object, parsedRulesData, operators, isReadOnly, elemBehaviourHandler*/ 108) {
    				each_value = Object.keys(/*parsedRulesData*/ ctx[3]);
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$b, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$b, each_1_anchor, get_each_context$b);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(326:20) {#if parsedRulesData}",
    		ctx
    	});

    	return block;
    }

    // (327:24) {#each Object.keys(parsedRulesData) as ruleItem (ruleItem)}
    function create_each_block$b(key_1, ctx) {
    	let first;
    	let ruleedit;
    	let current;

    	ruleedit = new RuleEdit({
    			props: {
    				keyIndex: /*ruleItem*/ ctx[13],
    				operators: /*operators*/ ctx[5],
    				dataRoleRemove: "remove-elem",
    				dataRoleEdit: "edit-rule",
    				isReadOnly: /*isReadOnly*/ ctx[2],
    				data: /*parsedRulesData*/ ctx[3][/*ruleItem*/ ctx[13]]
    			},
    			$$inline: true
    		});

    	ruleedit.$on("click", /*elemBehaviourHandler*/ ctx[6]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(ruleedit.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(ruleedit, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const ruleedit_changes = {};
    			if (dirty & /*parsedRulesData*/ 8) ruleedit_changes.keyIndex = /*ruleItem*/ ctx[13];
    			if (dirty & /*isReadOnly*/ 4) ruleedit_changes.isReadOnly = /*isReadOnly*/ ctx[2];
    			if (dirty & /*parsedRulesData*/ 8) ruleedit_changes.data = /*parsedRulesData*/ ctx[3][/*ruleItem*/ ctx[13]];
    			ruleedit.$set(ruleedit_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ruleedit.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ruleedit.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(ruleedit, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(327:24) {#each Object.keys(parsedRulesData) as ruleItem (ruleItem)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let div4;
    	let form;
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let scrollbar;
    	let t1;
    	let div3;
    	let btnstandart;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*parsedRulesData*/ ctx[3] && create_if_block$k(ctx);

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				btnType: "submit",
    				text: translations[/*LANG*/ ctx[4]].adminAllRules.btn,
    				color: "purple"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			form = element("form");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(scrollbar.$$.fragment);
    			t1 = space();
    			div3 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "wrap-rules-blocks");
    			add_location(div0, file$R, 324, 16, 8530);
    			attr_dev(div1, "class", "dynamic-content");
    			add_location(div1, file$R, 323, 12, 8454);
    			attr_dev(div2, "class", "my-scroller svelte-rreazo");
    			add_location(div2, file$R, 322, 8, 8388);
    			attr_dev(div3, "class", "mt-30");
    			add_location(div3, file$R, 346, 8, 9471);
    			attr_dev(form, "name", "edit-rules");
    			attr_dev(form, "data-role", "editRulesBlock-step");
    			attr_dev(form, "data-step", "accessWindowAddRules-window");
    			add_location(form, file$R, 317, 4, 8212);
    			add_location(div4, file$R, 316, 0, 8202);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, form);
    			append_dev(form, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    			/*div1_binding*/ ctx[8](div1);
    			/*div2_binding*/ ctx[9](div2);
    			append_dev(form, t0);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t1);
    			append_dev(form, div3);
    			mount_component(btnstandart, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[7]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*parsedRulesData*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*parsedRulesData*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (if_block) if_block.d();
    			/*div1_binding*/ ctx[8](null);
    			/*div2_binding*/ ctx[9](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccessWindowAllRules", slots, []);
    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [RuleEdit];
    	let isReadOnly = "readonly";

    	// Get rules data
    	const rulesData = localStorage.getItem("entered-rule-data");

    	let parsedRulesData = rulesData ? { ...JSON.parse(rulesData) } : {};

    	let operators = [
    		{ id: "0", name: "Equals" },
    		{ id: "1", name: "Plus" },
    		{ id: "2", name: "Minus" }
    	];

    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "edit-rule":
    				$$invalidate(3, parsedRulesData);
    				$$invalidate(2, isReadOnly = "");
    				break;
    			case "remove-elem":
    				delete parsedRulesData[ITEM_INDEX];
    				$$invalidate(3, parsedRulesData);
    				break;
    		}
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("editRulesBlock-step")) return false;

    		// Update localStorage with users data
    		saveEnteredRuleData("editRulesBlock-step");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object_1$6.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccessWindowAllRules> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnStandart,
    		RuleEdit,
    		checkStepFields,
    		saveEnteredRuleData,
    		iChangeMyHeight,
    		iAmScrollArea,
    		dispatch,
    		LANG,
    		itemsCount,
    		isReadOnly,
    		rulesData,
    		parsedRulesData,
    		operators,
    		elemBehaviourHandler,
    		goToNextStep
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    		if ("itemsCount" in $$props) itemsCount = $$props.itemsCount;
    		if ("isReadOnly" in $$props) $$invalidate(2, isReadOnly = $$props.isReadOnly);
    		if ("parsedRulesData" in $$props) $$invalidate(3, parsedRulesData = $$props.parsedRulesData);
    		if ("operators" in $$props) $$invalidate(5, operators = $$props.operators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		iChangeMyHeight,
    		iAmScrollArea,
    		isReadOnly,
    		parsedRulesData,
    		LANG,
    		operators,
    		elemBehaviourHandler,
    		goToNextStep,
    		div1_binding,
    		div2_binding
    	];
    }

    class AccessWindowAllRules extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccessWindowAllRules",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    /* src/components/admin/AccessWindowAddRules.svelte generated by Svelte v3.32.1 */
    const file$S = "src/components/admin/AccessWindowAddRules.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (329:20) {#if itemsCount}
    function create_if_block$l(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*itemsCount*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*itemsCount, elemBehaviourHandler*/ 65) {
    				each_value = /*itemsCount*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(329:20) {#if itemsCount}",
    		ctx
    	});

    	return block;
    }

    // (330:24) {#each itemsCount as component , index}
    function create_each_block$c(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[11];

    	function switch_props(ctx) {
    		return {
    			props: {
    				keyIndex: /*index*/ ctx[13],
    				dataRoleRemove: "remove-elem",
    				dataRolePlus: "create-new-elem"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*component*/ ctx[11])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("click", /*elemBehaviourHandler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(330:24) {#each itemsCount as component , index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let div5;
    	let h2;
    	let raw_value = translations[/*LANG*/ ctx[3]]?.adminAddRules?.header + "";
    	let t0;
    	let hr;
    	let t1;
    	let form;
    	let div2;
    	let div1;
    	let div0;
    	let t2;
    	let scrollbar;
    	let t3;
    	let div3;
    	let btnstandart;
    	let t4;
    	let div4;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*itemsCount*/ ctx[0] && create_if_block$l(ctx);

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[1],
    				scrollArea: /*iAmScrollArea*/ ctx[2],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[3]]?.adminAddRules?.btn,
    				btnType: "submit",
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "accessWindowAllRules-window" },
    			$$inline: true
    		});

    	btnback.$on("click", /*windowHandler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			h2 = element("h2");
    			t0 = space();
    			hr = element("hr");
    			t1 = space();
    			form = element("form");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t2 = space();
    			create_component(scrollbar.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t4 = space();
    			div4 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(h2, "class", "mt-15");
    			add_location(h2, file$S, 317, 4, 8139);
    			attr_dev(hr, "class", "hr-top");
    			add_location(hr, file$S, 318, 4, 8216);
    			attr_dev(div0, "class", "wrap-rules-blocks");
    			add_location(div0, file$S, 327, 16, 8535);
    			attr_dev(div1, "class", "dynamic-content");
    			add_location(div1, file$S, 326, 12, 8459);
    			attr_dev(div2, "class", "my-scroller svelte-9gdgb6");
    			add_location(div2, file$S, 325, 8, 8393);
    			attr_dev(div3, "class", "mt-30");
    			add_location(div3, file$S, 347, 8, 9358);
    			attr_dev(div4, "class", "mt-30");
    			add_location(div4, file$S, 353, 8, 9617);
    			attr_dev(form, "data-role", "addRulesBlock-step");
    			attr_dev(form, "data-step", "accessWindowAllRules-window");
    			add_location(form, file$S, 320, 4, 8241);
    			attr_dev(div5, "class", "center-block__content rules svelte-9gdgb6");
    			add_location(div5, file$S, 316, 0, 8093);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, h2);
    			h2.innerHTML = raw_value;
    			append_dev(div5, t0);
    			append_dev(div5, hr);
    			append_dev(div5, t1);
    			append_dev(div5, form);
    			append_dev(form, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    			/*div1_binding*/ ctx[7](div1);
    			/*div2_binding*/ ctx[8](div2);
    			append_dev(form, t2);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t3);
    			append_dev(form, div3);
    			mount_component(btnstandart, div3, null);
    			append_dev(form, t4);
    			append_dev(form, div4);
    			mount_component(btnback, div4, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextStep*/ ctx[5]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*itemsCount*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*itemsCount*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 2) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[1];
    			if (dirty & /*iAmScrollArea*/ 4) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[2];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block) if_block.d();
    			/*div1_binding*/ ctx[7](null);
    			/*div2_binding*/ ctx[8](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccessWindowAddRules", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let itemsCount = [Rule];

    	let operators = [
    		{ id: "0", name: "Equals" },
    		{ id: "1", name: "Plus" },
    		{ id: "2", name: "Minus" }
    	];

    	const windowHandler = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToNextStep = event => {
    		if (!checkStepFields("addRulesBlock-step")) return false;

    		// Update localStorage with users data
    		saveEnteredRuleData("addRulesBlock-step");

    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;

    	/**
     *
     * @param event
     */
    	const elemBehaviourHandler = event => {
    		const ROLE = event.target.dataset.role;
    		const ITEM_INDEX = event.target.dataset.index;

    		switch (ROLE) {
    			case "create-new-elem":
    				$$invalidate(0, itemsCount = [...itemsCount, Rule]);
    				break;
    			case "remove-elem":
    				delete itemsCount[ITEM_INDEX];
    				$$invalidate(0, itemsCount);
    				break;
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccessWindowAddRules> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(1, iChangeMyHeight);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(2, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		checkStepFields,
    		saveEnteredRuleData,
    		createEventDispatcher,
    		translations,
    		Scrollbar,
    		BtnBack,
    		BtnStandart,
    		Rule,
    		dispatch,
    		LANG,
    		itemsCount,
    		operators,
    		windowHandler,
    		goToNextStep,
    		iChangeMyHeight,
    		iAmScrollArea,
    		elemBehaviourHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("itemsCount" in $$props) $$invalidate(0, itemsCount = $$props.itemsCount);
    		if ("operators" in $$props) operators = $$props.operators;
    		if ("iChangeMyHeight" in $$props) $$invalidate(1, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(2, iAmScrollArea = $$props.iAmScrollArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		itemsCount,
    		iChangeMyHeight,
    		iAmScrollArea,
    		LANG,
    		windowHandler,
    		goToNextStep,
    		elemBehaviourHandler,
    		div1_binding,
    		div2_binding
    	];
    }

    class AccessWindowAddRules extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccessWindowAddRules",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    /* src/components/admin/AccessWindow.svelte generated by Svelte v3.32.1 */
    const file$T = "src/components/admin/AccessWindow.svelte";

    // (18:4) {#if currentStepWindow === 'accessWindowAllRules-window'}
    function create_if_block_1$c(ctx) {
    	let accesswindowallrules;
    	let current;
    	accesswindowallrules = new AccessWindowAllRules({ $$inline: true });
    	accesswindowallrules.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(accesswindowallrules.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(accesswindowallrules, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accesswindowallrules.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accesswindowallrules.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(accesswindowallrules, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(18:4) {#if currentStepWindow === 'accessWindowAllRules-window'}",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#if currentStepWindow === 'accessWindowAddRules-window'}
    function create_if_block$m(ctx) {
    	let accesswindowaddrules;
    	let current;
    	accesswindowaddrules = new AccessWindowAddRules({ $$inline: true });
    	accesswindowaddrules.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(accesswindowaddrules.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(accesswindowaddrules, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accesswindowaddrules.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accesswindowaddrules.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(accesswindowaddrules, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(21:4) {#if currentStepWindow === 'accessWindowAddRules-window'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*currentStepWindow*/ ctx[0] === "accessWindowAllRules-window" && create_if_block_1$c(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "accessWindowAddRules-window" && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			add_location(div, file$T, 15, 0, 382);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "accessWindowAllRules-window") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$c(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "accessWindowAddRules-window") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$m(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AccessWindow", slots, []);
    	let currentStepWindow = "accessWindowAllRules-window";

    	//TODO: Need to remove
    	//currentStepWindow = 'accessWindowAddRules-window';
    	const windowHandler = event => {
    		$$invalidate(0, currentStepWindow = event.detail.step);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AccessWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AccessWindowAllRules,
    		AccessWindowAddRules,
    		currentStepWindow,
    		windowHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, windowHandler];
    }

    class AccessWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccessWindow",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }

    /* src/components/Item.svelte generated by Svelte v3.32.1 */
    const file$U = "src/components/Item.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (209:0) {#if isOpen}
    function create_if_block$n(ctx) {
    	let ul;
    	let ul_transition;
    	let current;
    	let each_value = /*entry*/ ctx[0][1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(ul, file$U, 209, 4, 4421);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*entry*/ 1) {
    				each_value = /*entry*/ ctx[0][1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!ul_transition) ul_transition = create_bidirectional_transition(ul, slide, { duration: 300 }, true);
    				ul_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!ul_transition) ul_transition = create_bidirectional_transition(ul, slide, { duration: 300 }, false);
    			ul_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			if (detaching && ul_transition) ul_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(209:0) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    // (211:8) {#each entry[1] as item}
    function create_each_block$d(ctx) {
    	let li;
    	let t_value = /*item*/ ctx[3] + "";
    	let t;

    	const block = {
    		c: function create() {
    			li = element("li");
    			t = text(t_value);
    			attr_dev(li, "class", "accordion__content svelte-5alfd0");
    			add_location(li, file$U, 211, 12, 4508);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*entry*/ 1 && t_value !== (t_value = /*item*/ ctx[3] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(211:8) {#each entry[1] as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let button;
    	let span;
    	let t0_value = /*entry*/ ctx[0][0] + "";
    	let t0;
    	let t1;
    	let svg;
    	let path;
    	let t2;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*isOpen*/ ctx[1] && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(span, file$U, 203, 4, 4159);
    			attr_dev(path, "d", "M9 5l7 7-7 7");
    			add_location(path, file$U, 205, 8, 4352);
    			attr_dev(svg, "width", "20");
    			attr_dev(svg, "height", "20");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "stroke-linecap", "round");
    			attr_dev(svg, "stroke-linejoin", "round");
    			attr_dev(svg, "stroke-width", "2");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "stroke", "currentColor");
    			attr_dev(svg, "class", "svelte-5alfd0");
    			add_location(svg, file$U, 204, 4, 4187);
    			attr_dev(button, "aria-expanded", /*isOpen*/ ctx[1]);
    			attr_dev(button, "class", "accordion__header svelte-5alfd0");
    			add_location(button, file$U, 202, 0, 4079);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, span);
    			append_dev(span, t0);
    			append_dev(button, t1);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggle*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*entry*/ 1) && t0_value !== (t0_value = /*entry*/ ctx[0][0] + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*isOpen*/ 2) {
    				attr_dev(button, "aria-expanded", /*isOpen*/ ctx[1]);
    			}

    			if (/*isOpen*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Item", slots, []);
    	let { entry } = $$props;
    	let isOpen = false;
    	const toggle = () => $$invalidate(1, isOpen = !isOpen);
    	const writable_props = ["entry"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("entry" in $$props) $$invalidate(0, entry = $$props.entry);
    	};

    	$$self.$capture_state = () => ({ slide, entry, isOpen, toggle });

    	$$self.$inject_state = $$props => {
    		if ("entry" in $$props) $$invalidate(0, entry = $$props.entry);
    		if ("isOpen" in $$props) $$invalidate(1, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [entry, isOpen, toggle];
    }

    class Item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, { entry: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$V.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*entry*/ ctx[0] === undefined && !("entry" in props)) {
    			console.warn("<Item> was created without expected prop 'entry'");
    		}
    	}

    	get entry() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set entry(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/admin/ToolsWindow.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$7 } = globals;
    const file$V = "src/components/admin/ToolsWindow.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (30:16) {#each Object.entries(data) as entry}
    function create_each_block$e(ctx) {
    	let item;
    	let current;

    	item = new Item({
    			props: { entry: /*entry*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(item.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(item, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(item, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(30:16) {#each Object.entries(data) as entry}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let div3;
    	let h2;
    	let t1;
    	let hr0;
    	let t2;
    	let div2;
    	let div1;
    	let div0;
    	let t3;
    	let scrollbar;
    	let t4;
    	let hr1;
    	let current;
    	let each_value = Object.entries(/*data*/ ctx[2]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			h2 = element("h2");
    			h2.textContent = `${translations[/*LANG*/ ctx[3]]?.adminTools?.header}`;
    			t1 = space();
    			hr0 = element("hr");
    			t2 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			create_component(scrollbar.$$.fragment);
    			t4 = space();
    			hr1 = element("hr");
    			attr_dev(h2, "class", "mt-15");
    			add_location(h2, file$V, 23, 4, 2236);
    			attr_dev(hr0, "class", "hr-top");
    			add_location(hr0, file$V, 24, 4, 2304);
    			attr_dev(div0, "class", "accordion mt-30 mb-30 svelte-1ayixsr");
    			add_location(div0, file$V, 28, 12, 2463);
    			attr_dev(div1, "class", "dynamic-content");
    			add_location(div1, file$V, 27, 8, 2391);
    			attr_dev(div2, "class", "my-scroller svelte-1ayixsr");
    			add_location(div2, file$V, 26, 4, 2329);
    			attr_dev(hr1, "class", "hr-top");
    			add_location(hr1, file$V, 43, 4, 2846);
    			add_location(div3, file$V, 22, 0, 2226);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, h2);
    			append_dev(div3, t1);
    			append_dev(div3, hr0);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			/*div1_binding*/ ctx[4](div1);
    			/*div2_binding*/ ctx[5](div2);
    			append_dev(div3, t3);
    			mount_component(scrollbar, div3, null);
    			append_dev(div3, t4);
    			append_dev(div3, hr1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Object, data*/ 4) {
    				each_value = Object.entries(/*data*/ ctx[2]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(scrollbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(scrollbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    			/*div1_binding*/ ctx[4](null);
    			/*div2_binding*/ ctx[5](null);
    			destroy_component(scrollbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ToolsWindow", slots, []);

    	const data = {
    		"Steer the conversation": [
    			"To maximize the relevancy of the feed, admins can override the audience set by the intial poster. Just type “/” before each tag in the replies. For example. If you type in “/CEO /Fintech” only Fintech CEOs will see the post, regardless of the intial user posted. The original poster will see a private reply that says the admin replaced"
    		],
    		"Remind the right people": [
    			"To maximize the relevancy of the feed, admins can override the audience set by the intial poster. Just type “/” before each tag in the replies. For example. If you type in “/CEO /Fintech” only Fintech CEOs will see the post, regardless of the intial user posted. The original poster will see a private reply that says the admin replaced"
    		]
    	};

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	const writable_props = [];

    	Object_1$7.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ToolsWindow> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		translations,
    		Scrollbar,
    		Item,
    		data,
    		LANG,
    		iChangeMyHeight,
    		iAmScrollArea
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [iChangeMyHeight, iAmScrollArea, data, LANG, div1_binding, div2_binding];
    }

    class ToolsWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToolsWindow",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    /* src/components/admin/ImportWindow.svelte generated by Svelte v3.32.1 */
    const file$W = "src/components/admin/ImportWindow.svelte";

    function create_fragment$X(ctx) {
    	let div1;
    	let div0;
    	let btnstandart;
    	let current;

    	btnstandart = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[0]]?.importWindow?.importWindow_btn
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "m-30");
    			add_location(div0, file$W, 351, 4, 20329);
    			add_location(div1, file$W, 349, 0, 20318);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(btnstandart, div0, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(btnstandart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ImportWindow", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ImportWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ translations, BtnStandart, LANG });
    	return [LANG];
    }

    class ImportWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImportWindow",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src/components/admin/StepsAdminWindow.svelte generated by Svelte v3.32.1 */
    const file$X = "src/components/admin/StepsAdminWindow.svelte";

    // (328:16) {#if currentStepWindow === 'analytics-window'}
    function create_if_block_5(ctx) {
    	let analyticswindow;
    	let current;
    	analyticswindow = new AnalyticsWindow({ $$inline: true });
    	analyticswindow.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(analyticswindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(analyticswindow, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(analyticswindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(analyticswindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(analyticswindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(328:16) {#if currentStepWindow === 'analytics-window'}",
    		ctx
    	});

    	return block;
    }

    // (331:16) {#if currentStepWindow === 'admins-window'}
    function create_if_block_4(ctx) {
    	let adminswindow;
    	let current;
    	adminswindow = new AdminsWindow({ $$inline: true });
    	adminswindow.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(adminswindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(adminswindow, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(adminswindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(adminswindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(adminswindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(331:16) {#if currentStepWindow === 'admins-window'}",
    		ctx
    	});

    	return block;
    }

    // (334:16) {#if currentStepWindow === 'tags-window'}
    function create_if_block_3$2(ctx) {
    	let tagswindow;
    	let current;
    	tagswindow = new TagsWindow({ $$inline: true });
    	tagswindow.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(tagswindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tagswindow, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagswindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagswindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tagswindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(334:16) {#if currentStepWindow === 'tags-window'}",
    		ctx
    	});

    	return block;
    }

    // (337:16) {#if currentStepWindow === 'access-window'}
    function create_if_block_2$3(ctx) {
    	let accesswindow;
    	let current;
    	accesswindow = new AccessWindow({ $$inline: true });
    	accesswindow.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(accesswindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(accesswindow, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accesswindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accesswindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(accesswindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(337:16) {#if currentStepWindow === 'access-window'}",
    		ctx
    	});

    	return block;
    }

    // (340:16) {#if currentStepWindow === 'tools-window'}
    function create_if_block_1$d(ctx) {
    	let toolswindow;
    	let current;
    	toolswindow = new ToolsWindow({ $$inline: true });
    	toolswindow.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(toolswindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toolswindow, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toolswindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toolswindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toolswindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(340:16) {#if currentStepWindow === 'tools-window'}",
    		ctx
    	});

    	return block;
    }

    // (343:16) {#if currentStepWindow === 'import-window'}
    function create_if_block$o(ctx) {
    	let importwindow;
    	let current;
    	importwindow = new ImportWindow({ $$inline: true });
    	importwindow.$on("goToMenuItem", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(importwindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(importwindow, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(importwindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(importwindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(importwindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(343:16) {#if currentStepWindow === 'import-window'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let main;
    	let mainheader;
    	let t0;
    	let div4;
    	let div3;
    	let div2;
    	let button0;
    	let t1;
    	let div0;
    	let heading;
    	let t2;
    	let div1;
    	let button1;
    	let raw0_value = translations[/*LANG*/ ctx[1]]?.admin?.menu_1 + "";
    	let t3;
    	let button2;
    	let raw1_value = translations[/*LANG*/ ctx[1]]?.admin?.menu_2 + "";
    	let t4;
    	let button3;
    	let raw2_value = translations[/*LANG*/ ctx[1]]?.admin?.menu_3 + "";
    	let t5;
    	let button4;
    	let raw3_value = translations[/*LANG*/ ctx[1]]?.admin?.menu_4 + "";
    	let t6;
    	let button5;
    	let raw4_value = translations[/*LANG*/ ctx[1]]?.admin?.menu_5 + "";
    	let t7;
    	let button6;
    	let raw5_value = translations[/*LANG*/ ctx[1]]?.admin?.menu_6 + "";
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let current;
    	let mounted;
    	let dispose;
    	mainheader = new MainHeader({ $$inline: true });

    	heading = new Heading({
    			props: {
    				heading: translations[/*LANG*/ ctx[1]]?.admin?.heading
    			},
    			$$inline: true
    		});

    	let if_block0 = /*currentStepWindow*/ ctx[0] === "analytics-window" && create_if_block_5(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "admins-window" && create_if_block_4(ctx);
    	let if_block2 = /*currentStepWindow*/ ctx[0] === "tags-window" && create_if_block_3$2(ctx);
    	let if_block3 = /*currentStepWindow*/ ctx[0] === "access-window" && create_if_block_2$3(ctx);
    	let if_block4 = /*currentStepWindow*/ ctx[0] === "tools-window" && create_if_block_1$d(ctx);
    	let if_block5 = /*currentStepWindow*/ ctx[0] === "import-window" && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(mainheader.$$.fragment);
    			t0 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			button0 = element("button");
    			t1 = space();
    			div0 = element("div");
    			create_component(heading.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			button1 = element("button");
    			t3 = space();
    			button2 = element("button");
    			t4 = space();
    			button3 = element("button");
    			t5 = space();
    			button4 = element("button");
    			t6 = space();
    			button5 = element("button");
    			t7 = space();
    			button6 = element("button");
    			t8 = space();
    			if (if_block0) if_block0.c();
    			t9 = space();
    			if (if_block1) if_block1.c();
    			t10 = space();
    			if (if_block2) if_block2.c();
    			t11 = space();
    			if (if_block3) if_block3.c();
    			t12 = space();
    			if (if_block4) if_block4.c();
    			t13 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(button0, "class", "step-back svelte-l0y7");
    			add_location(button0, file$X, 283, 16, 8215);
    			attr_dev(div0, "class", "mb-15");
    			add_location(div0, file$X, 284, 16, 8283);
    			attr_dev(button1, "class", "admin-menu__item active svelte-l0y7");
    			attr_dev(button1, "data-step", "analytics-window");
    			add_location(button1, file$X, 289, 20, 8465);
    			attr_dev(button2, "class", "admin-menu__item svelte-l0y7");
    			attr_dev(button2, "data-step", "admins-window");
    			add_location(button2, file$X, 295, 20, 8768);
    			attr_dev(button3, "class", "admin-menu__item svelte-l0y7");
    			attr_dev(button3, "data-step", "tags-window");
    			add_location(button3, file$X, 301, 20, 9061);
    			attr_dev(button4, "class", "admin-menu__item svelte-l0y7");
    			attr_dev(button4, "data-step", "access-window");
    			add_location(button4, file$X, 307, 20, 9352);
    			attr_dev(button5, "class", "admin-menu__item svelte-l0y7");
    			attr_dev(button5, "data-step", "tools-window");
    			add_location(button5, file$X, 313, 20, 9645);
    			attr_dev(button6, "class", "admin-menu__item svelte-l0y7");
    			attr_dev(button6, "data-step", "import-window");
    			add_location(button6, file$X, 319, 20, 9937);
    			attr_dev(div1, "class", "admin-menu svelte-l0y7");
    			add_location(div1, file$X, 288, 16, 8420);
    			attr_dev(div2, "class", "admin-center-block__inner svelte-l0y7");
    			add_location(div2, file$X, 282, 12, 8159);
    			attr_dev(div3, "class", "admin-center-block svelte-l0y7");
    			add_location(div3, file$X, 281, 8, 8114);
    			attr_dev(div4, "class", "wrap-admin-center-block svelte-l0y7");
    			add_location(div4, file$X, 280, 4, 8068);
    			add_location(main, file$X, 278, 0, 8038);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(mainheader, main, null);
    			append_dev(main, t0);
    			append_dev(main, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			mount_component(heading, div0, null);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, button1);
    			button1.innerHTML = raw0_value;
    			append_dev(div1, t3);
    			append_dev(div1, button2);
    			button2.innerHTML = raw1_value;
    			append_dev(div1, t4);
    			append_dev(div1, button3);
    			button3.innerHTML = raw2_value;
    			append_dev(div1, t5);
    			append_dev(div1, button4);
    			button4.innerHTML = raw3_value;
    			append_dev(div1, t6);
    			append_dev(div1, button5);
    			button5.innerHTML = raw4_value;
    			append_dev(div1, t7);
    			append_dev(div1, button6);
    			button6.innerHTML = raw5_value;
    			append_dev(div2, t8);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t9);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t10);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t11);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(div2, t12);
    			if (if_block4) if_block4.m(div2, null);
    			append_dev(div2, t13);
    			if (if_block5) if_block5.m(div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*back*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button2, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button3, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button4, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button5, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button6, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "analytics-window") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div2, t9);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "admins-window") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t10);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "tags-window") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, t11);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "access-window") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div2, t12);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "tools-window") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$d(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div2, t13);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "import-window") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block$o(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div2, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mainheader.$$.fragment, local);
    			transition_in(heading.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mainheader.$$.fragment, local);
    			transition_out(heading.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(mainheader);
    			destroy_component(heading);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("StepsAdminWindow", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let currentStepWindow = "analytics-window";

    	//let previousStepWindow;
    	//TODO: Need to remove
    	// currentStepWindow = 'admins-window';
    	// Define what step should be displayed
    	const windowHandler = event => {
    		$$invalidate(0, currentStepWindow = event.target.dataset.step);
    		let elementsMenu = document.querySelectorAll(".admin-menu__item");

    		elementsMenu.forEach(function (el) {
    			el.classList.remove("active");
    		});

    		event.target.classList.add("active");
    	};

    	const back = () => {
    		
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<StepsAdminWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		MainHeader,
    		Heading,
    		AnalyticsWindow,
    		AdminsWindow,
    		TagsWindow,
    		AccessWindow,
    		ToolsWindow,
    		ImportWindow,
    		dispatch,
    		LANG,
    		currentStepWindow,
    		windowHandler,
    		back
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, LANG, windowHandler, back];
    }

    class StepsAdminWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StepsAdminWindow",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    const feed = [
    	{
    		"id": 0,
    		"parent_post_id": null,
    		"children_post_ids": [3],
    		"avatar_url" : '',
    		"user_name" : 'Lao Wade Zero',
    		"user_id" : 16126,
    		"post_date" : 1612694133,
    		"comment" : "Scelerisque purus semper eget duis at tellus at. A lacus vestibulum sed arcu. Diam vel quam elementum pulvinar etiam non quam lacus suspendisse. Vitae auctor eu augue ut lectus arcu bibendum. Tortor condimentum lacinia quis vel eros. Ipsum dolor sit amet consectetur adipiscing elit duis tristique molestie nunc non blandit nulla.",
    		"tags" : ['SaaS'],
    	},
    	{
    		"id": 1,
    		"parent_post_id": null,
    		"children_post_ids": [4,5],
    		"avatar_url" : 'https://images.pexels.com/photos/2804282/pexels-photo-2804282.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260',
    		"user_name" : 'Lady Chen',
    		"user_id" : 16128,
    		"post_date" : 151264233,
    		"comment" : "222Scelerisque purus semper eget duis at tellus at. A lacus vestibulum sed arcu. Diam vel quam elementum pulvinar etiam non quam lacus suspendisse. Vitae auctor eu augue ut lectus arcu bibendum. Tortor condimentum lacinia quis vel eros. Ipsum dolor sit amet consectetur adipiscing elit duis tristique molestie nunc non blandit nulla.",
    		"tags" : ['CEO', 'SaaS'],
    	},
    	{
    		"id": 2,
    		"parent_post_id": null,
    		"children_post_ids": [],
    		"avatar_url" : 'https://images.pexels.com/photos/2804282/pexels-photo-2804282.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260',
    		"user_name" : 'Test Parent',
    		"user_id" : 16129,
    		"post_date" : 151264233,
    		"comment" : "222Scelerisque purus semper eget duis at tellus at. A lacus vestibulum sed arcu. Diam vel quam elementum pulvinar etiam non quam lacus suspendisse. Vitae auctor eu augue ut lectus arcu bibendum. Tortor condimentum lacinia quis vel eros. Ipsum dolor sit amet consectetur adipiscing elit duis tristique molestie nunc non blandit nulla.",
    		"tags" : ['CEO', 'SaaS'],
    	},
    	{
    		"id": 3,
    		"parent_post_id": 0,
    		"children_post_ids": [],
    		"avatar_url" : '',
    		"user_name" : 'Lao Wade11(child)',
    		"user_id" : 16121,
    		"post_date" : 1612870330,
    		"comment" : "Scelerisque purus semper eget duis at tellus at. A lacus vestibulum sed arcu. Diam vel quam elementum pulvinar etiam non quam ",
    		"tags" : [],
    	},
    	{
    		"id": 4,
    		"parent_post_id": 1,
    		"children_post_ids": [],
    		"avatar_url" : '',
    		"user_name" : 'Lao Wade 5(child)',
    		"user_id" : 16156,
    		"post_date" : 1612614233,
    		"comment" : "Purus semper eget duis at tellus at. A lacus vestibulum sed arcu. Diam vel quam elementum pulvinar etiam non quam ",
    		"tags" : [],
    	},
    	{
    		"id": 5,
    		"parent_post_id": 1,
    		"children_post_ids": [],
    		"avatar_url" : '',
    		"user_name" : 'Lao Wade 3(child)',
    		"user_id" : 16326,
    		"post_date" : 1612611233,
    		"comment" : "Lorine Purus semper eget duis at tellus at. A lacus vestibulum sed arcu. Diam vel quam elementum pulvinar etiam non quam ",
    		"tags" : [],
    	},
    ];

    /* src/components/news-feed/Avatar.svelte generated by Svelte v3.32.1 */

    const file$Y = "src/components/news-feed/Avatar.svelte";

    // (36:18) 
    function create_if_block_1$e(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = /*url*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "user-avatar");
    			attr_dev(img, "class", "svelte-rwu5r2");
    			add_location(img, file$Y, 36, 8, 768);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*url*/ 1 && img.src !== (img_src_value = /*url*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(36:18) ",
    		ctx
    	});

    	return block;
    }

    // (34:4) {#if initials }
    function create_if_block$p(ctx) {
    	let t_value = /*initials*/ ctx[1][0].charAt(0) + /*initials*/ ctx[1][1].charAt(0) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(34:4) {#if initials }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*initials*/ ctx[1]) return create_if_block$p;
    		if (/*url*/ ctx[0]) return create_if_block_1$e;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "avatar svelte-rwu5r2");
    			add_location(div, file$Y, 32, 0, 643);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Avatar", slots, []);
    	let { url = "" } = $$props;
    	let { name = "" } = $$props;
    	let initials = url ? "" : name ? name.split(" ") : "XX";
    	const writable_props = ["url", "name"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Avatar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    	};

    	$$self.$capture_state = () => ({ url, name, initials });

    	$$self.$inject_state = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("initials" in $$props) $$invalidate(1, initials = $$props.initials);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [url, initials, name];
    }

    class Avatar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { url: 0, name: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Avatar",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get url() {
    		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-emoji-picker/src/index.svelte generated by Svelte v3.32.1 */
    const file$Z = "node_modules/svelte-emoji-picker/src/index.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (27:1) {#each emojis as emoji}
    function create_each_block$f(ctx) {
    	let button;
    	let t0_value = /*emoji*/ ctx[5] + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "class", "emoji svelte-17etvkn");
    			add_location(button, file$Z, 27, 2, 953);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*select*/ ctx[2](/*emoji*/ ctx[5]))) /*select*/ ctx[2](/*emoji*/ ctx[5]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*emojis*/ 1 && t0_value !== (t0_value = /*emoji*/ ctx[5] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(27:1) {#each emojis as emoji}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let div;
    	let each_value = /*emojis*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "panel");
    			set_style(div, "font-size", /*fontSize*/ ctx[1]);
    			add_location(div, file$Z, 25, 0, 876);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*select, emojis*/ 5) {
    				each_value = /*emojis*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*fontSize*/ 2) {
    				set_style(div, "font-size", /*fontSize*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Src", slots, []);

    	let { emojis = [
    		"✌️",
    		"😂",
    		"😝",
    		"😁",
    		"😱",
    		"👉",
    		"🙌",
    		"🍻",
    		"🔥",
    		"🌈",
    		"☀️",
    		"🎈",
    		"🌹",
    		"💄",
    		"🎀",
    		"⚽",
    		"🎾",
    		"🏁",
    		"😡",
    		"👿",
    		"🐻",
    		"🐶",
    		"🐬",
    		"🐟",
    		"🍀",
    		"👀",
    		"🚗",
    		"🍎",
    		"💝",
    		"💙",
    		"👌",
    		"❤",
    		"😍",
    		"😉",
    		"😓",
    		"😳",
    		"💪",
    		"💩",
    		"🍸",
    		"🔑",
    		"💖",
    		"🌟",
    		"🎉",
    		"🌺",
    		"🎶",
    		"👠",
    		"🏈",
    		"⚾",
    		"🏆",
    		"👽",
    		"💀",
    		"🐵",
    		"🐮",
    		"🐩",
    		"🐎",
    		"💣",
    		"👃",
    		"👂",
    		"🍓",
    		"💘",
    		"💜",
    		"👊",
    		"💋",
    		"😘",
    		"😜",
    		"😵",
    		"🙏",
    		"👋",
    		"🚽",
    		"💃",
    		"💎",
    		"🚀",
    		"🌙",
    		"🎁",
    		"⛄",
    		"🌊",
    		"⛵",
    		"🏀",
    		"🎱",
    		"💰",
    		"👶",
    		"👸",
    		"🐰",
    		"🐷",
    		"🐍",
    		"🐫",
    		"🔫",
    		"👄",
    		"🚲",
    		"🍉",
    		"💛",
    		"💚"
    	] } = $$props;

    	let { value = "" } = $$props;
    	let { fontSize = "30px" } = $$props;
    	const select = num => () => $$invalidate(3, value += num);
    	const clear = () => $$invalidate(3, value = "");
    	const writable_props = ["emojis", "value", "fontSize"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Src> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("emojis" in $$props) $$invalidate(0, emojis = $$props.emojis);
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("fontSize" in $$props) $$invalidate(1, fontSize = $$props.fontSize);
    	};

    	$$self.$capture_state = () => ({
    		emojis,
    		value,
    		fontSize,
    		createEventDispatcher,
    		select,
    		clear
    	});

    	$$self.$inject_state = $$props => {
    		if ("emojis" in $$props) $$invalidate(0, emojis = $$props.emojis);
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("fontSize" in $$props) $$invalidate(1, fontSize = $$props.fontSize);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [emojis, fontSize, select, value];
    }

    class Src extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, { emojis: 0, value: 3, fontSize: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Src",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get emojis() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set emojis(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fontSize() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fontSize(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/news-feed/CommentForm.svelte generated by Svelte v3.32.1 */
    const file$_ = "src/components/news-feed/CommentForm.svelte";

    // (441:12) {#if showCheckbox !== 'false'}
    function create_if_block_1$f(ctx) {
    	let div;
    	let input;
    	let t;
    	let p;
    	let raw_value = translations[/*LANG*/ ctx[4]]?.new_comment?.anonymously_label + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			p = element("p");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", "post-anonymously");
    			attr_dev(input, "class", "js-post-anonymously svelte-14ycaga");
    			add_location(input, file$_, 442, 20, 19776);
    			attr_dev(p, "class", "comment-block__anonymously-label svelte-14ycaga");
    			add_location(p, file$_, 443, 20, 19874);
    			attr_dev(div, "class", "comment-block__anonymously-wrapper svelte-14ycaga");
    			add_location(div, file$_, 441, 16, 19707);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			append_dev(div, t);
    			append_dev(div, p);
    			p.innerHTML = raw_value;
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(441:12) {#if showCheckbox !== 'false'}",
    		ctx
    	});

    	return block;
    }

    // (457:8) {#if emoji.haveEmoji}
    function create_if_block$q(ctx) {
    	let div;
    	let emojipicker;
    	let updating_value;
    	let current;

    	function emojipicker_value_binding(value) {
    		/*emojipicker_value_binding*/ ctx[9].call(null, value);
    	}

    	let emojipicker_props = {};

    	if (/*emojiElem*/ ctx[3] !== void 0) {
    		emojipicker_props.value = /*emojiElem*/ ctx[3];
    	}

    	emojipicker = new Src({ props: emojipicker_props, $$inline: true });
    	binding_callbacks.push(() => bind(emojipicker, "value", emojipicker_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(emojipicker.$$.fragment);
    			attr_dev(div, "class", "emoji svelte-14ycaga");
    			add_location(div, file$_, 457, 12, 20400);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(emojipicker, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const emojipicker_changes = {};

    			if (!updating_value && dirty & /*emojiElem*/ 8) {
    				updating_value = true;
    				emojipicker_changes.value = /*emojiElem*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			emojipicker.$set(emojipicker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(emojipicker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(emojipicker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(emojipicker);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(457:8) {#if emoji.haveEmoji}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let div8;
    	let avatar;
    	let t0;
    	let div7;
    	let form;
    	let input0;
    	let t1;
    	let div6;
    	let input1;
    	let t2;
    	let div5;
    	let div0;
    	let textarea;
    	let t3;
    	let div1;
    	let t4;
    	let div4;
    	let div2;
    	let input2;
    	let t5;
    	let div3;
    	let svg;
    	let path;
    	let t6;
    	let t7;
    	let btnstandart;
    	let t8;
    	let div8_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	avatar = new Avatar({
    			props: {
    				url: /*userData*/ ctx[5]?.avatar_url,
    				name: /*userData*/ ctx[5]?.user_name
    			},
    			$$inline: true
    		});

    	let if_block0 = /*showCheckbox*/ ctx[1] !== "false" && create_if_block_1$f(ctx);

    	btnstandart = new BtnStandart({
    			props: {
    				role: "select-audience-popup",
    				text: translations[/*LANG*/ ctx[4]].new_comment.select_audience,
    				className: "comment-block__select-audience-btn",
    				color: "purple"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*click_handler*/ ctx[8]);
    	let if_block1 = /*emoji*/ ctx[2].haveEmoji && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			create_component(avatar.$$.fragment);
    			t0 = space();
    			div7 = element("div");
    			form = element("form");
    			input0 = element("input");
    			t1 = space();
    			div6 = element("div");
    			input1 = element("input");
    			t2 = space();
    			div5 = element("div");
    			div0 = element("div");
    			textarea = element("textarea");
    			t3 = space();
    			div1 = element("div");
    			t4 = space();
    			div4 = element("div");
    			div2 = element("div");
    			input2 = element("input");
    			t5 = space();
    			div3 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t6 = space();
    			if (if_block0) if_block0.c();
    			t7 = space();
    			create_component(btnstandart.$$.fragment);
    			t8 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(input0, "type", "hidden");
    			input0.value = /*userData*/ ctx[5].id;
    			attr_dev(input0, "name", "community-id");
    			add_location(input0, file$_, 410, 8, 17169);
    			attr_dev(input1, "type", "hidden");
    			input1.value = /*userData*/ ctx[5].id;
    			attr_dev(input1, "name", "user-id");
    			add_location(input1, file$_, 413, 12, 17297);
    			attr_dev(textarea, "data-autoresize", "");
    			attr_dev(textarea, "class", "form-control__input-text svelte-14ycaga");
    			add_location(textarea, file$_, 417, 20, 17513);
    			attr_dev(div0, "class", "form-control mb-15 no-margin no-max-width");
    			add_location(div0, file$_, 416, 16, 17437);
    			attr_dev(div1, "class", "comment-block__emoji-btn js-emoji-btn svelte-14ycaga");
    			add_location(div1, file$_, 420, 16, 17647);
    			attr_dev(input2, "type", "file");
    			attr_dev(input2, "name", "user-new-comment-image[]");
    			attr_dev(input2, "class", "comment-block__image svelte-14ycaga");
    			attr_dev(input2, "accept", "image/*");
    			input2.multiple = true;
    			add_location(input2, file$_, 424, 24, 17877);
    			attr_dev(div2, "class", "comment-block__image-input-wrapper svelte-14ycaga");
    			add_location(div2, file$_, 423, 20, 17804);
    			attr_dev(path, "d", "M14.7109 4.21094C15.4228 4.21094 16 4.78805 16 5.5C15.9321 7.2099 13.4895 7.20943 13.4219 5.5C13.4219 4.78805 13.999 4.21094 14.7109 4.21094ZM20.2812 16.4878V3.4375C20.2812 2.48978 19.5102 1.71875 18.5625 1.71875H3.4375C2.48978 1.71875 1.71875 2.48978 1.71875 3.4375V11.0609L4.89173 7.8879C5.8969 6.88269 7.53251 6.88269 8.53776 7.8879L13.1113 12.4614L14.0754 11.4973C15.0807 10.4921 16.7162 10.4921 17.7215 11.4973L21.7483 15.5241C21.9095 15.6853 22 15.9039 22 16.1318V18.5625C22 20.4579 20.4579 22 18.5625 22H3.4375C1.54206 22 0 20.4579 0 18.5625V3.4375C0 1.54206 1.54206 0 3.4375 0H18.5625C20.4579 0 22 1.54206 22 3.4375V16.4878C21.9546 17.628 20.3262 17.6272 20.2812 16.4878ZM1.71875 13.4915V18.5625C1.71875 19.5102 2.48978 20.2812 3.4375 20.2812H18.5625C19.5102 20.2812 20.2812 19.5102 20.2812 18.5625V16.4878L16.5061 12.7126C16.1711 12.3776 15.6258 12.3776 15.2908 12.7126L11.0375 16.9659C10.702 17.3015 10.1579 17.3015 9.82218 16.9659C9.48656 16.6303 9.4866 16.0862 9.82218 15.7506L11.8959 13.6768L7.32235 9.10327C7.00249 8.76988 6.42692 8.76988 6.10706 9.10327L1.71875 13.4915Z");
    			attr_dev(path, "fill", "#C8C8C8");
    			add_location(path, file$_, 435, 28, 18435);
    			attr_dev(svg, "width", "22");
    			attr_dev(svg, "height", "22");
    			attr_dev(svg, "viewBox", "0 0 22 22");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "class", "svelte-14ycaga");
    			add_location(svg, file$_, 432, 24, 18253);
    			attr_dev(div3, "class", "comment-block__image-uploader-btn svelte-14ycaga");
    			add_location(div3, file$_, 431, 20, 18181);
    			attr_dev(div4, "class", "comment-block__image-uploader svelte-14ycaga");
    			add_location(div4, file$_, 422, 16, 17740);
    			attr_dev(div5, "class", "comment-block__input-wrapper js-emoji svelte-14ycaga");
    			add_location(div5, file$_, 414, 12, 17368);
    			attr_dev(div6, "class", "comment-block__wrapper-block svelte-14ycaga");
    			add_location(div6, file$_, 412, 8, 17242);
    			attr_dev(form, "name", "add-comment-form");
    			attr_dev(form, "method", "post");
    			attr_dev(form, "enctype", "multipart/form-data");
    			attr_dev(form, "class", "comment-block__form svelte-14ycaga");
    			add_location(form, file$_, 405, 8, 17027);
    			attr_dev(div7, "class", "emoji-wrap svelte-14ycaga");
    			add_location(div7, file$_, 404, 4, 16994);

    			attr_dev(div8, "class", div8_class_value = "comment-block__wrapper " + (/*className*/ ctx[0] ? /*className*/ ctx[0] : "") + " " + (/*showCheckbox*/ ctx[1] === "false"
    			? "comment-block__wrapper-mod"
    			: "js-comment-main") + " svelte-14ycaga");

    			add_location(div8, file$_, 401, 0, 16772);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			mount_component(avatar, div8, null);
    			append_dev(div8, t0);
    			append_dev(div8, div7);
    			append_dev(div7, form);
    			append_dev(form, input0);
    			append_dev(form, t1);
    			append_dev(form, div6);
    			append_dev(div6, input1);
    			append_dev(div6, t2);
    			append_dev(div6, div5);
    			append_dev(div5, div0);
    			append_dev(div0, textarea);
    			set_input_value(textarea, /*emojiElem*/ ctx[3]);
    			append_dev(div5, t3);
    			append_dev(div5, div1);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, input2);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, svg);
    			append_dev(svg, path);
    			append_dev(div6, t6);
    			if (if_block0) if_block0.m(div6, null);
    			append_dev(form, t7);
    			mount_component(btnstandart, form, null);
    			append_dev(div7, t8);
    			if (if_block1) if_block1.m(div7, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[7]),
    					listen_dev(div1, "click", /*toggle*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*emojiElem*/ 8) {
    				set_input_value(textarea, /*emojiElem*/ ctx[3]);
    			}

    			if (/*showCheckbox*/ ctx[1] !== "false") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$f(ctx);
    					if_block0.c();
    					if_block0.m(div6, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*emoji*/ ctx[2].haveEmoji) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*emoji*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$q(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div7, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*className, showCheckbox*/ 3 && div8_class_value !== (div8_class_value = "comment-block__wrapper " + (/*className*/ ctx[0] ? /*className*/ ctx[0] : "") + " " + (/*showCheckbox*/ ctx[1] === "false"
    			? "comment-block__wrapper-mod"
    			: "js-comment-main") + " svelte-14ycaga")) {
    				attr_dev(div8, "class", div8_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(avatar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(avatar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(avatar);
    			if (if_block0) if_block0.d();
    			destroy_component(btnstandart);
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function addAutoResize() {
    	document.querySelectorAll("[data-autoresize]").forEach(function (element) {
    		//element.style.boxSizing = 'border-box';
    		let offset = element.offsetHeight - element.clientHeight;

    		element.addEventListener("input", function (event) {
    			//event.target.style.height = 'auto';
    			event.target.style.height = event.target.scrollHeight + offset + "px";
    		});

    		element.removeAttribute("data-autoresize");
    	});
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CommentForm", slots, []);

    	const SEARCH_TAGS_ENDPOINT = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.SEARCH_TAGS_ENDPOINT;

    	const dispatch = createEventDispatcher();

    	// Getting app lang
    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	//TODO: Need to take somewhere user avatar image, name, user_id
    	let userData = {
    		id: 1233,
    		avatar_url: "",
    		user_name: "Jogn Doe"
    	};

    	let { className = "" } = $$props;
    	let { showCheckbox = true } = $$props;
    	let emoji = { haveEmoji: false };

    	function toggle() {
    		$$invalidate(2, emoji.haveEmoji = !emoji.haveEmoji, emoji);
    	}

    	let emojiElem = "";

    	setTimeout(
    		function () {
    			addAutoResize();
    		},
    		1000
    	);

    	const writable_props = ["className", "showCheckbox"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CommentForm> was created with unknown prop '${key}'`);
    	});

    	function textarea_input_handler() {
    		emojiElem = this.value;
    		$$invalidate(3, emojiElem);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function emojipicker_value_binding(value) {
    		emojiElem = value;
    		$$invalidate(3, emojiElem);
    	}

    	$$self.$$set = $$props => {
    		if ("className" in $$props) $$invalidate(0, className = $$props.className);
    		if ("showCheckbox" in $$props) $$invalidate(1, showCheckbox = $$props.showCheckbox);
    	};

    	$$self.$capture_state = () => ({
    		Avatar,
    		translations,
    		createEventDispatcher,
    		EmojiPicker: Src,
    		BtnStandart,
    		SEARCH_TAGS_ENDPOINT,
    		dispatch,
    		LANG,
    		userData,
    		className,
    		showCheckbox,
    		emoji,
    		toggle,
    		emojiElem,
    		addAutoResize
    	});

    	$$self.$inject_state = $$props => {
    		if ("userData" in $$props) $$invalidate(5, userData = $$props.userData);
    		if ("className" in $$props) $$invalidate(0, className = $$props.className);
    		if ("showCheckbox" in $$props) $$invalidate(1, showCheckbox = $$props.showCheckbox);
    		if ("emoji" in $$props) $$invalidate(2, emoji = $$props.emoji);
    		if ("emojiElem" in $$props) $$invalidate(3, emojiElem = $$props.emojiElem);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		className,
    		showCheckbox,
    		emoji,
    		emojiElem,
    		LANG,
    		userData,
    		toggle,
    		textarea_input_handler,
    		click_handler,
    		emojipicker_value_binding
    	];
    }

    class CommentForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, { className: 0, showCheckbox: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CommentForm",
    			options,
    			id: create_fragment$$.name
    		});
    	}

    	get className() {
    		throw new Error("<CommentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<CommentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showCheckbox() {
    		throw new Error("<CommentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showCheckbox(value) {
    		throw new Error("<CommentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/news-feed/FeedItem.svelte generated by Svelte v3.32.1 */
    const file$$ = "src/components/news-feed/FeedItem.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (177:8) {#if !isChild}
    function create_if_block_3$3(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*data*/ ctx[0]?.user_name + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*timeInstance*/ ctx[3].format(Date.now() - /*data*/ ctx[0]?.post_date) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			attr_dev(div0, "class", "feed-item__name svelte-1sllxin");
    			add_location(div0, file$$, 178, 16, 5859);
    			attr_dev(div1, "class", "feed-item__post-date svelte-1sllxin");
    			add_location(div1, file$$, 179, 16, 5928);
    			attr_dev(div2, "class", "feed-item__header-meta svelte-1sllxin");
    			add_location(div2, file$$, 177, 12, 5806);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*data*/ ctx[0]?.user_name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*timeInstance, data*/ 9 && t2_value !== (t2_value = /*timeInstance*/ ctx[3].format(Date.now() - /*data*/ ctx[0]?.post_date) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(177:8) {#if !isChild}",
    		ctx
    	});

    	return block;
    }

    // (199:8) {#if isChild}
    function create_if_block_2$4(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*data*/ ctx[0]?.user_name + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*timeInstance*/ ctx[3].format(/*data*/ ctx[0]?.post_date * 1000) + "";
    	let t2;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			attr_dev(div0, "class", "feed-item__name svelte-1sllxin");
    			add_location(div0, file$$, 200, 16, 6957);
    			attr_dev(div1, "class", "feed-item__post-date svelte-1sllxin");
    			add_location(div1, file$$, 201, 16, 7026);
    			attr_dev(div2, "class", "feed-item__header-meta svelte-1sllxin");
    			add_location(div2, file$$, 199, 12, 6904);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*data*/ ctx[0]?.user_name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*timeInstance, data*/ 9 && t2_value !== (t2_value = /*timeInstance*/ ctx[3].format(/*data*/ ctx[0]?.post_date * 1000) + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(199:8) {#if isChild}",
    		ctx
    	});

    	return block;
    }

    // (211:4) {#if !isChild}
    function create_if_block$r(ctx) {
    	let div1;
    	let div0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let each_value = /*data*/ ctx[0]?.tags;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[12];
    	validate_each_keys(ctx, each_value, get_each_context$g, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$g(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
    	}

    	let if_block = /*data*/ ctx[0]?.children_post_ids.length && create_if_block_1$g(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "feed-item__tags svelte-1sllxin");
    			add_location(div0, file$$, 212, 12, 7294);
    			attr_dev(div1, "class", "feed-item__footer-meta svelte-1sllxin");
    			add_location(div1, file$$, 211, 8, 7245);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div1, t);
    			if (if_block) if_block.m(div1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1) {
    				each_value = /*data*/ ctx[0]?.tags;
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$g, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, destroy_block, create_each_block$g, null, get_each_context$g);
    			}

    			if (/*data*/ ctx[0]?.children_post_ids.length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$g(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(211:4) {#if !isChild}",
    		ctx
    	});

    	return block;
    }

    // (214:16) {#each  data?.tags as tag,index (index)}
    function create_each_block$g(key_1, ctx) {
    	let button;
    	let t0;
    	let t1_value = /*tag*/ ctx[10] + "";
    	let t1;
    	let button_data_tag_value;

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			button = element("button");
    			t0 = text("#");
    			t1 = text(t1_value);
    			attr_dev(button, "class", "feed-item__tags-button svelte-1sllxin");
    			attr_dev(button, "data-tag", button_data_tag_value = /*tag*/ ctx[10].toLowerCase());
    			add_location(button, file$$, 214, 20, 7401);
    			this.first = button;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*data*/ 1 && t1_value !== (t1_value = /*tag*/ ctx[10] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*data*/ 1 && button_data_tag_value !== (button_data_tag_value = /*tag*/ ctx[10].toLowerCase())) {
    				attr_dev(button, "data-tag", button_data_tag_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(214:16) {#each  data?.tags as tag,index (index)}",
    		ctx
    	});

    	return block;
    }

    // (219:12) {#if (data?.children_post_ids).length }
    function create_if_block_1$g(ctx) {
    	let div;

    	let t_value = `
                        ${translations[/*LANG*/ ctx[6]]?.feed[/*mode*/ ctx[4]]}
                        ${/*data*/ ctx[0]?.children_post_ids.length
	? /*data*/ ctx[0]?.children_post_ids.length
	: 0}
                        ${/*data*/ ctx[0]?.children_post_ids.length > 1
	? translations[/*LANG*/ ctx[6]]?.feed.comments
	: translations[/*LANG*/ ctx[6]]?.feed.comment}
                    ` + "";

    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "feed-item__comment-count svelte-1sllxin");
    			add_location(div, file$$, 219, 16, 7597);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", prevent_default(/*toggleChildComment*/ ctx[7]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*mode, data*/ 17 && t_value !== (t_value = `
                        ${translations[/*LANG*/ ctx[6]]?.feed[/*mode*/ ctx[4]]}
                        ${/*data*/ ctx[0]?.children_post_ids.length
			? /*data*/ ctx[0]?.children_post_ids.length
			: 0}
                        ${/*data*/ ctx[0]?.children_post_ids.length > 1
			? translations[/*LANG*/ ctx[6]]?.feed.comments
			: translations[/*LANG*/ ctx[6]]?.feed.comment}
                    ` + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(219:12) {#if (data?.children_post_ids).length }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let div3;
    	let div1;
    	let avatar;
    	let t0;
    	let t1;
    	let button0;
    	let svg;
    	let ellipse0;
    	let ellipse1;
    	let ellipse2;
    	let t2;
    	let div0;
    	let button1;
    	let t4;
    	let button2;
    	let div0_class_value;
    	let t6;
    	let div2;
    	let t7;
    	let t8_value = /*data*/ ctx[0]?.comment + "";
    	let t8;
    	let t9;
    	let div3_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	avatar = new Avatar({
    			props: {
    				url: /*data*/ ctx[0]?.avatar_url,
    				name: /*data*/ ctx[0]?.user_name
    			},
    			$$inline: true
    		});

    	let if_block0 = !/*isChild*/ ctx[2] && create_if_block_3$3(ctx);
    	let if_block1 = /*isChild*/ ctx[2] && create_if_block_2$4(ctx);
    	let if_block2 = !/*isChild*/ ctx[2] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			create_component(avatar.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			button0 = element("button");
    			svg = svg_element("svg");
    			ellipse0 = svg_element("ellipse");
    			ellipse1 = svg_element("ellipse");
    			ellipse2 = svg_element("ellipse");
    			t2 = space();
    			div0 = element("div");
    			button1 = element("button");
    			button1.textContent = `${translations[/*LANG*/ ctx[6]]?.feed.reply}`;
    			t4 = space();
    			button2 = element("button");
    			button2.textContent = `${translations[/*LANG*/ ctx[6]]?.feed.delete}`;
    			t6 = space();
    			div2 = element("div");
    			if (if_block1) if_block1.c();
    			t7 = space();
    			t8 = text(t8_value);
    			t9 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(ellipse0, "cx", "2.6934");
    			attr_dev(ellipse0, "cy", "2");
    			attr_dev(ellipse0, "rx", "2.01859");
    			attr_dev(ellipse0, "ry", "2");
    			attr_dev(ellipse0, "fill", "black");
    			add_location(ellipse0, file$$, 185, 16, 6276);
    			attr_dev(ellipse1, "cx", "9.75883");
    			attr_dev(ellipse1, "cy", "2");
    			attr_dev(ellipse1, "rx", "2.01859");
    			attr_dev(ellipse1, "ry", "2");
    			attr_dev(ellipse1, "fill", "black");
    			add_location(ellipse1, file$$, 186, 16, 6355);
    			attr_dev(ellipse2, "cx", "16.8233");
    			attr_dev(ellipse2, "cy", "2");
    			attr_dev(ellipse2, "rx", "2.01859");
    			attr_dev(ellipse2, "ry", "2");
    			attr_dev(ellipse2, "fill", "black");
    			add_location(ellipse2, file$$, 187, 16, 6435);
    			attr_dev(svg, "width", "19");
    			attr_dev(svg, "height", "4");
    			attr_dev(svg, "viewBox", "0 0 19 4");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$$, 184, 12, 6166);
    			attr_dev(button0, "class", "feed-item__comment-menu-toggle svelte-1sllxin");
    			add_location(button0, file$$, 183, 8, 6062);
    			attr_dev(button1, "class", "feed-item__comment-menu-button svelte-1sllxin");
    			add_location(button1, file$$, 192, 12, 6615);
    			attr_dev(button2, "class", "feed-item__comment-menu-button svelte-1sllxin");
    			add_location(button2, file$$, 193, 12, 6716);
    			attr_dev(div0, "class", div0_class_value = "feed-item__comment-menu " + /*commentMenuStatus*/ ctx[5] + " svelte-1sllxin");
    			add_location(div0, file$$, 191, 8, 6545);
    			attr_dev(div1, "class", "feed-item__header svelte-1sllxin");
    			add_location(div1, file$$, 173, 4, 5673);
    			attr_dev(div2, "class", "feed-item__content svelte-1sllxin");
    			add_location(div2, file$$, 197, 4, 6837);
    			attr_dev(div3, "class", div3_class_value = "feed-item " + (/*isChild*/ ctx[2] ? "child-item" : "") + " " + /*customClasses*/ ctx[1] + " svelte-1sllxin");
    			add_location(div3, file$$, 172, 0, 5600);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			mount_component(avatar, div1, null);
    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, button0);
    			append_dev(button0, svg);
    			append_dev(svg, ellipse0);
    			append_dev(svg, ellipse1);
    			append_dev(svg, ellipse2);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			append_dev(div0, button1);
    			append_dev(div0, t4);
    			append_dev(div0, button2);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t7);
    			append_dev(div2, t8);
    			append_dev(div3, t9);
    			if (if_block2) if_block2.m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", prevent_default(/*toggleCommentMenu*/ ctx[8]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const avatar_changes = {};
    			if (dirty & /*data*/ 1) avatar_changes.url = /*data*/ ctx[0]?.avatar_url;
    			if (dirty & /*data*/ 1) avatar_changes.name = /*data*/ ctx[0]?.user_name;
    			avatar.$set(avatar_changes);

    			if (!/*isChild*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$3(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty & /*commentMenuStatus*/ 32 && div0_class_value !== (div0_class_value = "feed-item__comment-menu " + /*commentMenuStatus*/ ctx[5] + " svelte-1sllxin")) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (/*isChild*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$4(ctx);
    					if_block1.c();
    					if_block1.m(div2, t7);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || dirty & /*data*/ 1) && t8_value !== (t8_value = /*data*/ ctx[0]?.comment + "")) set_data_dev(t8, t8_value);

    			if (!/*isChild*/ ctx[2]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$r(ctx);
    					if_block2.c();
    					if_block2.m(div3, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (!current || dirty & /*isChild, customClasses*/ 6 && div3_class_value !== (div3_class_value = "feed-item " + (/*isChild*/ ctx[2] ? "child-item" : "") + " " + /*customClasses*/ ctx[1] + " svelte-1sllxin")) {
    				attr_dev(div3, "class", div3_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(avatar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(avatar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(avatar);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FeedItem", slots, []);
    	const dispatch = createEventDispatcher();

    	// Getting app lang
    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let { data = "" } = $$props;
    	let { customClasses = "" } = $$props;
    	let { isChild = false } = $$props;
    	let { timeInstance = "" } = $$props;
    	let mode = "show";
    	let commentMenuStatus = "hidden";

    	// Show/Hide child posts
    	const toggleChildComment = event => {
    		$$invalidate(4, mode = mode === "show" ? "hide" : "show");

    		dispatch("toggleChild", {
    			isChildShown: mode === "hide" ? "show" : "hide",
    			parent_id: data?.id
    		});
    	};

    	// Show/Hide comment menu
    	const toggleCommentMenu = event => {
    		$$invalidate(5, commentMenuStatus = commentMenuStatus === "hidden" ? "" : "hidden");
    	};

    	const writable_props = ["data", "customClasses", "isChild", "timeInstance"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FeedItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("customClasses" in $$props) $$invalidate(1, customClasses = $$props.customClasses);
    		if ("isChild" in $$props) $$invalidate(2, isChild = $$props.isChild);
    		if ("timeInstance" in $$props) $$invalidate(3, timeInstance = $$props.timeInstance);
    	};

    	$$self.$capture_state = () => ({
    		Avatar,
    		translations,
    		CommentForm,
    		createEventDispatcher,
    		dispatch,
    		LANG,
    		data,
    		customClasses,
    		isChild,
    		timeInstance,
    		mode,
    		commentMenuStatus,
    		toggleChildComment,
    		toggleCommentMenu
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("customClasses" in $$props) $$invalidate(1, customClasses = $$props.customClasses);
    		if ("isChild" in $$props) $$invalidate(2, isChild = $$props.isChild);
    		if ("timeInstance" in $$props) $$invalidate(3, timeInstance = $$props.timeInstance);
    		if ("mode" in $$props) $$invalidate(4, mode = $$props.mode);
    		if ("commentMenuStatus" in $$props) $$invalidate(5, commentMenuStatus = $$props.commentMenuStatus);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		data,
    		customClasses,
    		isChild,
    		timeInstance,
    		mode,
    		commentMenuStatus,
    		LANG,
    		toggleChildComment,
    		toggleCommentMenu
    	];
    }

    class FeedItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
    			data: 0,
    			customClasses: 1,
    			isChild: 2,
    			timeInstance: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FeedItem",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get data() {
    		throw new Error("<FeedItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FeedItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customClasses() {
    		throw new Error("<FeedItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customClasses(value) {
    		throw new Error("<FeedItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isChild() {
    		throw new Error("<FeedItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isChild(value) {
    		throw new Error("<FeedItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get timeInstance() {
    		throw new Error("<FeedItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set timeInstance(value) {
    		throw new Error("<FeedItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class Popup {
    	constructor() {
    		this.body = document.querySelector('body');
    		this.html = document.querySelector('html');
    	}



    	/**
    	 * Force Close All opened popup window
    	 * and clear the traces of an opened popup window
    	 */
    	forceCloseAllPopup() {
    		[...document.querySelectorAll('.popup')].forEach( (item) => {
    			//fadeOut( item );

    			item.classList.remove('opened');

    			const MAIL_SENT_OK_BOX = item.querySelector('.wpcf7-mail-sent-ok');
    			if ( MAIL_SENT_OK_BOX ) {
    				MAIL_SENT_OK_BOX.style.display = 'none';
    			}

    		});

    		this.body.classList.remove('popup-opened');
    		this.html.classList.remove('popup-opened');
    	}



    	/**
    	 * Open selected popup window
    	 * @param popupSelector - css selector of popup that should be opened
    	 * @param timeOut - ms
    	 */
    	openOnePopup(popupSelector = null, timeOut = 1000) {
    		this.forceCloseAllPopup();

    		setTimeout( () => {
    			this.body.classList.add('popup-opened');
    			this.html.classList.add('popup-opened');

    			//fadeIn(document.querySelector(popupSelector));

    			item.classList.add('opened');
    		}, timeOut);
    	}



    	/**
    	 * Opening popup window
    	 */
    	openPopup() {

    		this.body.addEventListener('click', (event) => {

    			if ( ![...event.target.classList].includes('js-open-popup-activator') ) {
    				return false;
    			}

    			event.preventDefault();

    			let el_href = ( event.target.nodeName === 'A' )
    				? event.target.getAttribute('href')
    				: event.target.dataset.href;

    			const POPUP_ELEMENT      = document.querySelector(el_href);
    			this.body.classList.add('popup-opened');
    			this.html.classList.add('popup-opened');

    			//fadeIn( POPUP_ELEMENT );
    			(POPUP_ELEMENT) && POPUP_ELEMENT.classList.add('opened');

    			//POPUP_FORM_INPUT && POPUP_FORM_INPUT.focus();
    		});

    	}



    	/**
    	 * Closing popup window
    	 */
    	closePopup() {
    		this.body.addEventListener('click', (event) => {

    			// Check if user click on close element
    			if ( ![...event.target.classList].includes('js-popup-close')
    				|| event.target.closest('.popup').getAttribute('id') === 'age-popup'

    			) {
    				return false;
    			}

    			event.preventDefault();
    			this.forceCloseAllPopup();

    		});


    		// Checking ESC button for closing opened popup window
    		document.addEventListener('keydown', (event) => {
    			if( event.keyCode === 27 ) {
    				this.forceCloseAllPopup();
    			}
    		});

    	}


    	init() {
    		this.openPopup();
    		this.closePopup();
    	}
    }

    /* src/components/news-feed/ModalWindow.svelte generated by Svelte v3.32.1 */

    const file$10 = "src/components/news-feed/ModalWindow.svelte";

    function create_fragment$11(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div3;
    	let div2;
    	let div1;
    	let t1;
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			button = element("button");
    			button.textContent = "close popup";
    			attr_dev(div0, "class", "my_overlay js-popup-close svelte-2ab0t8");
    			attr_dev(div0, "data-role", "popup-close");
    			add_location(div0, file$10, 307, 4, 9294);
    			attr_dev(div1, "class", "popup__body");
    			add_location(div1, file$10, 314, 12, 9494);
    			attr_dev(div2, "class", "in js-popup-inner svelte-2ab0t8");
    			add_location(div2, file$10, 312, 8, 9447);
    			attr_dev(button, "class", "popup-close js-popup-close svelte-2ab0t8");
    			attr_dev(button, "data-role", "popup-close");
    			add_location(button, file$10, 318, 8, 9596);
    			attr_dev(div3, "class", "popup-wrapper-inner svelte-2ab0t8");
    			add_location(div3, file$10, 311, 4, 9404);
    			attr_dev(div4, "class", "popup opened svelte-2ab0t8");
    			add_location(div4, file$10, 306, 0, 9262);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			append_dev(div3, t1);
    			append_dev(div3, button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[5], false, false, false),
    					listen_dev(button, "click", /*click_handler_1*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ModalWindow", slots, ['default']);
    	const dispatch = createEventDispatcher();

    	//const LANG = {"env":{"isProd":false,"CURRENT_LANG":"en","DOMAIN_FOR_REQUEST":"https://super.aladin.od.ua","GOOGLE_AUTHORIZATION_LINK":"/auth/redirect/google","LINKEDIN_AUTHORIZATION_LINK":"/auth/redirect/linkedin","GET_POST_ENDPOINT":"/community/posts/12","SET_NEW_POST_ENDPOINT":"/community/posts/13","SEARCH_POST_ENDPOINT":"/community/search/16","DELETE_POST_ENDPOINT":"/post/delete/15","CREATE_COMMENT_ENDPOINT":"/post/comment/1","DELETE_COMMENT_ENDPOINT":"/comment/delete/1","GET_USER_PROFILE_ENDPOINT":"/profile","GET_USER_PROFILE_EMAIL_ENDPOINT":"/profile/email","SEARCH_TAGS_ENDPOINT":"/community/tags/","LIST_TAGS_ENDPOINT":"/community/tags/12","LIST_CONTACTS_ENDPOINT":"/community/contacts/13","CREATE_COMMUNITY_ENDPOINT":"/community/0","GET_COMMUNITIES_ENDPOINT":"/community","GET_DRIVERS_ENDPOINT":"/export/drivers","GET_FIELDS_ENDPOINT":"/export/fields","PREVIEW_TAGS_ENDPOINT":"/export/preview","LOAD_PREVIEW_PARAMETERS_ENDPOINT":"/export/load","AUTOCOMPLETE_VALUES_ENDPOINT":"/export/values","EXPORT_RULES_ENDPOINT":"/export"}}.env.CURRENT_LANG;
    	// Init Popup Windows
    	const popup_instance = new Popup();

    	popup_instance.init();

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let { id = "" } = $$props;
    	let { isOpen = false } = $$props;
    	const writable_props = ["id", "isOpen"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalWindow> was created with unknown prop '${key}'`);
    	});

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("isOpen" in $$props) $$invalidate(1, isOpen = $$props.isOpen);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Popup,
    		dispatch,
    		popup_instance,
    		goToBack,
    		id,
    		isOpen
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(0, id = $$props.id);
    		if ("isOpen" in $$props) $$invalidate(1, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, isOpen, $$scope, slots, click_handler_1, click_handler];
    }

    class ModalWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, { id: 0, isOpen: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalWindow",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get id() {
    		throw new Error("<ModalWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ModalWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error("<ModalWindow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<ModalWindow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/news-feed/TagIcon.svelte generated by Svelte v3.32.1 */

    const { console: console_1$5 } = globals;
    const file$11 = "src/components/news-feed/TagIcon.svelte";

    // (291:4) {#if showCloseIcon}
    function create_if_block$s(ctx) {
    	let i;
    	let i_class_value;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "tag-icon tag-search-" + /*colorIcon*/ ctx[2] + "-icon" + " svelte-1fx74nk");
    			add_location(i, file$11, 291, 8, 7423);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*colorIcon*/ 4 && i_class_value !== (i_class_value = "tag-icon tag-search-" + /*colorIcon*/ ctx[2] + "-icon" + " svelte-1fx74nk")) {
    				attr_dev(i, "class", i_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(291:4) {#if showCloseIcon}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;
    	let if_block = /*showCloseIcon*/ ctx[1] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(/*value*/ ctx[0]);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "tag-search orange svelte-1fx74nk");
    			attr_dev(div, "data-value", /*value*/ ctx[0]);
    			add_location(div, file$11, 288, 0, 7296);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*deletionAudienceData*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*value*/ 1) set_data_dev(t0, /*value*/ ctx[0]);

    			if (/*showCloseIcon*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*value*/ 1) {
    				attr_dev(div, "data-value", /*value*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let $createdNewAudienceData;
    	validate_store(createdNewAudienceData, "createdNewAudienceData");
    	component_subscribe($$self, createdNewAudienceData, $$value => $$invalidate(5, $createdNewAudienceData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TagIcon", slots, []);
    	let { value = "" } = $$props;
    	let { showCloseIcon = false } = $$props;
    	let { colorIcon = "white" } = $$props;
    	let { typeName = "" } = $$props; // industry-name or geography-name

    	const deletionAudienceData = event => {
    		console.log("deletionAudienceData createdNewAudienceData", $createdNewAudienceData);
    		console.log("deletionAudienceData typeName", typeName);
    		let audienceNameArr = $createdNewAudienceData[typeName];
    		const valueToDelete = event.target.dataset.value;

    		audienceNameArr = {
    			...$createdNewAudienceData,
    			[typeName]: audienceNameArr && audienceNameArr.filter(item => item !== valueToDelete)
    		};

    		// save audience data
    		createdNewAudienceData.update(n => audienceNameArr);
    	};

    	const writable_props = ["value", "showCloseIcon", "colorIcon", "typeName"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<TagIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("showCloseIcon" in $$props) $$invalidate(1, showCloseIcon = $$props.showCloseIcon);
    		if ("colorIcon" in $$props) $$invalidate(2, colorIcon = $$props.colorIcon);
    		if ("typeName" in $$props) $$invalidate(4, typeName = $$props.typeName);
    	};

    	$$self.$capture_state = () => ({
    		createdNewAudienceData,
    		value,
    		showCloseIcon,
    		colorIcon,
    		typeName,
    		deletionAudienceData,
    		$createdNewAudienceData
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("showCloseIcon" in $$props) $$invalidate(1, showCloseIcon = $$props.showCloseIcon);
    		if ("colorIcon" in $$props) $$invalidate(2, colorIcon = $$props.colorIcon);
    		if ("typeName" in $$props) $$invalidate(4, typeName = $$props.typeName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, showCloseIcon, colorIcon, deletionAudienceData, typeName];
    }

    class TagIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {
    			value: 0,
    			showCloseIcon: 1,
    			colorIcon: 2,
    			typeName: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagIcon",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get value() {
    		throw new Error("<TagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<TagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showCloseIcon() {
    		throw new Error("<TagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showCloseIcon(value) {
    		throw new Error("<TagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colorIcon() {
    		throw new Error("<TagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colorIcon(value) {
    		throw new Error("<TagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get typeName() {
    		throw new Error("<TagIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set typeName(value) {
    		throw new Error("<TagIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/news-feed/stepsNewAudience/AudienceTagsGroup.svelte generated by Svelte v3.32.1 */
    const file$12 = "src/components/news-feed/stepsNewAudience/AudienceTagsGroup.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (412:4) {#each industryName as name}
    function create_each_block_1(ctx) {
    	let tagicon;
    	let current;

    	tagicon = new TagIcon({
    			props: {
    				value: /*name*/ ctx[7],
    				typeName: "industry-name",
    				showCloseIcon: "true"
    			},
    			$$inline: true
    		});

    	tagicon.$on("click", /*click_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(tagicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tagicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tagicon_changes = {};
    			if (dirty & /*industryName*/ 2) tagicon_changes.value = /*name*/ ctx[7];
    			tagicon.$set(tagicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tagicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(412:4) {#each industryName as name}",
    		ctx
    	});

    	return block;
    }

    // (415:4) {#each geographyName as name}
    function create_each_block$h(ctx) {
    	let tagicon;
    	let current;

    	tagicon = new TagIcon({
    			props: {
    				value: /*name*/ ctx[7],
    				typeName: "geography-name",
    				showCloseIcon: "true"
    			},
    			$$inline: true
    		});

    	tagicon.$on("click", /*click_handler_1*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(tagicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tagicon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tagicon_changes = {};
    			if (dirty & /*geographyName*/ 4) tagicon_changes.value = /*name*/ ctx[7];
    			tagicon.$set(tagicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tagicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(415:4) {#each geographyName as name}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let div;
    	let t;
    	let div_class_value;
    	let current;
    	let each_value_1 = /*industryName*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*geographyName*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", div_class_value = "popup__element-wrap " + (/*width*/ ctx[0] ? "mod-wrap" : "") + " text-left" + " svelte-1f1xjz4");
    			add_location(div, file$12, 410, 0, 11833);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div, null);
    			}

    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*industryName*/ 2) {
    				each_value_1 = /*industryName*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*geographyName*/ 4) {
    				each_value = /*geographyName*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*width*/ 1 && div_class_value !== (div_class_value = "popup__element-wrap " + (/*width*/ ctx[0] ? "mod-wrap" : "") + " text-left" + " svelte-1f1xjz4")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let industryName;
    	let geographyName;
    	let $createdNewAudienceData;
    	validate_store(createdNewAudienceData, "createdNewAudienceData");
    	component_subscribe($$self, createdNewAudienceData, $$value => $$invalidate(4, $createdNewAudienceData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AudienceTagsGroup", slots, []);
    	let { data = [] } = $$props;
    	let { width = "" } = $$props;
    	const writable_props = ["data", "width"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AudienceTagsGroup> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({
    		TagIcon,
    		createdNewAudienceData,
    		data,
    		width,
    		industryName,
    		$createdNewAudienceData,
    		geographyName
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    		if ("industryName" in $$props) $$invalidate(1, industryName = $$props.industryName);
    		if ("geographyName" in $$props) $$invalidate(2, geographyName = $$props.geographyName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$createdNewAudienceData*/ 16) {
    			$$invalidate(1, industryName = $createdNewAudienceData && $createdNewAudienceData?.["industry-name"]
    			? $createdNewAudienceData?.["industry-name"]
    			: "");
    		}

    		if ($$self.$$.dirty & /*$createdNewAudienceData*/ 16) {
    			$$invalidate(2, geographyName = $createdNewAudienceData && $createdNewAudienceData?.["geography-name"]
    			? $createdNewAudienceData?.["geography-name"]
    			: "");
    		}
    	};

    	return [
    		width,
    		industryName,
    		geographyName,
    		data,
    		$createdNewAudienceData,
    		click_handler,
    		click_handler_1
    	];
    }

    class AudienceTagsGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, { data: 3, width: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AudienceTagsGroup",
    			options,
    			id: create_fragment$13.name
    		});
    	}

    	get data() {
    		throw new Error("<AudienceTagsGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<AudienceTagsGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<AudienceTagsGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<AudienceTagsGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/news-feed/stepsNewAudience/NewAudienceTitle.svelte generated by Svelte v3.32.1 */
    const file$13 = "src/components/news-feed/stepsNewAudience/NewAudienceTitle.svelte";

    function create_fragment$14(ctx) {
    	let form;
    	let div1;
    	let div0;
    	let input;
    	let t0;
    	let audiencetagsgroup;
    	let t1;
    	let div3;
    	let div2;
    	let btnstandart;
    	let current;
    	let mounted;
    	let dispose;

    	input = new Input({
    			props: {
    				name: "audience-name",
    				value: /*audienceName*/ ctx[0],
    				dataInputRole: "subject",
    				placeholder: translations[/*LANG*/ ctx[1]]?.NewAudienceTitle?.NewAudienceTitle_placeholder
    			},
    			$$inline: true
    		});

    	audiencetagsgroup = new AudienceTagsGroup({ $$inline: true });

    	btnstandart = new BtnStandart({
    			props: {
    				btnType: "submit",
    				className: "btn-200 btn btn-purple custom-save",
    				text: translations[/*LANG*/ ctx[1]]?.NewAudienceTitle?.NewAudienceTitle_btn
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(input.$$.fragment);
    			t0 = space();
    			create_component(audiencetagsgroup.$$.fragment);
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "popup__element-wrap svelte-1non87q");
    			add_location(div0, file$13, 500, 8, 25872);
    			attr_dev(div1, "class", "popup__search svelte-1non87q");
    			add_location(div1, file$13, 499, 4, 25835);
    			attr_dev(div2, "class", "popup__element-wrap d-flex justify-content-center svelte-1non87q");
    			add_location(div2, file$13, 511, 8, 26243);
    			attr_dev(div3, "class", "popup__footer svelte-1non87q");
    			add_location(div3, file$13, 510, 4, 26206);
    			attr_dev(form, "data-role", "new-audience");
    			add_location(form, file$13, 495, 0, 25737);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div1);
    			append_dev(div1, div0);
    			mount_component(input, div0, null);
    			append_dev(form, t0);
    			mount_component(audiencetagsgroup, form, null);
    			append_dev(form, t1);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			mount_component(btnstandart, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*saveEnteredDataHandler*/ ctx[2]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(audiencetagsgroup.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(audiencetagsgroup.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(input);
    			destroy_component(audiencetagsgroup);
    			destroy_component(btnstandart);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewAudienceTitle", slots, []);

    	let audienceName = createdNewAudienceData && createdNewAudienceData?.["audience-name"]
    	? createdNewAudienceData?.["audience-name"]
    	: "";

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const saveEnteredDataHandler = event => {
    		if (!checkStepFields("new-audience")) return false;
    		saveEnteredAudienceData("new-audience");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NewAudienceTitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Input,
    		translations,
    		BtnStandart,
    		AudienceTagsGroup,
    		createdNewAudienceData,
    		checkStepFields,
    		saveEnteredAudienceData,
    		audienceName,
    		LANG,
    		saveEnteredDataHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("audienceName" in $$props) $$invalidate(0, audienceName = $$props.audienceName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [audienceName, LANG, saveEnteredDataHandler];
    }

    class NewAudienceTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewAudienceTitle",
    			options,
    			id: create_fragment$14.name
    		});
    	}
    }

    /* src/components/news-feed/stepsNewAudience/NewAudienceIndustry.svelte generated by Svelte v3.32.1 */
    const file$14 = "src/components/news-feed/stepsNewAudience/NewAudienceIndustry.svelte";

    // (618:4) {#if dataReactive }
    function create_if_block$t(ctx) {
    	let audiencetagsgroup;
    	let current;
    	audiencetagsgroup = new AudienceTagsGroup({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(audiencetagsgroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audiencetagsgroup, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audiencetagsgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audiencetagsgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audiencetagsgroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(618:4) {#if dataReactive }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$15(ctx) {
    	let form;
    	let div1;
    	let div0;
    	let input;
    	let t0;
    	let t1;
    	let div3;
    	let div2;
    	let btnstandart;
    	let current;
    	let mounted;
    	let dispose;

    	input = new Input({
    			props: {
    				name: "industry-name",
    				dataInputRole: "subject",
    				placeholder: translations[/*LANG*/ ctx[1]]?.NewAudienceIndustry?.NewAudienceIndustry_placeholder
    			},
    			$$inline: true
    		});

    	let if_block = /*dataReactive*/ ctx[0] && create_if_block$t(ctx);

    	btnstandart = new BtnStandart({
    			props: {
    				btnType: "submit",
    				className: "btn btn-purple custom-save",
    				text: translations[/*LANG*/ ctx[1]]?.NewAudienceIndustry?.NewAudienceIndustry_btn
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(input.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "popup__element-wrap svelte-rdahvs");
    			add_location(div0, file$14, 610, 8, 29427);
    			attr_dev(div1, "class", "popup__search svelte-rdahvs");
    			add_location(div1, file$14, 609, 4, 29390);
    			attr_dev(div2, "class", "popup__element-wrap d-flex justify-content-center svelte-rdahvs");
    			add_location(div2, file$14, 622, 8, 29802);
    			attr_dev(div3, "class", "popup__footer svelte-rdahvs");
    			add_location(div3, file$14, 621, 4, 29765);
    			attr_dev(form, "data-role", "new-industry");
    			add_location(form, file$14, 606, 0, 29241);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div1);
    			append_dev(div1, div0);
    			mount_component(input, div0, null);
    			append_dev(form, t0);
    			if (if_block) if_block.m(form, null);
    			append_dev(form, t1);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			mount_component(btnstandart, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[4]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*dataReactive*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*dataReactive*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(form, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(input);
    			if (if_block) if_block.d();
    			destroy_component(btnstandart);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let dataReactive;
    	let $createdNewAudienceData;
    	validate_store(createdNewAudienceData, "createdNewAudienceData");
    	component_subscribe($$self, createdNewAudienceData, $$value => $$invalidate(3, $createdNewAudienceData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewAudienceIndustry", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const saveEnteredDataHandler = (event, stepName, callBack) => {
    		if (!checkStepFields(stepName)) return false;
    		saveEnteredAudienceData(stepName);

    		if (typeof callBack === "function") {
    			callBack();
    		}

    		$$invalidate(0, dataReactive = $createdNewAudienceData);
    		event.target.reset();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NewAudienceIndustry> was created with unknown prop '${key}'`);
    	});

    	const submit_handler = event => saveEnteredDataHandler(event, "new-industry", "industry-name");

    	$$self.$capture_state = () => ({
    		Input,
    		translations,
    		BtnStandart,
    		checkStepFields,
    		saveEnteredAudienceData,
    		AudienceTagsGroup,
    		createdNewAudienceData,
    		LANG,
    		saveEnteredDataHandler,
    		dataReactive,
    		$createdNewAudienceData
    	});

    	$$self.$inject_state = $$props => {
    		if ("dataReactive" in $$props) $$invalidate(0, dataReactive = $$props.dataReactive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$createdNewAudienceData*/ 8) {
    			$$invalidate(0, dataReactive = $createdNewAudienceData);
    		}
    	};

    	return [
    		dataReactive,
    		LANG,
    		saveEnteredDataHandler,
    		$createdNewAudienceData,
    		submit_handler
    	];
    }

    class NewAudienceIndustry extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewAudienceIndustry",
    			options,
    			id: create_fragment$15.name
    		});
    	}
    }

    /* src/components/news-feed/stepsNewAudience/NewAudienceGeography.svelte generated by Svelte v3.32.1 */
    const file$15 = "src/components/news-feed/stepsNewAudience/NewAudienceGeography.svelte";

    function create_fragment$16(ctx) {
    	let form;
    	let div1;
    	let div0;
    	let input;
    	let t0;
    	let audiencetagsgroup;
    	let t1;
    	let div3;
    	let div2;
    	let btnstandart;
    	let current;
    	let mounted;
    	let dispose;

    	input = new Input({
    			props: {
    				name: "geography-name",
    				dataInputRole: "subject",
    				placeholder: translations[/*LANG*/ ctx[0]]?.NewAudienceGeography?.NewAudienceGeography_placeholder
    			},
    			$$inline: true
    		});

    	audiencetagsgroup = new AudienceTagsGroup({ $$inline: true });

    	btnstandart = new BtnStandart({
    			props: {
    				btnType: "submit",
    				className: "btn btn-purple custom-save",
    				text: translations[/*LANG*/ ctx[0]]?.NewAudienceGeography?.NewAudienceGeography_btn
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(input.$$.fragment);
    			t0 = space();
    			create_component(audiencetagsgroup.$$.fragment);
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			create_component(btnstandart.$$.fragment);
    			attr_dev(div0, "class", "popup__element-wrap svelte-97haik");
    			add_location(div0, file$15, 319, 8, 9814);
    			attr_dev(div1, "class", "popup__search svelte-97haik");
    			add_location(div1, file$15, 318, 4, 9778);
    			attr_dev(div2, "class", "popup__element-wrap d-flex justify-content-center svelte-97haik");
    			add_location(div2, file$15, 329, 8, 10142);
    			attr_dev(div3, "class", "popup__footer svelte-97haik");
    			add_location(div3, file$15, 328, 4, 10106);
    			attr_dev(form, "data-role", "new-geography");
    			attr_dev(form, "data-step", "NewAudienceGeographyList-window");
    			add_location(form, file$15, 314, 0, 9579);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div1);
    			append_dev(div1, div0);
    			mount_component(input, div0, null);
    			append_dev(form, t0);
    			mount_component(audiencetagsgroup, form, null);
    			append_dev(form, t1);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			mount_component(btnstandart, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[2]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(audiencetagsgroup.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(audiencetagsgroup.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(input);
    			destroy_component(audiencetagsgroup);
    			destroy_component(btnstandart);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewAudienceGeography", slots, []);
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const saveEnteredDataHandler = (event, stepName, callBack) => {
    		if (!checkStepFields(stepName)) return false;

    		// Update localStorage with users data
    		saveEnteredAudienceData(stepName);

    		if (typeof callBack === "function") {
    			callBack();
    		}

    		event.target.reset();
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NewAudienceGeography> was created with unknown prop '${key}'`);
    	});

    	const submit_handler = event => saveEnteredDataHandler(event, "new-geography", "geography-name");

    	$$self.$capture_state = () => ({
    		Input,
    		translations,
    		BtnStandart,
    		checkStepFields,
    		saveEnteredAudienceData,
    		createEventDispatcher,
    		AudienceTagsGroup,
    		dispatch,
    		LANG,
    		saveEnteredDataHandler
    	});

    	return [LANG, saveEnteredDataHandler, submit_handler];
    }

    class NewAudienceGeography extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewAudienceGeography",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    /* src/components/news-feed/stepsNewAudience/AudienceHumanItem.svelte generated by Svelte v3.32.1 */
    const file$16 = "src/components/news-feed/stepsNewAudience/AudienceHumanItem.svelte";

    function create_fragment$17(ctx) {
    	let div3;
    	let avatar;
    	let t0;
    	let div2;
    	let div0;
    	let t1_value = /*data*/ ctx[0]?.user_name + "";
    	let t1;
    	let t2;
    	let div1;
    	let t3_value = /*data*/ ctx[0]?.user_company + "";
    	let t3;
    	let t4;
    	let button;
    	let button_data_id_value;
    	let div3_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	avatar = new Avatar({
    			props: {
    				url: /*data*/ ctx[0]?.avatar_url,
    				name: /*data*/ ctx[0]?.user_name
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			create_component(avatar.$$.fragment);
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			button = element("button");
    			attr_dev(div0, "class", "audience-people__name svelte-1fskwgb");
    			add_location(div0, file$16, 228, 8, 5185);
    			attr_dev(div1, "class", "audience-people__company-name svelte-1fskwgb");
    			add_location(div1, file$16, 229, 8, 5252);
    			add_location(div2, file$16, 227, 4, 5171);
    			attr_dev(button, "class", "audience-people__item-btn svelte-1fskwgb");
    			attr_dev(button, "data-id", button_data_id_value = /*data*/ ctx[0]?.user_id);
    			add_location(button, file$16, 231, 4, 5337);
    			attr_dev(div3, "class", div3_class_value = "audience-people__item " + (/*activeState*/ ctx[1] ? "active" : "") + " svelte-1fskwgb");
    			add_location(div3, file$16, 224, 0, 5039);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			mount_component(avatar, div3, null);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, t3);
    			append_dev(div3, t4);
    			append_dev(div3, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*selectHumanHandler*/ ctx[2]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const avatar_changes = {};
    			if (dirty & /*data*/ 1) avatar_changes.url = /*data*/ ctx[0]?.avatar_url;
    			if (dirty & /*data*/ 1) avatar_changes.name = /*data*/ ctx[0]?.user_name;
    			avatar.$set(avatar_changes);
    			if ((!current || dirty & /*data*/ 1) && t1_value !== (t1_value = /*data*/ ctx[0]?.user_name + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*data*/ 1) && t3_value !== (t3_value = /*data*/ ctx[0]?.user_company + "")) set_data_dev(t3, t3_value);

    			if (!current || dirty & /*data*/ 1 && button_data_id_value !== (button_data_id_value = /*data*/ ctx[0]?.user_id)) {
    				attr_dev(button, "data-id", button_data_id_value);
    			}

    			if (!current || dirty & /*activeState*/ 2 && div3_class_value !== (div3_class_value = "audience-people__item " + (/*activeState*/ ctx[1] ? "active" : "") + " svelte-1fskwgb")) {
    				attr_dev(div3, "class", div3_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(avatar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(avatar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(avatar);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AudienceHumanItem", slots, []);
    	let { data = {} } = $$props;
    	let activeState = "";
    	const dispatch = createEventDispatcher();

    	const selectHumanHandler = event => {
    		$$invalidate(1, activeState = !activeState);
    		dispatch("selectUser", { user_id: event.target.dataset.id });
    	};

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AudienceHumanItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		Avatar,
    		createEventDispatcher,
    		data,
    		activeState,
    		dispatch,
    		selectHumanHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("activeState" in $$props) $$invalidate(1, activeState = $$props.activeState);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, activeState, selectHumanHandler];
    }

    class AudienceHumanItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AudienceHumanItem",
    			options,
    			id: create_fragment$17.name
    		});
    	}

    	get data() {
    		throw new Error("<AudienceHumanItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<AudienceHumanItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/news-feed/stepsNewAudience/NewAudienceGeographyList.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$8 } = globals;
    const file$17 = "src/components/news-feed/stepsNewAudience/NewAudienceGeographyList.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (610:20) {#if searchKeyword === ''                         || (peopleItemData['user_company'].toLowerCase()).includes(searchKeyword.toLowerCase())                         || (peopleItemData['user_name'].toLowerCase()).includes(searchKeyword.toLowerCase()) }
    function create_if_block$u(ctx) {
    	let audiencehumanitem;
    	let current;

    	audiencehumanitem = new AudienceHumanItem({
    			props: { data: /*peopleItemData*/ ctx[12] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(audiencehumanitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audiencehumanitem, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audiencehumanitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audiencehumanitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audiencehumanitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(610:20) {#if searchKeyword === ''                         || (peopleItemData['user_company'].toLowerCase()).includes(searchKeyword.toLowerCase())                         || (peopleItemData['user_name'].toLowerCase()).includes(searchKeyword.toLowerCase()) }",
    		ctx
    	});

    	return block;
    }

    // (609:16) {#each peopleList as peopleItemData (peopleItemData.user_id)}
    function create_each_block$i(key_1, ctx) {
    	let first;
    	let show_if = /*searchKeyword*/ ctx[2] === "" || /*peopleItemData*/ ctx[12]["user_company"].toLowerCase().includes(/*searchKeyword*/ ctx[2].toLowerCase()) || /*peopleItemData*/ ctx[12]["user_name"].toLowerCase().includes(/*searchKeyword*/ ctx[2].toLowerCase());
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$u(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*searchKeyword*/ 4) show_if = /*searchKeyword*/ ctx[2] === "" || /*peopleItemData*/ ctx[12]["user_company"].toLowerCase().includes(/*searchKeyword*/ ctx[2].toLowerCase()) || /*peopleItemData*/ ctx[12]["user_name"].toLowerCase().includes(/*searchKeyword*/ ctx[2].toLowerCase());

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*searchKeyword*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(609:16) {#each peopleList as peopleItemData (peopleItemData.user_id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$18(ctx) {
    	let form;
    	let div2;
    	let div0;
    	let audiencetagsgroup;
    	let t0;
    	let div1;
    	let span;
    	let t1;
    	let t2;
    	let t3_value = translations[/*LANG*/ ctx[4]]?.NewAudienceList?.NewAudienceList_result + "";
    	let t3;
    	let t4;
    	let hr;
    	let t5;
    	let div4;
    	let div3;
    	let input;
    	let t6;
    	let div7;
    	let div6;
    	let div5;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t7;
    	let scrollbar;
    	let t8;
    	let div10;
    	let div8;
    	let btnstandart;
    	let t9;
    	let div9;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;
    	audiencetagsgroup = new AudienceTagsGroup({ props: { width: true }, $$inline: true });

    	input = new Input({
    			props: {
    				placeholder: translations[/*LANG*/ ctx[4]]?.NewAudienceList?.NewAudienceList_placeholder,
    				search: "search"
    			},
    			$$inline: true
    		});

    	input.$on("input", /*searchValue*/ ctx[8]);
    	let each_value = /*peopleList*/ ctx[7];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*peopleItemData*/ ctx[12].user_id;
    	validate_each_keys(ctx, each_value, get_each_context$i, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$i(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$i(key, child_ctx));
    	}

    	scrollbar = new Scrollbar({
    			props: {
    				observerTarget: /*iChangeMyHeight*/ ctx[0],
    				scrollArea: /*iAmScrollArea*/ ctx[1],
    				showArrows: false,
    				buttonPressingMove: 10
    			},
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				btnType: "submit",
    				text: translations[/*LANG*/ ctx[4]]?.NewAudienceList?.NewAudienceList_btn
    			},
    			$$inline: true
    		});

    	btnback = new BtnBack({
    			props: { dataStep: "NewAudienceGeography-window" },
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[6]);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(audiencetagsgroup.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			span = element("span");
    			t1 = text(/*counter*/ ctx[3]);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			div4 = element("div");
    			div3 = element("div");
    			create_component(input.$$.fragment);
    			t6 = space();
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			create_component(scrollbar.$$.fragment);
    			t8 = space();
    			div10 = element("div");
    			div8 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t9 = space();
    			div9 = element("div");
    			create_component(btnback.$$.fragment);
    			add_location(div0, file$17, 592, 8, 28322);
    			add_location(span, file$17, 595, 35, 28418);
    			attr_dev(div1, "class", "search-result svelte-1xzbu7w");
    			add_location(div1, file$17, 595, 8, 28391);
    			attr_dev(div2, "class", "tag-search-wrap svelte-1xzbu7w");
    			add_location(div2, file$17, 591, 4, 28284);
    			attr_dev(hr, "class", "hr");
    			add_location(hr, file$17, 597, 4, 28524);
    			attr_dev(div3, "class", "popup__element-wrap svelte-1xzbu7w");
    			add_location(div3, file$17, 600, 8, 28581);
    			attr_dev(div4, "class", "popup__search svelte-1xzbu7w");
    			add_location(div4, file$17, 599, 4, 28545);
    			attr_dev(div5, "class", "audience-people mt-10 ml-30 mr-30 svelte-1xzbu7w");
    			add_location(div5, file$17, 607, 12, 28940);
    			attr_dev(div6, "class", "dynamic-content");
    			add_location(div6, file$17, 606, 8, 28868);
    			attr_dev(div7, "class", "my-scroller svelte-1xzbu7w");
    			add_location(div7, file$17, 605, 4, 28806);
    			attr_dev(div8, "class", "popup__element-wrap d-flex justify-content-center svelte-1xzbu7w");
    			add_location(div8, file$17, 626, 8, 29720);
    			attr_dev(div9, "class", "mt-30");
    			add_location(div9, file$17, 631, 8, 29968);
    			attr_dev(div10, "class", "popup__footer svelte-1xzbu7w");
    			add_location(div10, file$17, 625, 4, 29684);
    			attr_dev(form, "data-role", "new-industry");
    			attr_dev(form, "data-step", "NewAudienceGeographySave-window");
    			add_location(form, file$17, 587, 0, 28149);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div2);
    			append_dev(div2, div0);
    			mount_component(audiencetagsgroup, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, span);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			append_dev(div1, t3);
    			append_dev(form, t4);
    			append_dev(form, hr);
    			append_dev(form, t5);
    			append_dev(form, div4);
    			append_dev(div4, div3);
    			mount_component(input, div3, null);
    			append_dev(form, t6);
    			append_dev(form, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			/*div6_binding*/ ctx[9](div6);
    			/*div7_binding*/ ctx[10](div7);
    			append_dev(form, t7);
    			mount_component(scrollbar, form, null);
    			append_dev(form, t8);
    			append_dev(form, div10);
    			append_dev(div10, div8);
    			mount_component(btnstandart, div8, null);
    			append_dev(div10, t9);
    			append_dev(div10, div9);
    			mount_component(btnback, div9, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*goToNextWindow*/ ctx[5]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*counter*/ 8) set_data_dev(t1, /*counter*/ ctx[3]);

    			if (dirty & /*peopleList, searchKeyword*/ 132) {
    				each_value = /*peopleList*/ ctx[7];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$i, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div5, outro_and_destroy_block, create_each_block$i, null, get_each_context$i);
    				check_outros();
    			}

    			const scrollbar_changes = {};
    			if (dirty & /*iChangeMyHeight*/ 1) scrollbar_changes.observerTarget = /*iChangeMyHeight*/ ctx[0];
    			if (dirty & /*iAmScrollArea*/ 2) scrollbar_changes.scrollArea = /*iAmScrollArea*/ ctx[1];
    			scrollbar.$set(scrollbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audiencetagsgroup.$$.fragment, local);
    			transition_in(input.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(scrollbar.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audiencetagsgroup.$$.fragment, local);
    			transition_out(input.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(scrollbar.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(audiencetagsgroup);
    			destroy_component(input);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*div6_binding*/ ctx[9](null);
    			/*div7_binding*/ ctx[10](null);
    			destroy_component(scrollbar);
    			destroy_component(btnstandart);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewAudienceGeographyList", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const dispatch = createEventDispatcher();

    	const goToNextWindow = () => {
    		let updatedData = [];
    		const fieldsToSave = document.querySelectorAll(".audience-people__item.active .audience-people__name");

    		[...fieldsToSave].forEach((item, index) => {
    			const itemValue = "name";

    			updatedData[index] = {
    				...updatedData[index],
    				[itemValue]: item.innerText
    			};
    		});

    		createdNewAudiencePeople.update(n => updatedData);
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	let iChangeMyHeight = 100;
    	let iAmScrollArea = 100;
    	let searchKeyword = "";

    	// Temporary values;
    	let peopleList = [
    		{
    			"user_id": 1,
    			"user_name": "John Doe",
    			"avatar_url": "",
    			"user_company": "Google"
    		},
    		{
    			"user_id": 2,
    			"user_name": "Lady Dee",
    			"avatar_url": "https://images.pexels.com/photos/2804282/pexels-photo-2804282.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260",
    			"user_company": "Google"
    		},
    		{
    			"user_id": 3,
    			"user_name": "Lady Dee 2",
    			"avatar_url": "https://images.pexels.com/photos/2804282/pexels-photo-2804282.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260",
    			"user_company": "Google"
    		},
    		{
    			"user_id": 4,
    			"user_name": "Lady Dee 3",
    			"avatar_url": "https://images.pexels.com/photos/2804282/pexels-photo-2804282.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260",
    			"user_company": "Google"
    		}
    	];

    	let counter = 0;

    	Object.keys(peopleList).forEach(
    		function (key) {
    			$$invalidate(3, counter++, counter);
    		},
    		peopleList
    	);

    	const searchValue = event => {
    		$$invalidate(2, searchKeyword = event.target.value);

    		let newPeopleList = peopleList && peopleList.filter(item => {
    			return item["user_company"].toLowerCase().includes(searchKeyword.toLowerCase()) || item["user_name"].toLowerCase().includes(searchKeyword.toLowerCase());
    		});

    		$$invalidate(3, counter = newPeopleList.length);
    	};

    	const writable_props = [];

    	Object_1$8.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NewAudienceGeographyList> was created with unknown prop '${key}'`);
    	});

    	function div6_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iChangeMyHeight = $$value;
    			$$invalidate(0, iChangeMyHeight);
    		});
    	}

    	function div7_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			iAmScrollArea = $$value;
    			$$invalidate(1, iAmScrollArea);
    		});
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Input,
    		BtnStandart,
    		BtnBack,
    		Scrollbar,
    		translations,
    		AudienceHumanItem,
    		AudienceTagsGroup,
    		createdNewAudiencePeople,
    		LANG,
    		dispatch,
    		goToNextWindow,
    		goToBack,
    		iChangeMyHeight,
    		iAmScrollArea,
    		searchKeyword,
    		peopleList,
    		counter,
    		searchValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("iChangeMyHeight" in $$props) $$invalidate(0, iChangeMyHeight = $$props.iChangeMyHeight);
    		if ("iAmScrollArea" in $$props) $$invalidate(1, iAmScrollArea = $$props.iAmScrollArea);
    		if ("searchKeyword" in $$props) $$invalidate(2, searchKeyword = $$props.searchKeyword);
    		if ("peopleList" in $$props) $$invalidate(7, peopleList = $$props.peopleList);
    		if ("counter" in $$props) $$invalidate(3, counter = $$props.counter);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		iChangeMyHeight,
    		iAmScrollArea,
    		searchKeyword,
    		counter,
    		LANG,
    		goToNextWindow,
    		goToBack,
    		peopleList,
    		searchValue,
    		div6_binding,
    		div7_binding
    	];
    }

    class NewAudienceGeographyList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewAudienceGeographyList",
    			options,
    			id: create_fragment$18.name
    		});
    	}
    }

    /* src/components/news-feed/stepsNewAudience/NewAudienceGeographySave.svelte generated by Svelte v3.32.1 */
    const file$18 = "src/components/news-feed/stepsNewAudience/NewAudienceGeographySave.svelte";

    function create_fragment$19(ctx) {
    	let form;
    	let div1;
    	let div0;
    	let audiencetagsgroup;
    	let t0;
    	let hr;
    	let t1;
    	let div3;
    	let div2;
    	let input;
    	let t2;
    	let div6;
    	let div4;
    	let btnstandart0;
    	let t3;
    	let btnstandart1;
    	let t4;
    	let div5;
    	let btnback;
    	let current;
    	let mounted;
    	let dispose;
    	audiencetagsgroup = new AudienceTagsGroup({ props: { width: true }, $$inline: true });

    	input = new Input({
    			props: {
    				placeholder: translations[/*LANG*/ ctx[0]]?.NewAudienceGeographySave?.NewAudienceGeographySave_placeholder,
    				search: "search"
    			},
    			$$inline: true
    		});

    	btnstandart0 = new BtnStandart({
    			props: {
    				btnType: "submit",
    				text: translations[/*LANG*/ ctx[0]]?.NewAudienceGeographySave?.NewAudienceGeographySave_btn_1,
    				dataStep: "NewAudienceGeographySave-window",
    				color: "orange",
    				className: "btn-200 mr-20"
    			},
    			$$inline: true
    		});

    	btnstandart0.$on("click", /*goToNextWindow*/ ctx[1]);

    	btnstandart1 = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[0]]?.NewAudienceGeographySave?.NewAudienceGeographySave_btn_2,
    				dataStep: "NewAudienceGeographySave-window",
    				color: "gray hover-purple",
    				className: "btn-200"
    			},
    			$$inline: true
    		});

    	btnstandart1.$on("click", /*goToNextWindow*/ ctx[1]);

    	btnback = new BtnBack({
    			props: {
    				dataStep: "NewAudienceGeographyList-window"
    			},
    			$$inline: true
    		});

    	btnback.$on("click", /*goToBack*/ ctx[2]);

    	const block = {
    		c: function create() {
    			form = element("form");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(audiencetagsgroup.$$.fragment);
    			t0 = space();
    			hr = element("hr");
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			create_component(input.$$.fragment);
    			t2 = space();
    			div6 = element("div");
    			div4 = element("div");
    			create_component(btnstandart0.$$.fragment);
    			t3 = space();
    			create_component(btnstandart1.$$.fragment);
    			t4 = space();
    			div5 = element("div");
    			create_component(btnback.$$.fragment);
    			add_location(div0, file$18, 614, 8, 29432);
    			attr_dev(div1, "class", "tag-search-wrap svelte-irryk3");
    			add_location(div1, file$18, 613, 4, 29393);
    			attr_dev(hr, "class", "hr");
    			add_location(hr, file$18, 618, 4, 29512);
    			attr_dev(div2, "class", "popup__element-wrap svelte-irryk3");
    			add_location(div2, file$18, 621, 8, 29578);
    			attr_dev(div3, "class", "popup__search mt-15 svelte-irryk3");
    			add_location(div3, file$18, 620, 4, 29535);
    			attr_dev(div4, "class", "popup__element-wrap d-flex justify-content-between svelte-irryk3");
    			add_location(div4, file$18, 628, 8, 29842);
    			attr_dev(div5, "class", "mt-30");
    			add_location(div5, file$18, 642, 8, 30638);
    			attr_dev(div6, "class", "popup__footer svelte-irryk3");
    			add_location(div6, file$18, 627, 4, 29805);
    			attr_dev(form, "data-role", "save-audience");
    			attr_dev(form, "data-step", "");
    			add_location(form, file$18, 609, 0, 29299);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, div1);
    			append_dev(div1, div0);
    			mount_component(audiencetagsgroup, div0, null);
    			append_dev(form, t0);
    			append_dev(form, hr);
    			append_dev(form, t1);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			mount_component(input, div2, null);
    			append_dev(form, t2);
    			append_dev(form, div6);
    			append_dev(div6, div4);
    			mount_component(btnstandart0, div4, null);
    			append_dev(div4, t3);
    			mount_component(btnstandart1, div4, null);
    			append_dev(div6, t4);
    			append_dev(div6, div5);
    			mount_component(btnback, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", /*goToNextWindow*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audiencetagsgroup.$$.fragment, local);
    			transition_in(input.$$.fragment, local);
    			transition_in(btnstandart0.$$.fragment, local);
    			transition_in(btnstandart1.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audiencetagsgroup.$$.fragment, local);
    			transition_out(input.$$.fragment, local);
    			transition_out(btnstandart0.$$.fragment, local);
    			transition_out(btnstandart1.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(audiencetagsgroup);
    			destroy_component(input);
    			destroy_component(btnstandart0);
    			destroy_component(btnstandart1);
    			destroy_component(btnback);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewAudienceGeographySave", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const dispatch = createEventDispatcher();

    	const goToNextWindow = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const goToBack = event => {
    		dispatch("goToStep", { step: event.target.dataset.step });
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NewAudienceGeographySave> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Input,
    		BtnStandart,
    		BtnBack,
    		translations,
    		AudienceTagsGroup,
    		LANG,
    		dispatch,
    		goToNextWindow,
    		goToBack
    	});

    	return [LANG, goToNextWindow, goToBack];
    }

    class NewAudienceGeographySave extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewAudienceGeographySave",
    			options,
    			id: create_fragment$19.name
    		});
    	}
    }

    /* src/components/news-feed/stepsNewAudience/NewAudienceGeographySteps.svelte generated by Svelte v3.32.1 */
    const file$19 = "src/components/news-feed/stepsNewAudience/NewAudienceGeographySteps.svelte";

    // (252:4) {#if currentStepWindow === 'NewAudienceGeography-window'}
    function create_if_block_2$5(ctx) {
    	let newaudiencegeography;
    	let current;
    	newaudiencegeography = new NewAudienceGeography({ $$inline: true });
    	newaudiencegeography.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(newaudiencegeography.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newaudiencegeography, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newaudiencegeography.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newaudiencegeography.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newaudiencegeography, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(252:4) {#if currentStepWindow === 'NewAudienceGeography-window'}",
    		ctx
    	});

    	return block;
    }

    // (255:4) {#if currentStepWindow === 'NewAudienceGeographyList-window'}
    function create_if_block_1$h(ctx) {
    	let newaudiencegeographylist;
    	let current;
    	newaudiencegeographylist = new NewAudienceGeographyList({ $$inline: true });
    	newaudiencegeographylist.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(newaudiencegeographylist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newaudiencegeographylist, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newaudiencegeographylist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newaudiencegeographylist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newaudiencegeographylist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(255:4) {#if currentStepWindow === 'NewAudienceGeographyList-window'}",
    		ctx
    	});

    	return block;
    }

    // (258:4) {#if currentStepWindow === 'NewAudienceGeographySave-window'}
    function create_if_block$v(ctx) {
    	let newaudiencegeographysave;
    	let current;
    	newaudiencegeographysave = new NewAudienceGeographySave({ $$inline: true });
    	newaudiencegeographysave.$on("goToStep", /*windowHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(newaudiencegeographysave.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newaudiencegeographysave, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newaudiencegeographysave.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newaudiencegeographysave.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newaudiencegeographysave, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(258:4) {#if currentStepWindow === 'NewAudienceGeographySave-window'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1a(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = /*currentStepWindow*/ ctx[0] === "NewAudienceGeography-window" && create_if_block_2$5(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "NewAudienceGeographyList-window" && create_if_block_1$h(ctx);
    	let if_block2 = /*currentStepWindow*/ ctx[0] === "NewAudienceGeographySave-window" && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			add_location(div, file$19, 249, 0, 6199);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "NewAudienceGeography-window") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "NewAudienceGeographyList-window") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$h(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "NewAudienceGeographySave-window") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$v(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewAudienceGeographySteps", slots, []);
    	let currentStepWindow = "NewAudienceGeography-window";

    	// Define what step should be displayed
    	const windowHandler = event => {
    		$$invalidate(0, currentStepWindow = event.detail.step);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NewAudienceGeographySteps> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		NewAudienceGeography,
    		NewAudienceGeographyList,
    		NewAudienceGeographySave,
    		currentStepWindow,
    		windowHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, windowHandler];
    }

    class NewAudienceGeographySteps extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewAudienceGeographySteps",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    /* src/components/news-feed/stepsNewAudience/StepsNewAudience.svelte generated by Svelte v3.32.1 */
    const file$1a = "src/components/news-feed/stepsNewAudience/StepsNewAudience.svelte";

    // (418:4) {#if currentStepWindow === 'NewAudienceTitle-window'}
    function create_if_block_2$6(ctx) {
    	let newaudiencetitle;
    	let current;
    	newaudiencetitle = new NewAudienceTitle({ $$inline: true });
    	newaudiencetitle.$on("goToStep", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(newaudiencetitle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newaudiencetitle, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newaudiencetitle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newaudiencetitle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newaudiencetitle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(418:4) {#if currentStepWindow === 'NewAudienceTitle-window'}",
    		ctx
    	});

    	return block;
    }

    // (421:4) {#if currentStepWindow === 'NewAudienceIndustry-window'}
    function create_if_block_1$i(ctx) {
    	let newaudienceindustry;
    	let current;
    	newaudienceindustry = new NewAudienceIndustry({ $$inline: true });
    	newaudienceindustry.$on("goToStep", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(newaudienceindustry.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newaudienceindustry, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newaudienceindustry.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newaudienceindustry.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newaudienceindustry, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(421:4) {#if currentStepWindow === 'NewAudienceIndustry-window'}",
    		ctx
    	});

    	return block;
    }

    // (424:4) {#if currentStepWindow === 'NewAudienceGeographySteps-window'}
    function create_if_block$w(ctx) {
    	let newaudiencegeography;
    	let current;
    	newaudiencegeography = new NewAudienceGeographySteps({ $$inline: true });
    	newaudiencegeography.$on("goToStep", /*windowHandler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(newaudiencegeography.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newaudiencegeography, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newaudiencegeography.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newaudiencegeography.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newaudiencegeography, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(424:4) {#if currentStepWindow === 'NewAudienceGeographySteps-window'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1b(ctx) {
    	let div1;
    	let h2;
    	let t1;
    	let div0;
    	let button0;
    	let t3;
    	let button1;
    	let t5;
    	let button2;
    	let t7;
    	let t8;
    	let t9;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*currentStepWindow*/ ctx[0] === "NewAudienceTitle-window" && create_if_block_2$6(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "NewAudienceIndustry-window" && create_if_block_1$i(ctx);
    	let if_block2 = /*currentStepWindow*/ ctx[0] === "NewAudienceGeographySteps-window" && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			h2.textContent = `${translations[/*LANG*/ ctx[1]]?.newAudience?.newAudience_header}`;
    			t1 = space();
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = `${translations[/*LANG*/ ctx[1]]?.newAudience?.newAudienceMenuItem1}`;
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = `${translations[/*LANG*/ ctx[1]]?.newAudience?.newAudienceMenuItem2}`;
    			t5 = space();
    			button2 = element("button");
    			button2.textContent = `${translations[/*LANG*/ ctx[1]]?.newAudience?.newAudienceMenuItem3}`;
    			t7 = space();
    			if (if_block0) if_block0.c();
    			t8 = space();
    			if (if_block1) if_block1.c();
    			t9 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(h2, "class", "popup__header svelte-109t5zd");
    			add_location(h2, file$1a, 394, 4, 12342);
    			attr_dev(button0, "class", "admin-menu__item active svelte-109t5zd");
    			attr_dev(button0, "data-step", "NewAudienceTitle-window");
    			add_location(button0, file$1a, 397, 8, 12507);
    			attr_dev(button1, "class", "admin-menu__item svelte-109t5zd");
    			attr_dev(button1, "data-step", "NewAudienceIndustry-window");
    			add_location(button1, file$1a, 403, 8, 12765);
    			attr_dev(button2, "class", "admin-menu__item svelte-109t5zd");
    			attr_dev(button2, "data-step", "NewAudienceGeographySteps-window");
    			add_location(button2, file$1a, 409, 8, 13019);
    			attr_dev(div0, "class", "admin-menu svelte-109t5zd");
    			add_location(div0, file$1a, 396, 4, 12473);
    			add_location(div1, file$1a, 392, 0, 12329);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t3);
    			append_dev(div0, button1);
    			append_dev(div0, t5);
    			append_dev(div0, button2);
    			append_dev(div1, t7);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t8);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t9);
    			if (if_block2) if_block2.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button1, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false),
    					listen_dev(button2, "click", prevent_default(/*windowHandler*/ ctx[2]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "NewAudienceTitle-window") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t8);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "NewAudienceIndustry-window") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$i(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t9);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "NewAudienceGeographySteps-window") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$w(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("StepsNewAudience", slots, []);
    	let currentStepWindow = "NewAudienceTitle-window";

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	// Define what step should be displayed
    	const windowHandler = event => {
    		$$invalidate(0, currentStepWindow = event.target.dataset.step);
    		let elementsMenu = document.querySelectorAll(".admin-menu__item");

    		elementsMenu.forEach(function (el) {
    			el.classList.remove("active");
    		});

    		event.target.classList.add("active");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<StepsNewAudience> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		NewAudienceTitle,
    		NewAudienceIndustry,
    		NewAudienceGeography: NewAudienceGeographySteps,
    		translations,
    		currentStepWindow,
    		LANG,
    		windowHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, LANG, windowHandler];
    }

    class StepsNewAudience extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StepsNewAudience",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    /* src/components/news-feed/AudienceBlock.svelte generated by Svelte v3.32.1 */
    const file$1b = "src/components/news-feed/AudienceBlock.svelte";

    function create_fragment$1c(ctx) {
    	let div4;
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let div2_class_value;
    	let t3;
    	let div3;
    	let button0;
    	let t5;
    	let button1;
    	let t7;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(/*name*/ ctx[0]);
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "62 people";
    			t3 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "#CEO";
    			t5 = space();
    			button1 = element("button");
    			button1.textContent = "#CEO";
    			t7 = space();
    			button2 = element("button");
    			button2.textContent = "#CEO";
    			attr_dev(div0, "class", "audience__name svelte-k1piwz");
    			add_location(div0, file$1b, 206, 8, 4226);
    			attr_dev(div1, "class", "audience__count-people svelte-k1piwz");
    			add_location(div1, file$1b, 207, 8, 4275);
    			attr_dev(div2, "class", div2_class_value = "audience__top " + (/*activeState*/ ctx[1] ? "active" : "") + " svelte-k1piwz");
    			add_location(div2, file$1b, 205, 4, 4115);
    			attr_dev(button0, "class", "audience__tags-button svelte-k1piwz");
    			attr_dev(button0, "data-tag", "ceo");
    			add_location(button0, file$1b, 210, 8, 4379);
    			attr_dev(button1, "class", "audience__tags-button svelte-k1piwz");
    			attr_dev(button1, "data-tag", "ceo");
    			add_location(button1, file$1b, 214, 8, 4492);
    			attr_dev(button2, "class", "audience__tags-button svelte-k1piwz");
    			attr_dev(button2, "data-tag", "ceo");
    			add_location(button2, file$1b, 218, 8, 4605);
    			attr_dev(div3, "class", "audience__tags svelte-k1piwz");
    			add_location(div3, file$1b, 209, 4, 4342);
    			attr_dev(div4, "class", "audience__block svelte-k1piwz");
    			add_location(div4, file$1b, 204, 0, 4081);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t5);
    			append_dev(div3, button1);
    			append_dev(div3, t7);
    			append_dev(div3, button2);

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", prevent_default(/*selectHumanHandler*/ ctx[2]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*name*/ 1) set_data_dev(t0, /*name*/ ctx[0]);

    			if (dirty & /*activeState*/ 2 && div2_class_value !== (div2_class_value = "audience__top " + (/*activeState*/ ctx[1] ? "active" : "") + " svelte-k1piwz")) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AudienceBlock", slots, []);
    	let activeState = "";

    	const selectHumanHandler = event => {
    		$$invalidate(1, activeState = !activeState);
    	};

    	let { name = "" } = $$props;
    	let { users = [] } = $$props;
    	let { tags = [] } = $$props;
    	const writable_props = ["name", "users", "tags"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AudienceBlock> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("name" in $$props) $$invalidate(0, name = $$props.name);
    		if ("users" in $$props) $$invalidate(3, users = $$props.users);
    		if ("tags" in $$props) $$invalidate(4, tags = $$props.tags);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		activeState,
    		selectHumanHandler,
    		name,
    		users,
    		tags
    	});

    	$$self.$inject_state = $$props => {
    		if ("activeState" in $$props) $$invalidate(1, activeState = $$props.activeState);
    		if ("name" in $$props) $$invalidate(0, name = $$props.name);
    		if ("users" in $$props) $$invalidate(3, users = $$props.users);
    		if ("tags" in $$props) $$invalidate(4, tags = $$props.tags);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [name, activeState, selectHumanHandler, users, tags];
    }

    class AudienceBlock extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, { name: 0, users: 3, tags: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AudienceBlock",
    			options,
    			id: create_fragment$1c.name
    		});
    	}

    	get name() {
    		throw new Error("<AudienceBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<AudienceBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get users() {
    		throw new Error("<AudienceBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set users(value) {
    		throw new Error("<AudienceBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tags() {
    		throw new Error("<AudienceBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tags(value) {
    		throw new Error("<AudienceBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/news-feed/modals/SelectAudience.svelte generated by Svelte v3.32.1 */

    const { console: console_1$6 } = globals;
    const file$1c = "src/components/news-feed/modals/SelectAudience.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i].id;
    	child_ctx[6] = list[i].name;
    	return child_ctx;
    }

    // (563:8) {#if listAudience}
    function create_if_block$x(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*listAudience*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*listAudience*/ 1) {
    				each_value = /*listAudience*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(563:8) {#if listAudience}",
    		ctx
    	});

    	return block;
    }

    // (564:12) {#each listAudience as { id, name }}
    function create_each_block$j(ctx) {
    	let audienceblock;
    	let current;

    	audienceblock = new AudienceBlock({
    			props: {
    				name: /*name*/ ctx[6],
    				users: "",
    				tags: ""
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(audienceblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audienceblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const audienceblock_changes = {};
    			if (dirty & /*listAudience*/ 1) audienceblock_changes.name = /*name*/ ctx[6];
    			audienceblock.$set(audienceblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audienceblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audienceblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audienceblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(564:12) {#each listAudience as { id, name }}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1d(ctx) {
    	let h2;
    	let t1;
    	let div1;
    	let div0;
    	let input;
    	let t2;
    	let hr0;
    	let t3;
    	let div3;
    	let div2;
    	let t4;
    	let hr1;
    	let t5;
    	let div5;
    	let div4;
    	let btnstandart0;
    	let t6;
    	let btnstandart1;
    	let t7;
    	let div6;
    	let btnback;
    	let current;

    	input = new Input({
    			props: {
    				placeholder: "Search audience",
    				search: "search"
    			},
    			$$inline: true
    		});

    	let if_block = /*listAudience*/ ctx[0] && create_if_block$x(ctx);

    	btnstandart0 = new BtnStandart({
    			props: {
    				type: "button",
    				color: "gray",
    				className: "m-5 btn-200 hover-purple",
    				text: "Post to audience"
    			},
    			$$inline: true
    		});

    	btnstandart0.$on("click", /*savePostData*/ ctx[2]);

    	btnstandart1 = new BtnStandart({
    			props: {
    				type: "button",
    				role: "open-create-new-audience-popup",
    				className: "m-5 btn-200 btn-orange",
    				text: "Create new",
    				dataHref: "#create_new_audience"
    			},
    			$$inline: true
    		});

    	btnstandart1.$on("click", /*click_handler*/ ctx[3]);

    	btnback = new BtnBack({
    			props: {
    				className: "js-popup-close",
    				role: "popup-close"
    			},
    			$$inline: true
    		});

    	btnback.$on("click", /*click_handler_1*/ ctx[4]);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = `${translations[/*LANG*/ ctx[1]].select_audience.heading}`;
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			create_component(input.$$.fragment);
    			t2 = space();
    			hr0 = element("hr");
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			hr1 = element("hr");
    			t5 = space();
    			div5 = element("div");
    			div4 = element("div");
    			create_component(btnstandart0.$$.fragment);
    			t6 = space();
    			create_component(btnstandart1.$$.fragment);
    			t7 = space();
    			div6 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(h2, "class", "popup__header hr-bottom svelte-172xjp7");
    			add_location(h2, file$1c, 552, 0, 29281);
    			attr_dev(div0, "class", "popup__element-wrap svelte-172xjp7");
    			add_location(div0, file$1c, 554, 4, 29399);
    			attr_dev(div1, "class", "popup__search svelte-172xjp7");
    			add_location(div1, file$1c, 553, 0, 29367);
    			attr_dev(hr0, "class", "hr");
    			add_location(hr0, file$1c, 559, 0, 29530);
    			attr_dev(div2, "class", "audience mt-30");
    			add_location(div2, file$1c, 561, 4, 29584);
    			attr_dev(div3, "class", "popup__element-wrap svelte-172xjp7");
    			add_location(div3, file$1c, 560, 0, 29546);
    			attr_dev(hr1, "class", "hr mt-30");
    			add_location(hr1, file$1c, 569, 0, 29799);
    			attr_dev(div4, "class", "mt-30 d-flex flex-wrap justify-content-center");
    			add_location(div4, file$1c, 571, 4, 29852);
    			attr_dev(div5, "class", "wrap-buttons svelte-172xjp7");
    			add_location(div5, file$1c, 570, 0, 29821);
    			attr_dev(div6, "class", "mt-30");
    			add_location(div6, file$1c, 587, 0, 30433);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(input, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, hr0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			if (if_block) if_block.m(div2, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, hr1, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			mount_component(btnstandart0, div4, null);
    			append_dev(div4, t6);
    			mount_component(btnstandart1, div4, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div6, anchor);
    			mount_component(btnback, div6, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*listAudience*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*listAudience*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$x(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(btnstandart0.$$.fragment, local);
    			transition_in(btnstandart1.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(btnstandart0.$$.fragment, local);
    			transition_out(btnstandart1.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(input);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(hr0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div3);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(hr1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div5);
    			destroy_component(btnstandart0);
    			destroy_component(btnstandart1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div6);
    			destroy_component(btnback);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SelectAudience", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let listAudience;

    	(async () => {
    		const GET_COMMUNITIES_ENDPOINT = ({
    			"env": {
    				"isProd": false,
    				"CURRENT_LANG": "en",
    				"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    				"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    				"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    				"GET_POST_ENDPOINT": "/community/posts/12",
    				"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    				"SEARCH_POST_ENDPOINT": "/community/search/16",
    				"DELETE_POST_ENDPOINT": "/post/delete/15",
    				"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    				"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    				"GET_USER_PROFILE_ENDPOINT": "/profile",
    				"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    				"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    				"LIST_TAGS_ENDPOINT": "/community/tags/12",
    				"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    				"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    				"GET_COMMUNITIES_ENDPOINT": "/community",
    				"GET_DRIVERS_ENDPOINT": "/export/drivers",
    				"GET_FIELDS_ENDPOINT": "/export/fields",
    				"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    				"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    				"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    				"EXPORT_RULES_ENDPOINT": "/export"
    			}
    		}).env.GET_COMMUNITIES_ENDPOINT;

    		let res = await makeRequestToBackend(false, GET_COMMUNITIES_ENDPOINT, "GET");
    		$$invalidate(0, listAudience = JSON.parse(res));
    		console.log("listAudience", listAudience);
    	})();

    	const savePostData = event => {
    		document.querySelector(".js-popup-close").click();
    		let postData = {};
    		let blacks = ["1", "2", "3", "4"];
    		let tags = [1, 2, 3, 4];
    		let postMsg = document.querySelector(".js-comment-main .form-control__input-text").value;
    		let is_anonymous = document.querySelector(".js-comment-main .js-post-anonymously").checked;
    		let photos = [];
    		let files = document.querySelector(".js-comment-main .comment-block__image").files;

    		for (var i = 0; i < files.length; i++) {
    			photos.push(files[i].name);
    		}

    		postData["blacks"] = blacks;
    		postData["tags"] = tags;
    		postData["description"] = postMsg;
    		postData["photos"] = photos;
    		postData["is_anonymous"] = !!is_anonymous ? 1 : 0;
    		console.log("typeof blacks", typeof blacks);
    		console.log("typeof tags", typeof tags);
    		console.log("typeof photos", typeof photos);

    		(async () => {
    			const SET_NEW_POST_ENDPOINT = ({
    				"env": {
    					"isProd": false,
    					"CURRENT_LANG": "en",
    					"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    					"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    					"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    					"GET_POST_ENDPOINT": "/community/posts/12",
    					"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    					"SEARCH_POST_ENDPOINT": "/community/search/16",
    					"DELETE_POST_ENDPOINT": "/post/delete/15",
    					"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    					"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    					"GET_USER_PROFILE_ENDPOINT": "/profile",
    					"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    					"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    					"LIST_TAGS_ENDPOINT": "/community/tags/12",
    					"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    					"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    					"GET_COMMUNITIES_ENDPOINT": "/community",
    					"GET_DRIVERS_ENDPOINT": "/export/drivers",
    					"GET_FIELDS_ENDPOINT": "/export/fields",
    					"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    					"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    					"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    					"EXPORT_RULES_ENDPOINT": "/export"
    				}
    			}).env.SET_NEW_POST_ENDPOINT;

    			let res = await makeRequestToBackend(postData, SET_NEW_POST_ENDPOINT, "POST", false);

    			//submitBtnType = 'submit';
    			console.log("res - send post", res);

    			// Access isn't authorized
    			if (res.status === 401) {
    				nextStep = "login-step";
    				return;
    			}
    		})();

    		console.log("postData ---", postData);
    	}; // Update store with post data
    	//saveEnteredUserData();

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<SelectAudience> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$capture_state = () => ({
    		BtnStandart,
    		AudienceBlock,
    		BtnBack,
    		Input,
    		checkStepFields,
    		makeRequestToBackend,
    		saveEnteredUserData,
    		translations,
    		loop_guard,
    		LANG,
    		listAudience,
    		savePostData
    	});

    	$$self.$inject_state = $$props => {
    		if ("listAudience" in $$props) $$invalidate(0, listAudience = $$props.listAudience);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [listAudience, LANG, savePostData, click_handler, click_handler_1];
    }

    class SelectAudience extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectAudience",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    /* src/components/news-feed/modals/CreateNewAudience.svelte generated by Svelte v3.32.1 */

    function create_fragment$1e(ctx) {
    	let stepsnewaudience;
    	let current;
    	stepsnewaudience = new StepsNewAudience({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(stepsnewaudience.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(stepsnewaudience, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(stepsnewaudience.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(stepsnewaudience.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(stepsnewaudience, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CreateNewAudience", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CreateNewAudience> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ StepsNewAudience });
    	return [];
    }

    class CreateNewAudience extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CreateNewAudience",
    			options,
    			id: create_fragment$1e.name
    		});
    	}
    }

    /* src/components/news-feed/modals/EditProfile.svelte generated by Svelte v3.32.1 */
    const file$1d = "src/components/news-feed/modals/EditProfile.svelte";

    function create_fragment$1f(ctx) {
    	let h2;
    	let t1;
    	let div0;
    	let input;
    	let t2;
    	let div1;
    	let btnstandart;
    	let t3;
    	let div2;
    	let btnback;
    	let current;

    	input = new Input({
    			props: { label: "Full name" },
    			$$inline: true
    		});

    	btnstandart = new BtnStandart({
    			props: {
    				btnType: "submit",
    				text: "Save",
    				role: "close-edit-profile-popup",
    				className: "hover-purple",
    				color: "gray"
    			},
    			$$inline: true
    		});

    	btnstandart.$on("click", /*click_handler*/ ctx[1]);

    	btnback = new BtnBack({
    			props: { role: "close-edit-profile-popup" },
    			$$inline: true
    		});

    	btnback.$on("click", /*click_handler_1*/ ctx[2]);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = `${translations[/*LANG*/ ctx[0]]?.editProfile?.editProfile_header}`;
    			t1 = space();
    			div0 = element("div");
    			create_component(input.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(btnstandart.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(btnback.$$.fragment);
    			attr_dev(h2, "class", "popup__header hr-bottom svelte-1tr8rjq");
    			add_location(h2, file$1d, 480, 0, 25207);
    			attr_dev(div0, "class", "mt-30");
    			add_location(div0, file$1d, 482, 0, 25303);
    			attr_dev(div1, "class", "mt-30");
    			add_location(div1, file$1d, 486, 0, 25363);
    			attr_dev(div2, "class", "mt-30");
    			add_location(div2, file$1d, 495, 0, 25607);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(input, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(btnstandart, div1, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(btnback, div2, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			transition_in(btnstandart.$$.fragment, local);
    			transition_in(btnback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			transition_out(btnstandart.$$.fragment, local);
    			transition_out(btnback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div0);
    			destroy_component(input);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(btnstandart);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div2);
    			destroy_component(btnback);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EditProfile", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EditProfile> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$capture_state = () => ({
    		translations,
    		BtnBack,
    		Input,
    		BtnStandart,
    		LANG
    	});

    	return [LANG, click_handler, click_handler_1];
    }

    class EditProfile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditProfile",
    			options,
    			id: create_fragment$1f.name
    		});
    	}
    }

    /* src/components/news-feed/modals/DownloadImage.svelte generated by Svelte v3.32.1 */
    const file$1e = "src/components/news-feed/modals/DownloadImage.svelte";

    function create_fragment$1g(ctx) {
    	let h2;
    	let t1;
    	let div1;
    	let div0;
    	let t2;
    	let div2;
    	let form;
    	let input0;
    	let t3;
    	let input1;
    	let t4;
    	let btnstandart0;
    	let t5;
    	let btnstandart1;
    	let current;

    	btnstandart0 = new BtnStandart({
    			props: {
    				text: translations[/*LANG*/ ctx[0]]?.download_img?.download_btn_2,
    				role: "close-edit-profile-popup"
    			},
    			$$inline: true
    		});

    	btnstandart0.$on("click", /*trigger*/ ctx[1]);

    	btnstandart1 = new BtnStandart({
    			props: {
    				btnType: "submit",
    				text: translations[/*LANG*/ ctx[0]]?.download_img?.download_btn_1,
    				role: "close-edit-profile-popup",
    				className: "hover-purple ml-15",
    				color: "gray"
    			},
    			$$inline: true
    		});

    	btnstandart1.$on("click", /*click_handler*/ ctx[2]);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = `${translations[/*LANG*/ ctx[0]]?.download_img?.download_img_header}`;
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			t2 = space();
    			div2 = element("div");
    			form = element("form");
    			input0 = element("input");
    			t3 = space();
    			input1 = element("input");
    			t4 = space();
    			create_component(btnstandart0.$$.fragment);
    			t5 = space();
    			create_component(btnstandart1.$$.fragment);
    			attr_dev(h2, "class", "popup__header hr-bottom svelte-d2geq5");
    			add_location(h2, file$1e, 499, 0, 25515);
    			attr_dev(div0, "id", "text");
    			attr_dev(div0, "class", "text svelte-d2geq5");
    			add_location(div0, file$1e, 501, 4, 25635);
    			attr_dev(div1, "class", "m-30");
    			add_location(div1, file$1e, 500, 0, 25612);
    			attr_dev(input0, "type", "hidden");
    			attr_dev(input0, "name", "user_id");
    			add_location(input0, file$1e, 505, 8, 25725);
    			attr_dev(input1, "type", "file");
    			attr_dev(input1, "name", "user_image");
    			attr_dev(input1, "id", "btnFile");
    			attr_dev(input1, "class", "block-download__hidden svelte-d2geq5");
    			add_location(input1, file$1e, 506, 8, 25770);
    			add_location(form, file$1e, 504, 4, 25710);
    			attr_dev(div2, "class", "block-download svelte-d2geq5");
    			add_location(div2, file$1e, 503, 0, 25677);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, form);
    			append_dev(form, input0);
    			append_dev(form, t3);
    			append_dev(form, input1);
    			append_dev(form, t4);
    			mount_component(btnstandart0, form, null);
    			append_dev(form, t5);
    			mount_component(btnstandart1, form, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(btnstandart0.$$.fragment, local);
    			transition_in(btnstandart1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(btnstandart0.$$.fragment, local);
    			transition_out(btnstandart1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			destroy_component(btnstandart0);
    			destroy_component(btnstandart1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DownloadImage", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const trigger = () => {
    		let btnFile = document.getElementById("btnFile");
    		let text = document.getElementById("text");

    		btnFile.onchange = function () {
    			text.innerHTML = btnFile.value;
    		};

    		btnFile.click();
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DownloadImage> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$capture_state = () => ({ translations, BtnStandart, LANG, trigger });
    	return [LANG, trigger, click_handler];
    }

    class DownloadImage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DownloadImage",
    			options,
    			id: create_fragment$1g.name
    		});
    	}
    }

    /* src/components/news-feed/UserData.svelte generated by Svelte v3.32.1 */
    const file$1f = "src/components/news-feed/UserData.svelte";

    // (327:0) {#if isEditProfilePopupOpened }
    function create_if_block_1$j(ctx) {
    	let modalwindow;
    	let current;

    	modalwindow = new ModalWindow({
    			props: {
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modalwindow.$on("click", /*popupClickHandler*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(modalwindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalwindow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modalwindow_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				modalwindow_changes.$$scope = { dirty, ctx };
    			}

    			modalwindow.$set(modalwindow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalwindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalwindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalwindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(327:0) {#if isEditProfilePopupOpened }",
    		ctx
    	});

    	return block;
    }

    // (328:4) <ModalWindow on:click={popupClickHandler}>
    function create_default_slot_1(ctx) {
    	let editprofile;
    	let current;
    	editprofile = new EditProfile({ $$inline: true });
    	editprofile.$on("click", /*popupClickHandler*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(editprofile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(editprofile, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editprofile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editprofile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(editprofile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(328:4) <ModalWindow on:click={popupClickHandler}>",
    		ctx
    	});

    	return block;
    }

    // (333:0) {#if isDownloadImagePopupOpened }
    function create_if_block$y(ctx) {
    	let modalwindow;
    	let current;

    	modalwindow = new ModalWindow({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modalwindow.$on("click", /*popupClickHandler*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(modalwindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalwindow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modalwindow_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				modalwindow_changes.$$scope = { dirty, ctx };
    			}

    			modalwindow.$set(modalwindow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalwindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalwindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalwindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(333:0) {#if isDownloadImagePopupOpened }",
    		ctx
    	});

    	return block;
    }

    // (334:4) <ModalWindow on:click={popupClickHandler}>
    function create_default_slot(ctx) {
    	let downloadimage;
    	let current;
    	downloadimage = new DownloadImage({ $$inline: true });
    	downloadimage.$on("click", /*popupClickHandler*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(downloadimage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(downloadimage, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(downloadimage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(downloadimage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(downloadimage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(334:4) <ModalWindow on:click={popupClickHandler}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1h(ctx) {
    	let t0;
    	let t1;
    	let div28;
    	let div0;
    	let t2;
    	let div1;
    	let t4;
    	let div3;
    	let img;
    	let img_src_value;
    	let t5;
    	let div2;
    	let t6;
    	let div4;
    	let t8;
    	let div5;
    	let t10;
    	let div6;
    	let t12;
    	let div27;
    	let div7;
    	let t13;
    	let div26;
    	let div10;
    	let div8;
    	let t15;
    	let div9;
    	let t17;
    	let div13;
    	let div11;
    	let t19;
    	let div12;
    	let t21;
    	let div16;
    	let div14;
    	let t23;
    	let div15;
    	let t25;
    	let div19;
    	let div17;
    	let t27;
    	let div18;
    	let t29;
    	let div22;
    	let div20;
    	let t31;
    	let div21;
    	let t33;
    	let div25;
    	let div23;
    	let t35;
    	let div24;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*isEditProfilePopupOpened*/ ctx[0] && create_if_block_1$j(ctx);
    	let if_block1 = /*isDownloadImagePopupOpened*/ ctx[1] && create_if_block$y(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div28 = element("div");
    			div0 = element("div");
    			t2 = space();
    			div1 = element("div");
    			div1.textContent = `${translations[/*LANG*/ ctx[2]]?.editProfile?.editProfile_btn}`;
    			t4 = space();
    			div3 = element("div");
    			img = element("img");
    			t5 = space();
    			div2 = element("div");
    			t6 = space();
    			div4 = element("div");
    			div4.textContent = "John Doe";
    			t8 = space();
    			div5 = element("div");
    			div5.textContent = "Veritable";
    			t10 = space();
    			div6 = element("div");
    			div6.textContent = "johndoe@veritable.io";
    			t12 = space();
    			div27 = element("div");
    			div7 = element("div");
    			t13 = space();
    			div26 = element("div");
    			div10 = element("div");
    			div8 = element("div");
    			div8.textContent = "Geography:";
    			t15 = space();
    			div9 = element("div");
    			div9.textContent = "Boston";
    			t17 = space();
    			div13 = element("div");
    			div11 = element("div");
    			div11.textContent = "Geography:";
    			t19 = space();
    			div12 = element("div");
    			div12.textContent = "Boston";
    			t21 = space();
    			div16 = element("div");
    			div14 = element("div");
    			div14.textContent = "Geography:";
    			t23 = space();
    			div15 = element("div");
    			div15.textContent = "Boston";
    			t25 = space();
    			div19 = element("div");
    			div17 = element("div");
    			div17.textContent = "Geography:";
    			t27 = space();
    			div18 = element("div");
    			div18.textContent = "Boston";
    			t29 = space();
    			div22 = element("div");
    			div20 = element("div");
    			div20.textContent = "Geography:";
    			t31 = space();
    			div21 = element("div");
    			div21.textContent = "Boston";
    			t33 = space();
    			div25 = element("div");
    			div23 = element("div");
    			div23.textContent = "Geography:";
    			t35 = space();
    			div24 = element("div");
    			div24.textContent = "Boston";
    			attr_dev(div0, "class", "back-close svelte-h7ztm5");
    			attr_dev(div0, "data-role", "close-edit-profile");
    			add_location(div0, file$1f, 340, 4, 14112);
    			attr_dev(div1, "class", "edit-profile js-open-popup-activator svelte-h7ztm5");
    			attr_dev(div1, "data-role", "edit-user-data-popup");
    			add_location(div1, file$1f, 344, 4, 14206);
    			if (img.src !== (img_src_value = "./images/avatar-user-data.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "avatar");
    			attr_dev(img, "class", "svelte-h7ztm5");
    			add_location(img, file$1f, 349, 8, 14453);
    			attr_dev(div2, "class", "user-data__download js-open-popup-activator svelte-h7ztm5");
    			attr_dev(div2, "data-role", "download-image-popup");
    			add_location(div2, file$1f, 350, 8, 14517);
    			attr_dev(div3, "class", "user-data__avatar svelte-h7ztm5");
    			add_location(div3, file$1f, 348, 4, 14413);
    			attr_dev(div4, "class", "user-data__name svelte-h7ztm5");
    			add_location(div4, file$1f, 355, 4, 14700);
    			attr_dev(div5, "class", "user-data__company svelte-h7ztm5");
    			add_location(div5, file$1f, 356, 4, 14748);
    			attr_dev(div6, "class", "user-data__email svelte-h7ztm5");
    			add_location(div6, file$1f, 357, 4, 14800);
    			attr_dev(div7, "class", "hash svelte-h7ztm5");
    			add_location(div7, file$1f, 359, 8, 14894);
    			attr_dev(div8, "class", "group-tags__header svelte-h7ztm5");
    			add_location(div8, file$1f, 362, 16, 15017);
    			attr_dev(div9, "class", "group-tags__elem svelte-h7ztm5");
    			add_location(div9, file$1f, 363, 16, 15082);
    			attr_dev(div10, "class", "group-tags__item svelte-h7ztm5");
    			add_location(div10, file$1f, 361, 12, 14970);
    			attr_dev(div11, "class", "group-tags__header svelte-h7ztm5");
    			add_location(div11, file$1f, 366, 16, 15203);
    			attr_dev(div12, "class", "group-tags__elem svelte-h7ztm5");
    			add_location(div12, file$1f, 367, 16, 15268);
    			attr_dev(div13, "class", "group-tags__item svelte-h7ztm5");
    			add_location(div13, file$1f, 365, 12, 15156);
    			attr_dev(div14, "class", "group-tags__header svelte-h7ztm5");
    			add_location(div14, file$1f, 370, 16, 15389);
    			attr_dev(div15, "class", "group-tags__elem svelte-h7ztm5");
    			add_location(div15, file$1f, 371, 16, 15454);
    			attr_dev(div16, "class", "group-tags__item svelte-h7ztm5");
    			add_location(div16, file$1f, 369, 12, 15342);
    			attr_dev(div17, "class", "group-tags__header svelte-h7ztm5");
    			add_location(div17, file$1f, 374, 16, 15575);
    			attr_dev(div18, "class", "group-tags__elem svelte-h7ztm5");
    			add_location(div18, file$1f, 375, 16, 15640);
    			attr_dev(div19, "class", "group-tags__item svelte-h7ztm5");
    			add_location(div19, file$1f, 373, 12, 15528);
    			attr_dev(div20, "class", "group-tags__header svelte-h7ztm5");
    			add_location(div20, file$1f, 378, 16, 15761);
    			attr_dev(div21, "class", "group-tags__elem svelte-h7ztm5");
    			add_location(div21, file$1f, 379, 16, 15826);
    			attr_dev(div22, "class", "group-tags__item svelte-h7ztm5");
    			add_location(div22, file$1f, 377, 12, 15714);
    			attr_dev(div23, "class", "group-tags__header svelte-h7ztm5");
    			add_location(div23, file$1f, 382, 16, 15947);
    			attr_dev(div24, "class", "group-tags__elem svelte-h7ztm5");
    			add_location(div24, file$1f, 383, 16, 16012);
    			attr_dev(div25, "class", "group-tags__item svelte-h7ztm5");
    			add_location(div25, file$1f, 381, 12, 15900);
    			attr_dev(div26, "class", "group-tags__list svelte-h7ztm5");
    			add_location(div26, file$1f, 360, 8, 14927);
    			attr_dev(div27, "class", "group-tags svelte-h7ztm5");
    			add_location(div27, file$1f, 358, 4, 14861);
    			attr_dev(div28, "class", "user-data svelte-h7ztm5");
    			add_location(div28, file$1f, 339, 0, 14084);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div28, anchor);
    			append_dev(div28, div0);
    			append_dev(div28, t2);
    			append_dev(div28, div1);
    			append_dev(div28, t4);
    			append_dev(div28, div3);
    			append_dev(div3, img);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div28, t6);
    			append_dev(div28, div4);
    			append_dev(div28, t8);
    			append_dev(div28, div5);
    			append_dev(div28, t10);
    			append_dev(div28, div6);
    			append_dev(div28, t12);
    			append_dev(div28, div27);
    			append_dev(div27, div7);
    			append_dev(div27, t13);
    			append_dev(div27, div26);
    			append_dev(div26, div10);
    			append_dev(div10, div8);
    			append_dev(div10, t15);
    			append_dev(div10, div9);
    			append_dev(div26, t17);
    			append_dev(div26, div13);
    			append_dev(div13, div11);
    			append_dev(div13, t19);
    			append_dev(div13, div12);
    			append_dev(div26, t21);
    			append_dev(div26, div16);
    			append_dev(div16, div14);
    			append_dev(div16, t23);
    			append_dev(div16, div15);
    			append_dev(div26, t25);
    			append_dev(div26, div19);
    			append_dev(div19, div17);
    			append_dev(div19, t27);
    			append_dev(div19, div18);
    			append_dev(div26, t29);
    			append_dev(div26, div22);
    			append_dev(div22, div20);
    			append_dev(div22, t31);
    			append_dev(div22, div21);
    			append_dev(div26, t33);
    			append_dev(div26, div25);
    			append_dev(div25, div23);
    			append_dev(div25, t35);
    			append_dev(div25, div24);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(div1, "click", prevent_default(/*popupClickHandler*/ ctx[3]), false, true, false),
    					listen_dev(div2, "click", prevent_default(/*popupClickHandler*/ ctx[3]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isEditProfilePopupOpened*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isEditProfilePopupOpened*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$j(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isDownloadImagePopupOpened*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isDownloadImagePopupOpened*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$y(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div28);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserData", slots, []);

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	let isEditProfilePopupOpened = false;
    	let isDownloadImagePopupOpened = false;

    	/**
     * Popup external click handler
     * @param event
     */
    	const popupClickHandler = event => {
    		const ROLE = event.target.dataset.role;

    		// console.log(event.target);
    		// console.log('ROLE', ROLE);
    		switch (ROLE) {
    			case "popup-close":
    				$$invalidate(0, isEditProfilePopupOpened = false);
    				$$invalidate(1, isDownloadImagePopupOpened = false);
    				break;
    			case "edit-user-data-popup":
    				$$invalidate(0, isEditProfilePopupOpened = true);
    				break;
    			case "close-edit-profile-popup":
    				$$invalidate(0, isEditProfilePopupOpened = false);
    				break;
    			case "download-image-popup":
    				$$invalidate(1, isDownloadImagePopupOpened = true);
    				break;
    			case "close-download-image-popup":
    				$$invalidate(1, isDownloadImagePopupOpened = false);
    				break;
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserData> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$capture_state = () => ({
    		translations,
    		EditProfile,
    		DownloadImage,
    		ModalWindow,
    		LANG,
    		isEditProfilePopupOpened,
    		isDownloadImagePopupOpened,
    		popupClickHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("isEditProfilePopupOpened" in $$props) $$invalidate(0, isEditProfilePopupOpened = $$props.isEditProfilePopupOpened);
    		if ("isDownloadImagePopupOpened" in $$props) $$invalidate(1, isDownloadImagePopupOpened = $$props.isDownloadImagePopupOpened);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isEditProfilePopupOpened,
    		isDownloadImagePopupOpened,
    		LANG,
    		popupClickHandler,
    		click_handler
    	];
    }

    class UserData extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserData",
    			options,
    			id: create_fragment$1h.name
    		});
    	}
    }

    /* src/components/news-feed/Search.svelte generated by Svelte v3.32.1 */
    const file$1g = "src/components/news-feed/Search.svelte";

    function create_fragment$1i(ctx) {
    	let div;
    	let input;
    	let input_class_value;
    	let t;
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			span = element("span");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "name", "search-tag-name");
    			attr_dev(input, "class", input_class_value = "search__input " + (/*queryTagInputStatus*/ ctx[0] ? "active" : "") + " svelte-pa54tt");
    			attr_dev(input, "placeholder", translations[/*LANG*/ ctx[1]].search.search_placeholder);
    			add_location(input, file$1g, 90, 4, 4519);
    			attr_dev(span, "class", "search__btn svelte-pa54tt");
    			add_location(span, file$1g, 95, 4, 4723);
    			attr_dev(div, "class", "search svelte-pa54tt");
    			add_location(div, file$1g, 89, 0, 4494);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			append_dev(div, t);
    			append_dev(div, span);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", prevent_default(/*searchFormHandler*/ ctx[2]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*queryTagInputStatus*/ 1 && input_class_value !== (input_class_value = "search__input " + (/*queryTagInputStatus*/ ctx[0] ? "active" : "") + " svelte-pa54tt")) {
    				attr_dev(input, "class", input_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Search", slots, []);
    	let searchElem = document.querySelector(".search");
    	let queryTagInputStatus = false;
    	const dispatch = createEventDispatcher();

    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	const searchFormHandler = event => $$invalidate(0, queryTagInputStatus = !queryTagInputStatus);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Search> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		translations,
    		searchElem,
    		queryTagInputStatus,
    		dispatch,
    		LANG,
    		searchFormHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("searchElem" in $$props) searchElem = $$props.searchElem;
    		if ("queryTagInputStatus" in $$props) $$invalidate(0, queryTagInputStatus = $$props.queryTagInputStatus);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [queryTagInputStatus, LANG, searchFormHandler];
    }

    class Search extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Search",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    /* src/components/news-feed/TagsArea.svelte generated by Svelte v3.32.1 */

    const { Object: Object_1$9 } = globals;
    const file$1h = "src/components/news-feed/TagsArea.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (324:8) {#each Object.keys(foundedTagsData) as tag, index (index)}
    function create_each_block$k(key_1, ctx) {
    	let button;
    	let t0_value = /*foundedTagsData*/ ctx[0][/*tag*/ ctx[3]] + "";
    	let t0;
    	let t1;
    	let button_data_name_value;
    	let mounted;
    	let dispose;

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			button = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(button, "class", "tags-area__tag svelte-11qtbac");
    			attr_dev(button, "data-name", button_data_name_value = /*foundedTagsData*/ ctx[0][/*tag*/ ctx[3]]);
    			add_location(button, file$1h, 324, 12, 10113);
    			this.first = button;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*sortPostsByTagHandler*/ ctx[2]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*foundedTagsData*/ 1 && t0_value !== (t0_value = /*foundedTagsData*/ ctx[0][/*tag*/ ctx[3]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*foundedTagsData*/ 1 && button_data_name_value !== (button_data_name_value = /*foundedTagsData*/ ctx[0][/*tag*/ ctx[3]])) {
    				attr_dev(button, "data-name", button_data_name_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(324:8) {#each Object.keys(foundedTagsData) as tag, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let div1;
    	let div0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let search;
    	let current;
    	let each_value = Object.keys(/*foundedTagsData*/ ctx[0]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[5];
    	validate_each_keys(ctx, each_value, get_each_context$k, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$k(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$k(key, child_ctx));
    	}

    	search = new Search({ $$inline: true });
    	search.$on("submit", /*searchFormSubmitHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			create_component(search.$$.fragment);
    			attr_dev(div0, "class", "tags-area__tags");
    			add_location(div0, file$1h, 322, 4, 10004);
    			attr_dev(div1, "class", "tags-area svelte-11qtbac");
    			add_location(div1, file$1h, 321, 0, 9976);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div1, t);
    			mount_component(search, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*foundedTagsData, Object, sortPostsByTagHandler*/ 5) {
    				each_value = Object.keys(/*foundedTagsData*/ ctx[0]);
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$k, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, destroy_block, create_each_block$k, null, get_each_context$k);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(search.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(search.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(search);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TagsArea", slots, []);
    	let foundedTagsData = "";

    	const searchFormSubmitHandler = async event => {
    		//const queryValue = event.target['search-tag-name'];
    		new FormData(event.target);

    		// TODO : Test data
    		//let communityId = 12;
    		//const res = await sendDataToBackend(SEARCH_TAGS_ENDPOINT+communityId, formData);
    		//foundedTagsData = await res.json();
    		$$invalidate(0, foundedTagsData = { name: "CEO" });
    	};

    	const sortPostsByTagHandler = event => {
    		const tagName = event.target.dataset?.name;
    		if (!tagName) return;
    		dispatch("sortPostsByTag", { tag_name: tagName });
    	};

    	const writable_props = [];

    	Object_1$9.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TagsArea> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Search,
    		foundedTagsData,
    		searchFormSubmitHandler,
    		sortPostsByTagHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("foundedTagsData" in $$props) $$invalidate(0, foundedTagsData = $$props.foundedTagsData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [foundedTagsData, searchFormSubmitHandler, sortPostsByTagHandler];
    }

    class TagsArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagsArea",
    			options,
    			id: create_fragment$1j.name
    		});
    	}
    }

    // Fallback locale.
    // (when not a single one of the supplied "preferred" locales is available)
    var defaultLocale = 'en'; // For all locales added
    // their relative time formatter messages will be stored here.

    var localesData = {}; // According to the spec BCP 47 language tags are case-insensitive.
    // https://tools.ietf.org/html/rfc5646

    var lowercaseLocaleLookup = {};
    function getDefaultLocale() {
      return defaultLocale;
    }
    function setDefaultLocale(locale) {
      defaultLocale = locale;
    }
    /**
     * Gets locale data previously added by `addLocaleData()`.
     * @return  {object} [localeData]
     */

    function getLocaleData(locale) {
      return localesData[locale];
    }
    /**
     * Adds locale data.
     * Is called by `RelativeTimeFormat.addLocale(...)`.
     * @param  {object} localeData
     */

    function addLocaleData(localeData) {
      if (!localeData) {
        throw new Error('No locale data passed');
      } // This locale data is stored in a global variable
      // and later used when calling `.format(time)`.


      localesData[localeData.locale] = localeData;
      lowercaseLocaleLookup[localeData.locale.toLowerCase()] = localeData.locale;
    }
    /**
     * Returns a locale for which locale data has been added
     * via `RelativeTimeFormat.addLocale(...)`.
     * @param  {string} locale
     * @return {string} [locale]
     */

    function resolveLocale(locale) {
      if (localesData[locale]) {
        return locale;
      }

      if (lowercaseLocaleLookup[locale.toLowerCase()]) {
        return lowercaseLocaleLookup[locale.toLowerCase()];
      }
    }

    /**
     * Resolves a locale to a supported one (if any).
     * @param  {string} locale
     * @param {Object} [options] - An object that may have the following property:
     * @param {string} [options.localeMatcher="lookup"] - The locale matching algorithm to use. Possible values are "lookup" and "best fit". Currently only "lookup" is supported.
     * @return {string} [locale]
     * @example
     * // Returns "sr"
     * resolveLocale("sr-Cyrl-BA")
     * // Returns `undefined`
     * resolveLocale("xx-Latn")
     */

    function resolveLocale$1(locale) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var localeMatcher = options.localeMatcher || 'lookup';

      switch (localeMatcher) {
        case 'lookup':
          return resolveLocaleLookup(locale);
        // "best fit" locale matching is not supported.
        // https://github.com/catamphetamine/relative-time-format/issues/2

        case 'best fit':
          // return resolveLocaleBestFit(locale)
          return resolveLocaleLookup(locale);

        default:
          throw new RangeError("Invalid \"localeMatcher\" option: ".concat(localeMatcher));
      }
    }
    /**
     * Resolves a locale to a supported one (if any).
     * Starts from the most specific locale and gradually
     * falls back to less specific ones.
     * This is a basic implementation of the "lookup" algorithm.
     * https://tools.ietf.org/html/rfc4647#section-3.4
     * @param  {string} locale
     * @return {string} [locale]
     * @example
     * // Returns "sr"
     * resolveLocaleLookup("sr-Cyrl-BA")
     * // Returns `undefined`
     * resolveLocaleLookup("xx-Latn")
     */

    function resolveLocaleLookup(locale) {
      var resolvedLocale = resolveLocale(locale);

      if (resolvedLocale) {
        return resolvedLocale;
      } // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.


      var parts = locale.split('-');

      while (locale.length > 1) {
        parts.pop();
        locale = parts.join('-');

        var _resolvedLocale = resolveLocale(locale);

        if (_resolvedLocale) {
          return _resolvedLocale;
        }
      }
    }

    // (this file was autogenerated by `generate-locales`)
    // "plural rules" functions are not stored in locale JSON files because they're not strings.
    // This file isn't big — it's about 5 kilobytes in size (minified).
    // Alternatively, the pluralization rules for each locale could be stored
    // in their JSON files in a non-parsed form and later parsed via `make-plural` library.
    // But `make-plural` library itself is relatively big in size:
    // `make-plural.min.js` is about 6 kilobytes (https://unpkg.com/make-plural/).
    // So, it's more practical to bypass runtime `make-plural` pluralization rules compilation
    // and just include the already compiled pluarlization rules for all locales in the library code.
    var $ = {
      af: function classify(n) {
        return n == 1 ? 'one' : 'other';
      },
      am: function classify(n) {
        return n >= 0 && n <= 1 ? 'one' : 'other';
      },
      ar: function classify(n) {
        var s = String(n).split('.'),
            t0 = Number(s[0]) == n,
            n100 = t0 && s[0].slice(-2);
        return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n100 >= 3 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 99 ? 'many' : 'other';
      },
      ast: function classify(n) {
        var s = String(n).split('.'),
            v0 = !s[1];
        return n == 1 && v0 ? 'one' : 'other';
      },
      be: function classify(n) {
        var s = String(n).split('.'),
            t0 = Number(s[0]) == n,
            n10 = t0 && s[0].slice(-1),
            n100 = t0 && s[0].slice(-2);
        return n10 == 1 && n100 != 11 ? 'one' : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? 'few' : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? 'many' : 'other';
      },
      br: function classify(n) {
        var s = String(n).split('.'),
            t0 = Number(s[0]) == n,
            n10 = t0 && s[0].slice(-1),
            n100 = t0 && s[0].slice(-2),
            n1000000 = t0 && s[0].slice(-6);
        return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? 'one' : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? 'two' : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? 'few' : n != 0 && t0 && n1000000 == 0 ? 'many' : 'other';
      },
      bs: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            f = s[1] || '',
            v0 = !s[1],
            i10 = i.slice(-1),
            i100 = i.slice(-2),
            f10 = f.slice(-1),
            f100 = f.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';
      },
      cs: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            v0 = !s[1];
        return n == 1 && v0 ? 'one' : i >= 2 && i <= 4 && v0 ? 'few' : !v0 ? 'many' : 'other';
      },
      cy: function classify(n) {
        return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n == 3 ? 'few' : n == 6 ? 'many' : 'other';
      },
      da: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            t0 = Number(s[0]) == n;
        return n == 1 || !t0 && (i == 0 || i == 1) ? 'one' : 'other';
      },
      dsb: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            f = s[1] || '',
            v0 = !s[1],
            i100 = i.slice(-2),
            f100 = f.slice(-2);
        return v0 && i100 == 1 || f100 == 1 ? 'one' : v0 && i100 == 2 || f100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? 'few' : 'other';
      },
      dz: function classify(n) {
        return 'other';
      },
      fil: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            f = s[1] || '',
            v0 = !s[1],
            i10 = i.slice(-1),
            f10 = f.slice(-1);
        return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? 'one' : 'other';
      },
      fr: function classify(n) {
        return n >= 0 && n < 2 ? 'one' : 'other';
      },
      ga: function classify(n) {
        var s = String(n).split('.'),
            t0 = Number(s[0]) == n;
        return n == 1 ? 'one' : n == 2 ? 'two' : t0 && n >= 3 && n <= 6 ? 'few' : t0 && n >= 7 && n <= 10 ? 'many' : 'other';
      },
      gd: function classify(n) {
        var s = String(n).split('.'),
            t0 = Number(s[0]) == n;
        return n == 1 || n == 11 ? 'one' : n == 2 || n == 12 ? 'two' : t0 && n >= 3 && n <= 10 || t0 && n >= 13 && n <= 19 ? 'few' : 'other';
      },
      he: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            v0 = !s[1],
            t0 = Number(s[0]) == n,
            n10 = t0 && s[0].slice(-1);
        return n == 1 && v0 ? 'one' : i == 2 && v0 ? 'two' : v0 && (n < 0 || n > 10) && t0 && n10 == 0 ? 'many' : 'other';
      },
      is: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            t0 = Number(s[0]) == n,
            i10 = i.slice(-1),
            i100 = i.slice(-2);
        return t0 && i10 == 1 && i100 != 11 || !t0 ? 'one' : 'other';
      },
      ksh: function classify(n) {
        return n == 0 ? 'zero' : n == 1 ? 'one' : 'other';
      },
      lt: function classify(n) {
        var s = String(n).split('.'),
            f = s[1] || '',
            t0 = Number(s[0]) == n,
            n10 = t0 && s[0].slice(-1),
            n100 = t0 && s[0].slice(-2);
        return n10 == 1 && (n100 < 11 || n100 > 19) ? 'one' : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? 'few' : f != 0 ? 'many' : 'other';
      },
      lv: function classify(n) {
        var s = String(n).split('.'),
            f = s[1] || '',
            v = f.length,
            t0 = Number(s[0]) == n,
            n10 = t0 && s[0].slice(-1),
            n100 = t0 && s[0].slice(-2),
            f100 = f.slice(-2),
            f10 = f.slice(-1);
        return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? 'zero' : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? 'one' : 'other';
      },
      mk: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            f = s[1] || '',
            v0 = !s[1],
            i10 = i.slice(-1),
            i100 = i.slice(-2),
            f10 = f.slice(-1),
            f100 = f.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : 'other';
      },
      mt: function classify(n) {
        var s = String(n).split('.'),
            t0 = Number(s[0]) == n,
            n100 = t0 && s[0].slice(-2);
        return n == 1 ? 'one' : n == 0 || n100 >= 2 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 19 ? 'many' : 'other';
      },
      pa: function classify(n) {
        return n == 0 || n == 1 ? 'one' : 'other';
      },
      pl: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            v0 = !s[1],
            i10 = i.slice(-1),
            i100 = i.slice(-2);
        return n == 1 && v0 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i != 1 && (i10 == 0 || i10 == 1) || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 12 && i100 <= 14 ? 'many' : 'other';
      },
      pt: function classify(n) {
        var s = String(n).split('.'),
            i = s[0];
        return i == 0 || i == 1 ? 'one' : 'other';
      },
      ro: function classify(n) {
        var s = String(n).split('.'),
            v0 = !s[1],
            t0 = Number(s[0]) == n,
            n100 = t0 && s[0].slice(-2);
        return n == 1 && v0 ? 'one' : !v0 || n == 0 || n != 1 && n100 >= 1 && n100 <= 19 ? 'few' : 'other';
      },
      ru: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            v0 = !s[1],
            i10 = i.slice(-1),
            i100 = i.slice(-2);
        return v0 && i10 == 1 && i100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? 'many' : 'other';
      },
      se: function classify(n) {
        return n == 1 ? 'one' : n == 2 ? 'two' : 'other';
      },
      si: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            f = s[1] || '';
        return n == 0 || n == 1 || i == 0 && f == 1 ? 'one' : 'other';
      },
      sl: function classify(n) {
        var s = String(n).split('.'),
            i = s[0],
            v0 = !s[1],
            i100 = i.slice(-2);
        return v0 && i100 == 1 ? 'one' : v0 && i100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || !v0 ? 'few' : 'other';
      }
    };
    $.as = $.am;
    $.az = $.af;
    $.bg = $.af;
    $.bn = $.am;
    $.ca = $.ast;
    $.ce = $.af;
    $.chr = $.af;
    $.de = $.ast;
    $.ee = $.af;
    $.el = $.af;
    $.en = $.ast;
    $.es = $.af;
    $.et = $.ast;
    $.eu = $.af;
    $.fa = $.am;
    $.fi = $.ast;
    $.fo = $.af;
    $.fur = $.af;
    $.fy = $.ast;
    $.gl = $.ast;
    $.gu = $.am;
    $.hi = $.am;
    $.hr = $.bs;
    $.hsb = $.dsb;
    $.hu = $.af;
    $.hy = $.fr;
    $.ia = $.ast;
    $.id = $.dz;
    $.it = $.ast;
    $.ja = $.dz;
    $.jgo = $.af;
    $.jv = $.dz;
    $.ka = $.af;
    $.kea = $.dz;
    $.kk = $.af;
    $.kl = $.af;
    $.km = $.dz;
    $.kn = $.am;
    $.ko = $.dz;
    $.ku = $.af;
    $.ky = $.af;
    $.lb = $.af;
    $.lkt = $.dz;
    $.lo = $.dz;
    $.ml = $.af;
    $.mn = $.af;
    $.mr = $.am;
    $.ms = $.dz;
    $.my = $.dz;
    $.nb = $.af;
    $.ne = $.af;
    $.nl = $.ast;
    $.nn = $.af;
    $.or = $.af;
    $.ps = $.af;
    $["pt-PT"] = $.ast;
    $.sah = $.dz;
    $.sd = $.af;
    $.sk = $.cs;
    $.so = $.af;
    $.sq = $.af;
    $.sr = $.bs;
    $.sv = $.ast;
    $.sw = $.ast;
    $.ta = $.af;
    $.te = $.af;
    $.th = $.dz;
    $.ti = $.pa;
    $.tk = $.af;
    $.to = $.dz;
    $.tr = $.af;
    $.ug = $.af;
    $.uk = $.ru;
    $.ur = $.ast;
    $.uz = $.af;
    $.vi = $.dz;
    $.wae = $.af;
    $.yi = $.ast;
    $.yue = $.dz;
    $.zh = $.dz;
    $.zu = $.am;

    /**
     * Returns a `locale` for which a function exists in `./PluralRuleFunctions.js`.
     * @param  {string} locale
     * @return {string}
     * @example
     * getPluralRulesLocale("ru-RU-Cyrl") // Returns "ru".
     */
    function getPluralRulesLocale(locale) {
      // "pt" language is the only one having different pluralization rules
      // for the one ("pt") (Portuguese) locale and the other ("pt-PT") (European Portuguese).
      // http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html
      // (see the entries for "pt" and "pt_PT" there)
      if (locale === 'pt-PT') {
        return locale;
      }

      return getLanguageFromLanguageTag(locale);
    }
    /**
     * Extracts language from an IETF BCP 47 language tag.
     * @param {string} languageTag - IETF BCP 47 language tag.
     * @return {string}
     * @example
     * // Returns "he"
     * getLanguageFromLanguageTag("he-IL-u-ca-hebrew-tz-jeruslm")
     * // Returns "ar"
     * getLanguageFromLanguageTag("ar-u-nu-latn")
     */

    var LANGUAGE_REG_EXP = /^([a-z0-9]+)/i;

    function getLanguageFromLanguageTag(languageTag) {
      var match = languageTag.match(LANGUAGE_REG_EXP);

      if (!match) {
        throw new TypeError("Invalid locale: ".concat(languageTag));
      }

      return match[1];
    }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
    /**
     * `Intl.PluralRules` polyfill.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/PluralRules
     */

    var PluralRules =
    /*#__PURE__*/
    function () {
      function PluralRules(locale, options) {
        _classCallCheck(this, PluralRules);

        var locales = PluralRules.supportedLocalesOf(locale);

        if (locales.length === 0) {
          throw new RangeError("Unsupported locale: " + locale);
        }

        if (options && options.type !== "cardinal") {
          throw new RangeError("Only \"cardinal\" \"type\" is supported");
        }

        this.$ = $[getPluralRulesLocale(locales[0])];
      }

      _createClass(PluralRules, [{
        key: "select",
        value: function select(number) {
          return this.$(number);
        }
      }], [{
        key: "supportedLocalesOf",
        value: function supportedLocalesOf(locales) {
          if (typeof locales === "string") {
            locales = [locales];
          }

          return locales.filter(function (locale) {
            return $[getPluralRulesLocale(locale)];
          });
        }
      }]);

      return PluralRules;
    }();

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

    function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

    function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

    function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

    function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    // results in a bundle that is larger by 1kB for some reason.
    // import PluralRules from 'intl-plural-rules-polyfill/cardinal'
    // Valid time units.

    var UNITS = ["second", "minute", "hour", "day", "week", "month", "quarter", "year"]; // Valid values for the `numeric` option.

    var NUMERIC_VALUES = ["auto", "always"]; // Valid values for the `style` option.

    var STYLE_VALUES = ["long", "short", "narrow"]; // Valid values for the `localeMatcher` option.

    var LOCALE_MATCHER_VALUES = ["lookup", "best fit"];
    /**
     * Polyfill for `Intl.RelativeTimeFormat` proposal.
     * https://github.com/tc39/proposal-intl-relative-time
     * https://github.com/tc39/proposal-intl-relative-time/issues/55
     */

    var RelativeTimeFormat =
    /*#__PURE__*/
    function () {
      /**
       * @param {(string|string[])} [locales] - Preferred locales (or locale).
       * @param {Object} [options] - Formatting options.
       * @param {string} [options.style="long"] - One of: "long", "short", "narrow".
       * @param {string} [options.numeric="always"] - (Version >= 2) One of: "always", "auto".
       * @param {string} [options.localeMatcher="lookup"] - One of: "lookup", "best fit". Currently only "lookup" is supported.
       */
      function RelativeTimeFormat() {
        var locales = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck$1(this, RelativeTimeFormat);

        _defineProperty(this, "numeric", "always");

        _defineProperty(this, "style", "long");

        _defineProperty(this, "localeMatcher", "lookup");

        var numeric = options.numeric,
            style = options.style,
            localeMatcher = options.localeMatcher; // Set `numeric` option.

        if (numeric !== undefined) {
          if (NUMERIC_VALUES.indexOf(numeric) < 0) {
            throw new RangeError("Invalid \"numeric\" option: ".concat(numeric));
          }

          this.numeric = numeric;
        } // Set `style` option.


        if (style !== undefined) {
          if (STYLE_VALUES.indexOf(style) < 0) {
            throw new RangeError("Invalid \"style\" option: ".concat(style));
          }

          this.style = style;
        } // Set `localeMatcher` option.


        if (localeMatcher !== undefined) {
          if (LOCALE_MATCHER_VALUES.indexOf(localeMatcher) < 0) {
            throw new RangeError("Invalid \"localeMatcher\" option: ".concat(localeMatcher));
          }

          this.localeMatcher = localeMatcher;
        } // Set `locale`.
        // Convert `locales` to an array.


        if (typeof locales === 'string') {
          locales = [locales];
        } // Add default locale.


        locales.push(getDefaultLocale()); // Choose the most appropriate locale.

        this.locale = RelativeTimeFormat.supportedLocalesOf(locales, {
          localeMatcher: this.localeMatcher
        })[0];

        if (!this.locale) {
          throw new Error("No supported locale was found");
        } // Construct an `Intl.PluralRules` instance (polyfill).


        if (PluralRules.supportedLocalesOf(this.locale).length > 0) {
          this.pluralRules = new PluralRules(this.locale);
        } else {
          console.warn("\"".concat(this.locale, "\" locale is not supported"));
        } // Use `Intl.NumberFormat` for formatting numbers (when available).


        if (typeof Intl !== 'undefined' && Intl.NumberFormat) {
          this.numberFormat = new Intl.NumberFormat(this.locale);
          this.numberingSystem = this.numberFormat.resolvedOptions().numberingSystem;
        } else {
          this.numberingSystem = 'latn';
        }

        this.locale = resolveLocale$1(this.locale, {
          localeMatcher: this.localeMatcher
        });
      }
      /**
       * Formats time `number` in `units` (either in past or in future).
       * @param {number} number - Time interval value.
       * @param {string} unit - Time interval measurement unit.
       * @return {string}
       * @throws {RangeError} If unit is not one of "second", "minute", "hour", "day", "week", "month", "quarter".
       * @example
       * // Returns "2 days ago"
       * rtf.format(-2, "day")
       * // Returns "in 5 minutes"
       * rtf.format(5, "minute")
       */


      _createClass$1(RelativeTimeFormat, [{
        key: "format",
        value: function format() {
          var _parseFormatArgs = parseFormatArgs(arguments),
              _parseFormatArgs2 = _slicedToArray(_parseFormatArgs, 2),
              number = _parseFormatArgs2[0],
              unit = _parseFormatArgs2[1];

          return this.getRule(number, unit).replace('{0}', this.formatNumber(Math.abs(number)));
        }
        /**
         * Formats time `number` in `units` (either in past or in future).
         * @param {number} number - Time interval value.
         * @param {string} unit - Time interval measurement unit.
         * @return {Object[]} The parts (`{ type, value }`).
         * @throws {RangeError} If unit is not one of "second", "minute", "hour", "day", "week", "month", "quarter".
         * @example
         * // Version 1.
         * // Returns [
         * //   { type: "literal", value: "in " },
         * //   { type: "day", value: "100" },
         * //   { type: "literal", value: " days" }
         * // ]
         * rtf.formatToParts(100, "day")
         * //
         * // Version 2.
         * // Returns [
         * //   { type: "literal", value: "in " },
         * //   { type: "integer", value: "100", unit: "day" },
         * //   { type: "literal", value: " days" }
         * // ]
         * rtf.formatToParts(100, "day")
         */

      }, {
        key: "formatToParts",
        value: function formatToParts() {
          var _parseFormatArgs3 = parseFormatArgs(arguments),
              _parseFormatArgs4 = _slicedToArray(_parseFormatArgs3, 2),
              number = _parseFormatArgs4[0],
              unit = _parseFormatArgs4[1];

          var rule = this.getRule(number, unit);
          var valueIndex = rule.indexOf("{0}"); // "yesterday"/"today"/"tomorrow".

          if (valueIndex < 0) {
            return [{
              type: "literal",
              value: rule
            }];
          }

          var parts = [];

          if (valueIndex > 0) {
            parts.push({
              type: "literal",
              value: rule.slice(0, valueIndex)
            });
          }

          parts = parts.concat(this.formatNumberToParts(Math.abs(number)).map(function (part) {
            return _objectSpread({}, part, {
              unit: unit
            });
          }));

          if (valueIndex + "{0}".length < rule.length - 1) {
            parts.push({
              type: "literal",
              value: rule.slice(valueIndex + "{0}".length)
            });
          }

          return parts;
        }
        /**
         * Returns formatting rule for `value` in `units` (either in past or in future).
         * @param {number} value - Time interval value.
         * @param {string} unit - Time interval measurement unit.
         * @return {string}
         * @throws {RangeError} If unit is not one of "second", "minute", "hour", "day", "week", "month", "quarter".
         * @example
         * // Returns "{0} days ago"
         * getRule(-2, "day")
         */

      }, {
        key: "getRule",
        value: function getRule(value, unit) {
          // Get locale-specific time interval formatting rules
          // of a given `style` for the given value of measurement `unit`.
          //
          // E.g.:
          //
          // ```json
          // {
          //  "past": {
          //    "one": "a second ago",
          //    "other": "{0} seconds ago"
          //  },
          //  "future": {
          //    "one": "in a second",
          //    "other": "in {0} seconds"
          //  }
          // }
          // ```
          //
          var unitMessages = getLocaleData(this.locale)[this.style][unit]; // Special case for "yesterday"/"today"/"tomorrow".

          if (this.numeric === "auto") {
            // "yesterday", "the day before yesterday", etc.
            if (value === -2 || value === -1) {
              var message = unitMessages["previous".concat(value === -1 ? '' : '-' + Math.abs(value))];

              if (message) {
                return message;
              }
            } // "tomorrow", "the day after tomorrow", etc.
            else if (value === 1 || value === 2) {
                var _message = unitMessages["next".concat(value === 1 ? '' : '-' + Math.abs(value))];

                if (_message) {
                  return _message;
                }
              } // "today"
              else if (value === 0) {
                  if (unitMessages.current) {
                    return unitMessages.current;
                  }
                }
          } // Choose either "past" or "future" based on time `value` sign.
          // If there's only "other" then it's being collapsed.
          // (the resulting bundle size optimization technique)


          var pluralizedMessages = unitMessages[isNegative(value) ? "past" : "future"]; // Bundle size optimization technique.

          if (typeof pluralizedMessages === "string") {
            return pluralizedMessages;
          } // Quantify `value`.
          // There seems to be no such locale in CLDR
          // for which "plural rules" function is missing.


          var quantifier = this.pluralRules && this.pluralRules.select(Math.abs(value)) || 'other'; // "other" rule is supposed to be always present.
          // If only "other" rule is present then "rules" is not an object and is a string.

          return pluralizedMessages[quantifier] || pluralizedMessages.other;
        }
        /**
         * Formats a number into a string.
         * Uses `Intl.NumberFormat` when available.
         * @param  {number} number
         * @return {string}
         */

      }, {
        key: "formatNumber",
        value: function formatNumber(number) {
          return this.numberFormat ? this.numberFormat.format(number) : String(number);
        }
        /**
         * Formats a number into a list of parts.
         * Uses `Intl.NumberFormat` when available.
         * @param  {number} number
         * @return {object[]}
         */

      }, {
        key: "formatNumberToParts",
        value: function formatNumberToParts(number) {
          // `Intl.NumberFormat.formatToParts()` is not present, for example,
          // in Node.js 8.x while `Intl.NumberFormat` itself is present.
          return this.numberFormat && this.numberFormat.formatToParts ? this.numberFormat.formatToParts(number) : [{
            type: "integer",
            value: this.formatNumber(number)
          }];
        }
        /**
         * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions
         * @return {Object}
         */

      }, {
        key: "resolvedOptions",
        value: function resolvedOptions() {
          return {
            locale: this.locale,
            style: this.style,
            numeric: this.numeric,
            numberingSystem: this.numberingSystem
          };
        }
      }]);

      return RelativeTimeFormat;
    }();

    RelativeTimeFormat.supportedLocalesOf = function (locales) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Convert `locales` to an array.
      if (typeof locales === 'string') {
        locales = [locales];
      } else if (!Array.isArray(locales)) {
        throw new TypeError('Invalid "locales" argument');
      }

      return locales.filter(function (locale) {
        return resolveLocale$1(locale, options);
      });
    };
    /**
     * Adds locale data for a specific locale.
     * @param {Object} localeData
     */


    RelativeTimeFormat.addLocale = addLocaleData;
    /**
     * Sets default locale.
     * @param  {string} locale
     */

    RelativeTimeFormat.setDefaultLocale = setDefaultLocale;
    /**
     * Gets default locale.
     * @return  {string} locale
     */

    RelativeTimeFormat.getDefaultLocale = getDefaultLocale;
    /**
     * Export `Intl.PluralRules` just in case it's used somewhere else.
     */

    RelativeTimeFormat.PluralRules = PluralRules; // The specification allows units to be in plural form.
    // Convert plural to singular.
    // Example: "seconds" -> "second".

    var UNIT_ERROR = 'Invalid "unit" argument';

    function parseUnit(unit) {
      if (_typeof(unit) === 'symbol') {
        throw new TypeError(UNIT_ERROR);
      }

      if (typeof unit !== 'string') {
        throw new RangeError("".concat(UNIT_ERROR, ": ").concat(unit));
      }

      if (unit[unit.length - 1] === 's') {
        unit = unit.slice(0, unit.length - 1);
      }

      if (UNITS.indexOf(unit) < 0) {
        throw new RangeError("".concat(UNIT_ERROR, ": ").concat(unit));
      }

      return unit;
    } // Converts `value` to a `Number`.
    // The specification allows value to be a non-number.
    // For example, "-0" is supposed to be treated as `-0`.
    // Also checks if `value` is a finite number.


    var NUMBER_ERROR = 'Invalid "number" argument';

    function parseNumber(value) {
      value = Number(value);

      if (Number.isFinite) {
        if (!Number.isFinite(value)) {
          throw new RangeError("".concat(NUMBER_ERROR, ": ").concat(value));
        }
      }

      return value;
    }
    /**
     * Tells `0` from `-0`.
     * https://stackoverflow.com/questions/7223359/are-0-and-0-the-same
     * @param  {number} number
     * @return {Boolean}
     * @example
     * isNegativeZero(0); // false
     * isNegativeZero(-0); // true
     */


    function isNegativeZero(number) {
      return 1 / number === -Infinity;
    }

    function isNegative(number) {
      return number < 0 || number === 0 && isNegativeZero(number);
    }

    function parseFormatArgs(args) {
      if (args.length < 2) {
        throw new TypeError("\"unit\" argument is required");
      }

      return [parseNumber(args[0]), parseUnit(args[1])];
    }

    function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

    function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    /**
     * A basic in-memory cache.
     *
     * import Cache from 'javascript-time-ago/Cache'
     * const cache = new Cache()
     * const object = cache.get('key1', 'key2', ...) || cache.put('key1', 'key2', ..., createObject())
     */
    var Cache =
    /*#__PURE__*/
    function () {
      function Cache() {
        _classCallCheck$2(this, Cache);

        _defineProperty$1(this, "cache", {});
      }

      _createClass$2(Cache, [{
        key: "get",
        value: function get() {
          var cache = this.cache;

          for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
            keys[_key] = arguments[_key];
          }

          for (var _i = 0; _i < keys.length; _i++) {
            var key = keys[_i];

            if (_typeof$1(cache) !== 'object') {
              return;
            }

            cache = cache[key];
          }

          return cache;
        }
      }, {
        key: "put",
        value: function put() {
          for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            keys[_key2] = arguments[_key2];
          }

          var value = keys.pop();
          var lastKey = keys.pop();
          var cache = this.cache;

          for (var _i2 = 0; _i2 < keys.length; _i2++) {
            var key = keys[_i2];

            if (_typeof$1(cache[key]) !== 'object') {
              cache[key] = {};
            }

            cache = cache[key];
          }

          return cache[lastKey] = value;
        }
      }]);

      return Cache;
    }();

    function _typeof$2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

    /**
     * Chooses the most appropriate locale
     * (one of the registered ones)
     * based on the list of preferred `locales` supplied by the user.
     *
     * @param {string[]} locales - the list of preferable locales (in [IETF format](https://en.wikipedia.org/wiki/IETF_language_tag)).
     * @param {Function} isLocaleDataAvailable - tests if a locale is available.
     *
     * @returns {string} The most suitable locale.
     *
     * @example
     * // Returns 'en'
     * chooseLocale(['en-US'], undefined, (locale) => locale === 'ru' || locale === 'en')
     */
    function chooseLocale(locales, isLocaleDataAvailable) {
      // This is not an intelligent algorithm,
      // but it will do for this library's case.
      // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.
      for (var _iterator = locales, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var locale = _ref;

        if (isLocaleDataAvailable(locale)) {
          return locale;
        }

        var parts = locale.split('-');

        while (parts.length > 1) {
          parts.pop();
          locale = parts.join('-');

          if (isLocaleDataAvailable(locale)) {
            return locale;
          }
        }
      }

      throw new Error("No locale data has been registered for any of the locales: ".concat(locales.join(', ')));
    }
    /**
     * Whether can use `Intl.DateTimeFormat`.
     * @return {boolean}
     */

    function intlDateTimeFormatSupported() {
      // Babel transforms `typeof` into some "branches"
      // so istanbul will show this as "branch not covered".

      /* istanbul ignore next */
      var isIntlAvailable = (typeof Intl === "undefined" ? "undefined" : _typeof$2(Intl)) === 'object';
      return isIntlAvailable && typeof Intl.DateTimeFormat === 'function';
    }

    var minute = 60; // in seconds

    var hour = 60 * minute; // in seconds

    var day = 24 * hour; // in seconds

    var week = 7 * day; // in seconds
    // https://www.quora.com/What-is-the-average-number-of-days-in-a-month

    var month = 30.44 * day; // in seconds
    // "400 years have 146097 days (taking into account leap year rules)"

    var year = 146097 / 400 * day; // in seconds

    function getSecondsInUnit(unit) {
      switch (unit) {
        case 'second':
          return 1;

        case 'minute':
          return minute;

        case 'hour':
          return hour;

        case 'day':
          return day;

        case 'week':
          return week;

        case 'month':
          return month;

        case 'year':
          return year;
      }
    } // export function getPreviousUnitFor(unit) {
    // 	switch (unit) {
    // 		case 'second':
    // 			return 'now'
    // 		case 'minute':
    // 			return 'second'
    // 		case 'hour':
    // 			return 'minute'
    // 		case 'day':
    // 			return 'hour'
    // 		case 'week':
    // 			return 'day'
    // 		case 'month':
    // 			return 'week'
    // 		case 'year':
    // 			return 'month'
    // 	}
    // }

    function getStepDenominator(step) {
      // `factor` is a legacy property.
      if (step.factor !== undefined) {
        return step.factor;
      } // "unit" is now called "formatAs".


      return getSecondsInUnit(step.unit || step.formatAs) || 1;
    }

    function getRoundFunction(round) {
      switch (round) {
        case 'floor':
          return Math.floor;

        default:
          return Math.round;
      }
    } // For non-negative numbers.

    function getDiffRatioToNextRoundedNumber(round) {
      switch (round) {
        case 'floor':
          // Math.floor(x) = x
          // Math.floor(x + 1) = x + 1
          return 1;

        default:
          // Math.round(x) = x
          // Math.round(x + 0.5) = x + 1
          return 0.5;
      }
    }

    function _typeof$3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }
    function getStepMinTime(step, _ref) {
      var prevStep = _ref.prevStep,
          timestamp = _ref.timestamp,
          now = _ref.now,
          future = _ref.future,
          round = _ref.round;
      var minTime; // "threshold_for_xxx" is a legacy property.

      if (prevStep) {
        if (prevStep.id || prevStep.unit) {
          minTime = step["threshold_for_".concat(prevStep.id || prevStep.unit)];
        }
      }

      if (minTime === undefined) {
        // "threshold" is a legacy property.
        if (step.threshold !== undefined) {
          // "threshold" is a legacy name for "minTime".
          minTime = step.threshold; // "threshold" function is deprecated.

          if (typeof minTime === 'function') {
            minTime = minTime(now, future);
          }
        }
      }

      if (minTime === undefined) {
        minTime = step.minTime;
      } // A deprecated way of specifying a different threshold
      // depending on the previous step's unit.


      if (_typeof$3(minTime) === 'object') {
        if (prevStep && prevStep.id && minTime[prevStep.id] !== undefined) {
          minTime = minTime[prevStep.id];
        } else {
          minTime = minTime.default;
        }
      }

      if (typeof minTime === 'function') {
        minTime = minTime(timestamp, {
          future: future,
          getMinTimeForUnit: function getMinTimeForUnit(toUnit, fromUnit) {
            return _getMinTimeForUnit(toUnit, fromUnit || prevStep && prevStep.formatAs, {
              round: round
            });
          }
        });
      } // Evaluate the `test()` function.
      // `test()` function is deprecated.


      if (minTime === undefined) {
        if (step.test) {
          if (step.test(timestamp, {
            now: now,
            future: future
          })) {
            // `0` threshold always passes.
            minTime = 0;
          } else {
            // `MAX_SAFE_INTEGER` threshold won't ever pass in real life.
            minTime = 9007199254740991; // Number.MAX_SAFE_INTEGER
          }
        }
      }

      if (minTime === undefined) {
        if (prevStep) {
          if (step.formatAs && prevStep.formatAs) {
            minTime = _getMinTimeForUnit(step.formatAs, prevStep.formatAs, {
              round: round
            });
          }
        } else {
          // The first step's `minTime` is `0` by default.
          minTime = 0;
        }
      } // Warn if no `minTime` was defined or could be deduced.


      if (minTime === undefined) {
        console.warn('[javascript-time-ago] A step should specify `minTime`:\n' + JSON.stringify(step, null, 2));
      }

      return minTime;
    }

    function _getMinTimeForUnit(toUnit, fromUnit, _ref2) {
      var round = _ref2.round;
      var toUnitAmount = getSecondsInUnit(toUnit); // if (!fromUnit) {
      // 	return toUnitAmount;
      // }
      // if (!fromUnit) {
      // 	fromUnit = getPreviousUnitFor(toUnit)
      // }

      var fromUnitAmount;

      if (fromUnit === 'now') {
        fromUnitAmount = getSecondsInUnit(toUnit);
      } else {
        fromUnitAmount = getSecondsInUnit(fromUnit);
      }

      if (toUnitAmount !== undefined && fromUnitAmount !== undefined) {
        return toUnitAmount - fromUnitAmount * (1 - getDiffRatioToNextRoundedNumber(round));
      }
    }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    /**
     * Finds an appropriate `step` of `steps` for the time interval (in seconds).
     *
     * @param {Object[]} steps - Time formatting steps.
     *
     * @param {number} secondsPassed - Time interval (in seconds).
     *                                 `< 0` for past dates and `> 0` for future dates.
     *
     * @param {number} options.now - Current timestamp.
     *
     * @param {boolean} [options.future] - Whether the date should be formatted as a future one
     *                                     instead of a past one.
     *
     * @param {string} [options.round] - (undocumented) Rounding mechanism.
     *
     * @param {string[]} [options.units] - A list of allowed time units.
     *                                     (Example: ['second', 'minute', 'hour', …])
     *
     * @param {boolean} [options.getNextStep] - Pass true to return `[step, nextStep]` instead of just `step`.
     *
     * @return {Object|Object[]} [step] — Either a `step` or `[prevStep, step, nextStep]`.
     */

    function getStep(steps, secondsPassed, _ref) {
      var now = _ref.now,
          future = _ref.future,
          round = _ref.round,
          units = _ref.units,
          getNextStep = _ref.getNextStep;
      // Ignore steps having not-supported time units in `formatAs`.
      steps = filterStepsByUnits(steps, units);

      var step = _getStep(steps, secondsPassed, {
        now: now,
        future: future,
        round: round
      });

      if (getNextStep) {
        if (step) {
          var prevStep = steps[steps.indexOf(step) - 1];
          var nextStep = steps[steps.indexOf(step) + 1];
          return [prevStep, step, nextStep];
        }

        return [undefined, undefined, steps[0]];
      }

      return step;
    }

    function _getStep(steps, secondsPassed, _ref2) {
      var now = _ref2.now,
          future = _ref2.future,
          round = _ref2.round;

      // If no steps fit the conditions then return nothing.
      if (steps.length === 0) {
        return;
      } // Find the most appropriate step.


      var i = getStepIndex(steps, secondsPassed, {
        now: now,
        future: future || secondsPassed < 0,
        round: round
      }); // If no step is applicable the return nothing.

      if (i === -1) {
        return;
      }

      var step = steps[i]; // Apply granularity to the time amount
      // (and fall back to the previous step
      //  if the first level of granularity
      //  isn't met by this amount)

      if (step.granularity) {
        // Recalculate the amount of seconds passed based on `granularity`.
        var secondsPassedGranular = getRoundFunction(round)(Math.abs(secondsPassed) / getStepDenominator(step) / step.granularity) * step.granularity; // If the granularity for this step is too high,
        // then fall back to the previous step.
        // (if there is any previous step)

        if (secondsPassedGranular === 0 && i > 0) {
          return steps[i - 1];
        }
      }

      return step;
    }
    /**
     * Iterates through steps until it finds the maximum one satisfying the `minTime` threshold.
     * @param  {Object} steps - Steps.
     * @param  {number} secondsPassed - How much seconds have passed since the date till `now`.
     * @param  {number} options.now - Current timestamp.
     * @param  {boolean} options.future - Whether the time interval should be formatted as a future one.
     * @param  {number} [i] - Gradation step currently being tested.
     * @return {number} Gradation step index.
     */


    function getStepIndex(steps, secondsPassed, options) {
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var minTime = getStepMinTime(steps[i], _objectSpread$1({
        prevStep: steps[i - 1],
        timestamp: options.now - secondsPassed * 1000
      }, options)); // If `minTime` isn't defined or deduceable for this step, then stop.

      if (minTime === undefined) {
        return i - 1;
      } // If the `minTime` threshold for moving from previous step
      // to this step is too high then return the previous step.


      if (Math.abs(secondsPassed) < minTime) {
        return i - 1;
      } // If it's the last step then return it.


      if (i === steps.length - 1) {
        return i;
      } // Move to the next step.


      return getStepIndex(steps, secondsPassed, options, i + 1);
    }
    /**
     * Leaves only allowed steps.
     * @param  {Object[]} steps
     * @param  {string[]} units - Allowed time units.
     * @return {Object[]}
     */


    function filterStepsByUnits(steps, units) {
      return steps.filter(function (_ref3) {
        var unit = _ref3.unit,
            formatAs = _ref3.formatAs;
        // "unit" is now called "formatAs".
        unit = unit || formatAs; // If this step has a `unit` defined
        // then this `unit` must be in the list of allowed `units`.

        if (unit) {
          return units.indexOf(unit) >= 0;
        } // A step is not required to specify a `unit`:
        // alternatively, it could specify `format()`.
        // (see "twitter" style for an example)


        return true;
      });
    }

    /**
     * Gets the time to next update for a step with a time unit defined.
     * @param  {string} unit
     * @param  {number} date — The date passed to `.format()`, converted to a timestamp.
     * @param  {number} options.now
     * @param  {string} [options.round] — (undocumented) Rounding mechanism.
     * @return {number} [timeToNextUpdate]
     */

    function getTimeToNextUpdateForUnit(unit, timestamp, _ref) {
      var now = _ref.now,
          round = _ref.round;

      // For some units, like "now", there's no defined amount of seconds in them.
      if (!getSecondsInUnit(unit)) {
        // If there's no amount of seconds defined for this unit
        // then the update interval can't be determined reliably.
        return;
      }

      var unitDenominator = getSecondsInUnit(unit) * 1000;
      var future = timestamp > now;
      var preciseAmount = Math.abs(timestamp - now);
      var roundedAmount = getRoundFunction(round)(preciseAmount / unitDenominator) * unitDenominator;

      if (future) {
        if (roundedAmount > 0) {
          // Amount decreases with time.
          return preciseAmount - roundedAmount + getDiffToPreviousRoundedNumber(round, unitDenominator);
        } else {
          // Refresh right after the zero point,
          // when "future" changes to "past".
          return preciseAmount - roundedAmount + 1;
        }
      } // Amount increases with time.


      return -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round, unitDenominator);
    }

    function getDiffToNextRoundedNumber(round, unitDenominator) {
      return getDiffRatioToNextRoundedNumber(round) * unitDenominator;
    }

    function getDiffToPreviousRoundedNumber(round, unitDenominator) {
      return (1 - getDiffRatioToNextRoundedNumber(round)) * unitDenominator + 1;
    }

    var YEAR = 365 * 24 * 60 * 60 * 1000;
    var INFINITY = 1000 * YEAR;
    /**
     * Gets the time to next update for a date and a step.
     * @param  {number} date — The date passed to `.format()`, converted to a timestamp.
     * @param  {object} step
     * @param  {object} [options.previousStep]
     * @param  {object} [options.nextStep]
     * @param  {number} options.now
     * @param  {boolean} options.future
     * @param  {string} [options.round] - (undocumented) Rounding mechanism.
     * @return {number} [timeToNextUpdate]
     */

    function getTimeToNextUpdate(date, step, _ref) {
      var prevStep = _ref.prevStep,
          nextStep = _ref.nextStep,
          now = _ref.now,
          future = _ref.future,
          round = _ref.round;
      var timestamp = date.getTime ? date.getTime() : date;

      var getTimeToNextUpdateForUnit$1 = function getTimeToNextUpdateForUnit$1(unit) {
        return getTimeToNextUpdateForUnit(unit, timestamp, {
          now: now,
          round: round
        });
      }; // For future dates, steps move from the last one to the first one,
      // while for past dates, steps move from the first one to the last one,
      // due to the fact that time flows in one direction,
      // and future dates' interval naturally becomes smaller
      // while past dates' interval naturally grows larger.
      //
      // For future dates, it's the transition
      // from the current step to the previous step,
      // therefore check the `minTime` of the current step.
      //
      // For past dates, it's the transition
      // from the current step to the next step,
      // therefore check the `minTime` of the next step.
      //


      var timeToStepChange = getTimeToStepChange(future ? step : nextStep, timestamp, {
        future: future,
        now: now,
        round: round,
        prevStep: future ? prevStep : step // isFirstStep: future && isFirstStep

      });

      if (timeToStepChange === undefined) {
        // Can't reliably determine "time to next update"
        // if not all of the steps provide `minTime`.
        return;
      }

      var timeToNextUpdate;

      if (step) {
        if (step.getTimeToNextUpdate) {
          timeToNextUpdate = step.getTimeToNextUpdate(timestamp, {
            getTimeToNextUpdateForUnit: getTimeToNextUpdateForUnit$1,
            getRoundFunction: getRoundFunction,
            now: now,
            future: future,
            round: round
          });
        }

        if (timeToNextUpdate === undefined) {
          // "unit" is now called "formatAs".
          var unit = step.unit || step.formatAs;

          if (unit) {
            // For some units, like "now", there's no defined amount of seconds in them.
            // In such cases, `getTimeToNextUpdateForUnit()` returns `undefined`,
            // and the next step's `minTime` could be used to calculate the update interval:
            // it will just assume that the label never changes for this step.
            timeToNextUpdate = getTimeToNextUpdateForUnit$1(unit);
          }
        }
      }

      if (timeToNextUpdate === undefined) {
        return timeToStepChange;
      }

      return Math.min(timeToNextUpdate, timeToStepChange);
    }
    function getStepChangesAt(currentOrNextStep, timestamp, _ref2) {
      var now = _ref2.now,
          future = _ref2.future,
          round = _ref2.round,
          prevStep = _ref2.prevStep;
      // The first step's `minTime` is `0` by default.
      // It doesn't "change" steps at zero point
      // but it does change the wording when switching
      // from "future" to "past": "in ..." -> "... ago".
      // Therefore, the label should be updated at zero-point too.
      var minTime = getStepMinTime(currentOrNextStep, {
        timestamp: timestamp,
        now: now,
        future: future,
        round: round,
        prevStep: prevStep
      });

      if (minTime === undefined) {
        return;
      }

      if (future) {
        // The step changes to the previous step
        // as soon as `timestamp - now` becomes
        // less than the `minTime` of the current step:
        // `timestamp - now === minTime - 1`
        // => `now === timestamp - minTime + 1`.
        return timestamp - minTime * 1000 + 1;
      } else {
        // The step changes to the next step
        // as soon as `now - timestamp` becomes
        // equal to `minTime` of the next step:
        // `now - timestamp === minTime`
        // => `now === timestamp + minTime`.
        // This is a special case when double-update could be skipped.
        if (minTime === 0 && timestamp === now) {
          return INFINITY;
        }

        return timestamp + minTime * 1000;
      }
    }
    function getTimeToStepChange(step, timestamp, _ref3) {
      var now = _ref3.now,
          future = _ref3.future,
          round = _ref3.round,
          prevStep = _ref3.prevStep;

      if (step) {
        var stepChangesAt = getStepChangesAt(step, timestamp, {
          now: now,
          future: future,
          round: round,
          prevStep: prevStep
        });

        if (stepChangesAt === undefined) {
          return;
        }

        return stepChangesAt - now;
      } else {
        if (future) {
          // No step.
          // Update right after zero point, when it changes from "future" to "past".
          return timestamp - now + 1;
        } else {
          // The last step doesn't ever change when `date` is in the past.
          return INFINITY;
        }
      }
    }

    // For all locales added
    // their relative time formatter messages will be stored here.
    var localesData$1 = {};
    function getLocaleData$1(locale) {
      return localesData$1[locale];
    }
    function addLocaleData$1(localeData) {
      if (!localeData) {
        throw new Error('[javascript-time-ago] No locale data passed.');
      } // This locale data is stored in a global variable
      // and later used when calling `.format(time)`.


      localesData$1[localeData.locale] = localeData;
    }

    // just now
    // 1 second ago
    // 2 seconds ago
    // …
    // 59 seconds ago
    // 1 minute ago
    // 2 minutes ago
    // …
    // 59 minutes ago
    // 1 hour ago
    // 2 hours ago
    // …
    // 24 hours ago
    // 1 day ago
    // 2 days ago
    // …
    // 6 days ago
    // 1 week ago
    // 2 weeks ago
    // …
    // 3 weeks ago
    // 1 month ago
    // 2 months ago
    // …
    // 11 months ago
    // 1 year ago
    // 2 years ago
    // …
    var round = [{
      formatAs: 'now'
    }, {
      formatAs: 'second'
    }, {
      formatAs: 'minute'
    }, {
      formatAs: 'hour'
    }, {
      formatAs: 'day'
    }, {
      formatAs: 'week'
    }, {
      formatAs: 'month'
    }, {
      formatAs: 'year'
    }];

    // 1 second ago
    // 2 seconds ago
    // …
    // 59 seconds ago
    // 1 minute ago
    // 2 minutes ago
    // …
    // 59 minutes ago
    // 1 minute ago
    // 2 minutes ago
    // …
    // 59 minutes ago
    // 1 hour ago
    // 2 hours ago
    // …
    // 24 hours ago
    // 1 day ago
    // 2 days ago
    // …
    // 6 days ago
    // 1 week ago
    // 2 weeks ago
    // 3 weeks ago
    // 4 weeks ago
    // 1 month ago
    // 2 months ago
    // …
    // 11 months ago
    // 1 year ago
    // 2 years ago
    // …
    //

    var round$1 = {
      steps: round,
      labels: 'long'
    };

    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } return target; }

    function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    // 1 minute ago
    // 2 minutes ago
    // …
    // 59 minutes ago
    // 1 minute ago
    // 2 minutes ago
    // …
    // 59 minutes ago
    // 1 hour ago
    // 2 hours ago
    // …
    // 24 hours ago
    // 1 day ago
    // 2 days ago
    // …
    // 6 days ago
    // 1 week ago
    // 2 weeks ago
    // 3 weeks ago
    // 4 weeks ago
    // 1 month ago
    // 2 months ago
    // …
    // 11 months ago
    // 1 year ago
    // 2 years ago
    // …
    //

    var defaultStyle = _objectSpread$2({}, round$1, {
      // Skip "seconds".
      steps: round$1.steps.filter(function (step) {
        return step.formatAs !== 'second';
      })
    });

    // Developers shouldn't need to use it in their custom steps.
    // "threshold" is a legacy name of "min".
    // Developers should use "min" property name instead of "threshold".
    // "threshold_for_idOrUnit: value" is a legacy way of specifying "min: { id: value }".
    // Developers should use "min" property instead of "threshold".
    // just now
    // 1 minute ago
    // 2 minutes ago
    // 5 minutes ago
    // 10 minutes ago
    // 15 minutes ago
    // 20 minutes ago
    // …
    // 50 minutes ago
    // an hour ago
    // 2 hours ago
    // …
    // 20 hours ago
    // a day ago
    // 2 days ago
    // 5 days ago
    // a week ago
    // 2 weeks ago
    // 3 weeks ago
    // a month ago
    // 2 months ago
    // 4 months ago
    // a year ago
    // 2 years ago
    // …

    var approximate = [{
      // This step returns the amount of seconds
      // by dividing the amount of seconds by `1`.
      factor: 1,
      // "now" labels are used for formatting the output.
      unit: 'now'
    }, {
      // When the language doesn't support `now` unit,
      // the first step is ignored, and it uses this `second` unit.
      threshold: 1,
      // `threshold_for_now` should be the same as `threshold` on minutes.
      threshold_for_now: 45.5,
      // This step returns the amount of seconds
      // by dividing the amount of seconds by `1`.
      factor: 1,
      // "second" labels are used for formatting the output.
      unit: 'second'
    }, {
      // `threshold` should be the same as `threshold_for_now` on seconds.
      threshold: 45.5,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a minute.
      factor: minute,
      // "minute" labels are used for formatting the output.
      unit: 'minute'
    }, {
      // This step is effective starting from 2.5 minutes.
      threshold: 2.5 * minute,
      // Allow only 5-minute increments of minutes starting from 2.5 minutes.
      // `granularity` — (advanced) Time interval value "granularity".
      // For example, it could be set to `5` for minutes to allow only 5-minute increments
      // when formatting time intervals: `0 minutes`, `5 minutes`, `10 minutes`, etc.
      // Perhaps this feature will be removed because there seem to be no use cases
      // of it in the real world.
      granularity: 5,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a minute.
      factor: minute,
      // "minute" labels are used for formatting the output.
      unit: 'minute'
    }, {
      // This step is effective starting from 22.5 minutes.
      threshold: 22.5 * minute,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in  half-an-hour.
      factor: 0.5 * hour,
      // "half-hour" labels are used for formatting the output.
      // (if available, which is no longer the case)
      unit: 'half-hour'
    }, {
      // This step is effective starting from 42.5 minutes.
      threshold: 42.5 * minute,
      threshold_for_minute: 52.5 * minute,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in an hour.
      factor: hour,
      // "hour" labels are used for formatting the output.
      unit: 'hour'
    }, {
      // This step is effective starting from 20.5 hours.
      threshold: 20.5 / 24 * day,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a day.
      factor: day,
      // "day" labels are used for formatting the output.
      unit: 'day'
    }, {
      // This step is effective starting from 5.5 days.
      threshold: 5.5 * day,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a week.
      factor: week,
      // "week" labels are used for formatting the output.
      unit: 'week'
    }, {
      // This step is effective starting from 3.5 weeks.
      threshold: 3.5 * week,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a month.
      factor: month,
      // "month" labels are used for formatting the output.
      unit: 'month'
    }, {
      // This step is effective starting from 10.5 months.
      threshold: 10.5 * month,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a year.
      factor: year,
      // "year" labels are used for formatting the output.
      unit: 'year'
    }];

    // It's here just for legacy compatibility.
    // Use "steps" name instead.
    // "flavour" is a legacy name for "labels".
    // It's here just for legacy compatibility.
    // Use "labels" name instead.
    // "units" is a legacy property.
    // It's here just for legacy compatibility.
    // Developers shouldn't need to use it in their custom styles.

    var approximate$1 = {
      gradation: approximate,
      flavour: 'long',
      units: ['now', 'minute', 'hour', 'day', 'week', 'month', 'year']
    };

    // It's here just for legacy compatibility.
    // Use "steps" name instead.
    // "flavour" is a legacy name for "labels".
    // It's here just for legacy compatibility.
    // Use "labels" name instead.
    // "units" is a legacy property.
    // It's here just for legacy compatibility.
    // Developers shouldn't need to use it in their custom styles.
    // Similar to the default style but with "ago" omitted.
    //
    // just now
    // 5 minutes
    // 10 minutes
    // 15 minutes
    // 20 minutes
    // an hour
    // 2 hours
    // …
    // 20 hours
    // 1 day
    // 2 days
    // a week
    // 2 weeks
    // 3 weeks
    // a month
    // 2 months
    // 3 months
    // 4 months
    // a year
    // 2 years
    //

    var approximateTime = {
      gradation: approximate,
      flavour: 'long-time',
      units: ['now', 'minute', 'hour', 'day', 'week', 'month', 'year']
    };

    // Looks like this one's deprecated.
    // /**
    //  * Returns a step corresponding to the unit.
    //  * @param  {Object[]} steps
    //  * @param  {string} unit
    //  * @return {?Object}
    //  */
    // export function getStepForUnit(steps, unit) {
    // 	for (const step of steps) {
    // 		if (step.unit === unit) {
    // 			return step
    // 		}
    // 	}
    // }
    // Looks like this one won't be used in the next major version.

    /**
     * Converts value to a `Date`
     * @param {(number|Date)} value
     * @return {Date}
     */
    function getDate(value) {
      return value instanceof Date ? value : new Date(value);
    }

    // ("1m", "2h", "Mar 3", "Apr 4, 2012").
    //
    // Seconds, minutes or hours are shown for shorter intervals,
    // and longer intervals are formatted using full date format.

    var steps = [{
      formatAs: 'second'
    }, {
      formatAs: 'minute'
    }, {
      formatAs: 'hour'
    }]; // A cache for `Intl.DateTimeFormat` formatters
    // for various locales (is a global variable).

    var formatters = {}; // Starting from day intervals, output month and day.

    var monthAndDay = {
      minTime: function minTime(timestamp, _ref) {
        _ref.future;
            var getMinTimeForUnit = _ref.getMinTimeForUnit;
        // Returns `23.5 * 60 * 60` when `round` is "round",
        // and `24 * 60 * 60` when `round` is "floor".
        return getMinTimeForUnit('day');
      },
      format: function format(value, locale) {
        /* istanbul ignore else */
        if (!formatters[locale]) {
          formatters[locale] = {};
        }
        /* istanbul ignore else */


        if (!formatters[locale].dayMonth) {
          // "Apr 11" (MMMd)
          formatters[locale].dayMonth = new Intl.DateTimeFormat(locale, {
            month: 'short',
            day: 'numeric'
          });
        } // Output month and day.


        return formatters[locale].dayMonth.format(getDate(value));
      }
    }; // If the `date` happened/happens outside of current year,
    // then output day, month and year.
    // The interval should be such that the `date` lies outside of the current year.

    var yearMonthAndDay = {
      minTime: function minTime(timestamp, _ref2) {
        var future = _ref2.future;

        if (future) {
          // January 1, 00:00, of the `date`'s year is right after
          // the maximum `now` for formatting a future date:
          // When `now` is before that date, the `date` is formatted as "day/month/year" (this step),
          // When `now` is equal to or after that date, the `date` is formatted as "day/month" (another step).
          // After that, it's hours, minutes, seconds, and after that it's no longer `future`.
          // The date is right after the maximum `now` for formatting a future date,
          // so subtract 1 millisecond from it.
          var maxFittingNow = new Date(new Date(timestamp).getFullYear(), 0).getTime() - 1; // Return `minTime` (in seconds).

          return (timestamp - maxFittingNow) / 1000;
        } else {
          // January 1, 00:00, of the year following the `date`'s year
          // is the minimum `now` for formatting a past date:
          // When `now` is before that date, the `date` is formatted as "day/month" (another step),
          // When `now` is equal to or after that date, the `date` is formatted as "day/month/year" (this step).
          // After that, it's hours, minutes, seconds, and after that it's no longer `future`.
          var minFittingNow = new Date(new Date(timestamp).getFullYear() + 1, 0).getTime(); // Return `minTime` (in seconds).

          return (minFittingNow - timestamp) / 1000;
        }
      },
      format: function format(value, locale) {
        /* istanbul ignore if */
        if (!formatters[locale]) {
          formatters[locale] = {};
        }
        /* istanbul ignore else */


        if (!formatters[locale].dayMonthYear) {
          // "Apr 11, 2017" (yMMMd)
          formatters[locale].dayMonthYear = new Intl.DateTimeFormat(locale, {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
          });
        } // Output day, month and year.


        return formatters[locale].dayMonthYear.format(getDate(value));
      }
    }; // If `Intl.DateTimeFormat` is supported,
    // then longer time intervals will be formatted as dates.

    /* istanbul ignore else */

    if (intlDateTimeFormatSupported()) {
      steps.push(monthAndDay, yearMonthAndDay);
    } // Otherwise, if `Intl.DateTimeFormat` is not supported,
    // which could be the case when using Internet Explorer,
    // then simply mimick "round" steps.
    else {
        steps.push({
          formatAs: 'day'
        }, {
          formatAs: 'week'
        }, {
          formatAs: 'month'
        }, {
          formatAs: 'year'
        });
      }

    var twitter = {
      steps: steps,
      labels: [// "mini" labels are only defined for a few languages.
      'mini', // "short-time" labels are only defined for a few languages.
      'short-time', // "narrow" and "short" labels are defined for all languages.
      // "narrow" labels can sometimes be weird (like "+5d."),
      // but "short" labels have the " ago" part, so "narrow" seem
      // more appropriate.
      // "short" labels would have been more appropriate if they
      // didn't have the " ago" part, hence the "short-time" above.
      'narrow', // Since "narrow" labels are always present, "short" element
      // of this array can be removed.
      'short']
    };

    function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$4(target, key, source[key]); }); } return target; }

    function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    var twitterNow = _objectSpread$3({}, twitter, {
      // Add "now".
      steps: [{
        formatAs: 'now'
      }].concat(twitter.steps)
    });

    function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$5(target, key, source[key]); }); } return target; }

    function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    var twitterMinute = _objectSpread$4({}, twitter, {
      // Skip "seconds".
      steps: twitter.steps.filter(function (step) {
        return step.formatAs !== 'second';
      })
    });

    function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$6(target, key, source[key]); }); } return target; }

    function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    var twitterMinuteNow = _objectSpread$5({}, twitterMinute, {
      // Add "now".
      steps: [{
        formatAs: 'now'
      }].concat(twitterMinute.steps)
    });

    function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$7(target, key, source[key]); }); } return target; }

    function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    var twitterFirstMinute = _objectSpread$6({}, twitter, {
      // Skip "seconds".
      steps: twitter.steps.filter(function (step) {
        return step.formatAs !== 'second';
      }) // Start showing `1m` from the first minute.
      .map(function (step) {
        return step.formatAs === 'minute' ? _objectSpread$6({}, step, {
          minTime: minute
        }) : step;
      })
    });

    var mini = {
      steps: [{
        formatAs: 'second'
      }, {
        formatAs: 'minute'
      }, {
        formatAs: 'hour'
      }, {
        formatAs: 'day'
      }, {
        formatAs: 'month'
      }, {
        formatAs: 'year'
      }],
      labels: [// "mini" labels are only defined for a few languages.
      'mini', // "short-time" labels are only defined for a few languages.
      'short-time', // "narrow" and "short" labels are defined for all languages.
      // "narrow" labels can sometimes be weird (like "+5d."),
      // but "short" labels have the " ago" part, so "narrow" seem
      // more appropriate.
      // "short" labels would have been more appropriate if they
      // didn't have the " ago" part, hence the "short-time" above.
      'narrow', // Since "narrow" labels are always present, "short" element
      // of this array can be removed.
      'short']
    };

    function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$8(target, key, source[key]); }); } return target; }

    function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    var miniNow = _objectSpread$7({}, mini, {
      // Add "now".
      steps: [{
        formatAs: 'now'
      }].concat(mini.steps)
    });

    function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$9(target, key, source[key]); }); } return target; }

    function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    var miniMinute = _objectSpread$8({}, mini, {
      // Skip "seconds".
      steps: mini.steps.filter(function (step) {
        return step.formatAs !== 'second';
      })
    });

    function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$a(target, key, source[key]); }); } return target; }

    function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    var miniMinuteNow = _objectSpread$9({}, miniMinute, {
      // Add "now".
      steps: [{
        formatAs: 'now'
      }].concat(miniMinute.steps)
    });

    function getStyleByName(style) {
      switch (style) {
        // "default" style name is deprecated.
        case 'default':
        case 'round':
          return round$1;

        case 'round-minute':
          return defaultStyle;

        case 'approximate':
          return approximate$1;
        // "time" style name is deprecated.

        case 'time':
        case 'approximate-time':
          return approximateTime;

        case 'mini':
          return mini;

        case 'mini-now':
          return miniNow;

        case 'mini-minute':
          return miniMinute;

        case 'mini-minute-now':
          return miniMinuteNow;

        case 'twitter':
          return twitter;

        case 'twitter-now':
          return twitterNow;

        case 'twitter-minute':
          return twitterMinute;

        case 'twitter-minute-now':
          return twitterMinuteNow;

        case 'twitter-first-minute':
          return twitterFirstMinute;

        default:
          // For historical reasons, the default style is "approximate".
          return approximate$1;
      }
    }

    function _typeof$4(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

    function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1(); }

    function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

    function _iterableToArrayLimit$1(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

    function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }

    function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

    var TimeAgo =
    /*#__PURE__*/
    function () {
      /**
       * @param {(string|string[])} locales=[] - Preferred locales (or locale).
       * @param {boolean} [polyfill] — Pass `false` to use native `Intl.RelativeTimeFormat` and `Intl.PluralRules` instead of the polyfills.
       */
      function TimeAgo() {
        var locales = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            polyfill = _ref.polyfill;

        _classCallCheck$3(this, TimeAgo);

        // Convert `locales` to an array.
        if (typeof locales === 'string') {
          locales = [locales];
        } // Choose the most appropriate locale
        // from the list of `locales` added by the user.
        // For example, new TimeAgo("en-US") -> "en".


        this.locale = chooseLocale(locales.concat(TimeAgo.getDefaultLocale()), getLocaleData$1);

        if (typeof Intl !== 'undefined') {
          // Use `Intl.NumberFormat` for formatting numbers (when available).
          if (Intl.NumberFormat) {
            this.numberFormat = new Intl.NumberFormat(this.locale);
          }
        } // Some people have requested the ability to use native
        // `Intl.RelativeTimeFormat` and `Intl.PluralRules`
        // instead of the polyfills.
        // https://github.com/catamphetamine/javascript-time-ago/issues/21


        if (polyfill === false) {
          this.IntlRelativeTimeFormat = Intl.RelativeTimeFormat;
          this.IntlPluralRules = Intl.PluralRules;
        } else {
          this.IntlRelativeTimeFormat = RelativeTimeFormat;
          this.IntlPluralRules = RelativeTimeFormat.PluralRules;
        } // Cache `Intl.RelativeTimeFormat` instance.


        this.relativeTimeFormatCache = new Cache(); // Cache `Intl.PluralRules` instance.

        this.pluralRulesCache = new Cache();
      }
      /**
       * Formats relative date/time.
       *
       * @param {number} [options.now] - Sets the current date timestamp.
       *
       * @param  {boolean} [options.future] — Tells how to format value `0`:
       *         as "future" (`true`) or "past" (`false`).
       *         Is `false` by default, but should have been `true` actually,
       *         in order to correspond to `Intl.RelativeTimeFormat`
       *         that uses `future` formatting for `0` unless `-0` is passed.
       *
       * @param {string} [options.round] — Rounding method. Overrides the style's one.
       *
       * @param {boolean} [options.getTimeToNextUpdate] — Pass `true` to return `[formattedDate, timeToNextUpdate]` instead of just `formattedDate`.
       *
       * @return {string} The formatted relative date/time. If no eligible `step` is found, then an empty string is returned.
       */


      _createClass$3(TimeAgo, [{
        key: "format",
        value: function format(input, style, options) {
          if (!options) {
            if (style && !isStyle(style)) {
              options = style;
              style = undefined;
            } else {
              options = {};
            }
          }

          if (!style) {
            style = defaultStyle;
          }

          if (typeof style === 'string') {
            style = getStyleByName(style);
          }

          var timestamp = getTimestamp(input); // Get locale messages for this type of labels.
          // "flavour" is a legacy name for "labels".

          var _this$getLabels = this.getLabels(style.flavour || style.labels),
              labels = _this$getLabels.labels,
              labelsType = _this$getLabels.labelsType;

          var now; // Can pass a custom `now`, e.g. for testing purposes.
          //
          // Legacy way was passing `now` in `style`.
          // That way is deprecated.

          if (style.now !== undefined) {
            now = style.now;
          } // The new way is passing `now` option to `.format()`.


          if (now === undefined && options.now !== undefined) {
            now = options.now;
          }

          if (now === undefined) {
            now = Date.now();
          } // how much time has passed (in seconds)


          var secondsPassed = (now - timestamp) / 1000; // in seconds

          var future = options.future || secondsPassed < 0;
          var nowLabel = getNowLabel(labels, getLocaleData$1(this.locale).now, getLocaleData$1(this.locale).long, future); // `custom` – A function of `{ elapsed, time, date, now, locale }`.
          //
          // Looks like `custom` function is deprecated and will be removed
          // in the next major version.
          //
          // If this function returns a value, then the `.format()` call will return that value.
          // Otherwise the relative date/time is formatted as usual.
          // This feature is currently not used anywhere and is here
          // just for providing the ultimate customization point
          // in case anyone would ever need that. Prefer using
          // `steps[step].format(value, locale)` instead.
          //

          if (style.custom) {
            var custom = style.custom({
              now: now,
              date: new Date(timestamp),
              time: timestamp,
              elapsed: secondsPassed,
              locale: this.locale
            });

            if (custom !== undefined) {
              // Won't return `timeToNextUpdate` here
              // because `custom()` seems deprecated.
              return custom;
            }
          } // Get the list of available time interval units.


          var units = getTimeIntervalMeasurementUnits( // Controlling `style.steps` through `style.units` seems to be deprecated:
          // create a new custom `style` instead.
          style.units, labels, nowLabel); // // If no available time unit is suitable, just output an empty string.
          // if (units.length === 0) {
          // 	console.error(`None of the "${units.join(', ')}" time units have been found in "${labelsType}" labels for "${this.locale}" locale.`)
          // 	return ''
          // }

          var round = options.round || style.round; // Choose the appropriate time measurement unit
          // and get the corresponding rounded time amount.

          var _getStep = getStep( // "gradation" is a legacy name for "steps".
          // For historical reasons, "approximate" steps are used by default.
          // In the next major version, there'll be no default for `steps`.
          style.gradation || style.steps || defaultStyle.steps, secondsPassed, {
            now: now,
            units: units,
            round: round,
            future: future,
            getNextStep: true
          }),
              _getStep2 = _slicedToArray$1(_getStep, 3),
              prevStep = _getStep2[0],
              step = _getStep2[1],
              nextStep = _getStep2[2];

          var formattedDate = this.formatDateForStep(timestamp, step, secondsPassed, {
            labels: labels,
            labelsType: labelsType,
            nowLabel: nowLabel,
            now: now,
            future: future,
            round: round
          }) || '';

          if (options.getTimeToNextUpdate) {
            var timeToNextUpdate = getTimeToNextUpdate(timestamp, step, {
              nextStep: nextStep,
              prevStep: prevStep,
              now: now,
              future: future,
              round: round
            });
            return [formattedDate, timeToNextUpdate];
          }

          return formattedDate;
        }
      }, {
        key: "formatDateForStep",
        value: function formatDateForStep(timestamp, step, secondsPassed, _ref2) {
          var _this = this;

          var labels = _ref2.labels,
              labelsType = _ref2.labelsType,
              nowLabel = _ref2.nowLabel,
              now = _ref2.now,
              future = _ref2.future,
              round = _ref2.round;

          // If no step matches, then output an empty string.
          if (!step) {
            return;
          }

          if (step.format) {
            return step.format(timestamp, this.locale, {
              formatAs: function formatAs(unit, value) {
                // Mimicks `Intl.RelativeTimeFormat.format()`.
                return _this.formatValue(value, unit, {
                  labels: labels,
                  future: future
                });
              },
              now: now,
              future: future
            });
          } // "unit" is now called "formatAs".


          var unit = step.unit || step.formatAs;

          if (!unit) {
            throw new Error("[javascript-time-ago] Each step must define either `formatAs` or `format()`. Step: ".concat(JSON.stringify(step)));
          } // `Intl.RelativeTimeFormat` doesn't operate in "now" units.
          // Therefore, threat "now" as a special case.


          if (unit === 'now') {
            return nowLabel;
          } // Amount in units.


          var amount = Math.abs(secondsPassed) / getStepDenominator(step); // Apply granularity to the time amount
          // (and fallback to the previous step
          //  if the first level of granularity
          //  isn't met by this amount)
          //
          // `granularity` — (advanced) Time interval value "granularity".
          // For example, it could be set to `5` for minutes to allow only 5-minute increments
          // when formatting time intervals: `0 minutes`, `5 minutes`, `10 minutes`, etc.
          // Perhaps this feature will be removed because there seem to be no use cases
          // of it in the real world.
          //

          if (step.granularity) {
            // Recalculate the amount of seconds passed based on granularity
            amount = getRoundFunction(round)(amount / step.granularity) * step.granularity;
          }

          var valueForFormatting = -1 * Math.sign(secondsPassed) * getRoundFunction(round)(amount); // By default, this library formats a `0` in "past" mode,
          // unless `future: true` option is passed.
          // This is different to `relative-time-format`'s behavior
          // which formats a `0` in "future" mode by default, unless it's a `-0`.
          // So, convert `0` to `-0` if `future: true` option wasn't passed.
          // `=== 0` matches both `0` and `-0`.

          if (valueForFormatting === 0) {
            if (future) {
              valueForFormatting = 0;
            } else {
              valueForFormatting = -0;
            }
          }

          switch (labelsType) {
            case 'long':
            case 'short':
            case 'narrow':
              // Format the amount using `Intl.RelativeTimeFormat`.
              return this.getFormatter(labelsType).format(valueForFormatting, unit);

            default:
              // Format the amount.
              // (mimicks `Intl.RelativeTimeFormat` behavior for other time label styles)
              return this.formatValue(valueForFormatting, unit, {
                labels: labels,
                future: future
              });
          }
        }
        /**
         * Mimicks what `Intl.RelativeTimeFormat` does for additional locale styles.
         * @param  {number} value
         * @param  {string} unit
         * @param  {object} options.labels — Relative time labels.
         * @param  {boolean} [options.future] — Tells how to format value `0`: as "future" (`true`) or "past" (`false`). Is `false` by default, but should have been `true` actually.
         * @return {string}
         */

      }, {
        key: "formatValue",
        value: function formatValue(value, unit, _ref3) {
          var labels = _ref3.labels,
              future = _ref3.future;
          return this.getFormattingRule(labels, unit, value, {
            future: future
          }).replace('{0}', this.formatNumber(Math.abs(value)));
        }
        /**
         * Returns formatting rule for `value` in `units` (either in past or in future).
         * @param {object} formattingRules — Relative time labels for different units.
         * @param {string} unit - Time interval measurement unit.
         * @param {number} value - Time interval value.
         * @param  {boolean} [options.future] — Tells how to format value `0`: as "future" (`true`) or "past" (`false`). Is `false` by default.
         * @return {string}
         * @example
         * // Returns "{0} days ago"
         * getFormattingRule(en.long, "day", -2, 'en')
         */

      }, {
        key: "getFormattingRule",
        value: function getFormattingRule(formattingRules, unit, value, _ref4) {
          var future = _ref4.future;
          // Passing the language is required in order to
          // be able to correctly classify the `value` as a number.
          this.locale;
          formattingRules = formattingRules[unit]; // Check for a special "compacted" rules case:
          // if formatting rules are the same for "past" and "future",
          // and also for all possible `value`s, then those rules are
          // stored as a single string.

          if (typeof formattingRules === 'string') {
            return formattingRules;
          } // Choose either "past" or "future" based on time `value` sign.
          // If "past" is same as "future" then they're stored as "other".
          // If there's only "other" then it's being collapsed.


          var pastOrFuture = value === 0 ? future ? 'future' : 'past' : value < 0 ? 'past' : 'future';
          var quantifierRules = formattingRules[pastOrFuture] || formattingRules; // Bundle size optimization technique.

          if (typeof quantifierRules === 'string') {
            return quantifierRules;
          } // Quantify `value`.


          var quantifier = this.getPluralRules().select(Math.abs(value)); // "other" rule is supposed to always be present.
          // If only "other" rule is present then "rules" is not an object and is a string.

          return quantifierRules[quantifier] || quantifierRules.other;
        }
        /**
         * Formats a number into a string.
         * Uses `Intl.NumberFormat` when available.
         * @param  {number} number
         * @return {string}
         */

      }, {
        key: "formatNumber",
        value: function formatNumber(number) {
          return this.numberFormat ? this.numberFormat.format(number) : String(number);
        }
        /**
         * Returns an `Intl.RelativeTimeFormat` for a given `labelsType`.
         * @param {string} labelsType
         * @return {object} `Intl.RelativeTimeFormat` instance
         */

      }, {
        key: "getFormatter",
        value: function getFormatter(labelsType) {
          // `Intl.RelativeTimeFormat` instance creation is (hypothetically) assumed
          // a lengthy operation so the instances are cached and reused.
          return this.relativeTimeFormatCache.get(this.locale, labelsType) || this.relativeTimeFormatCache.put(this.locale, labelsType, new this.IntlRelativeTimeFormat(this.locale, {
            style: labelsType
          }));
        }
        /**
         * Returns an `Intl.PluralRules` instance.
         * @return {object} `Intl.PluralRules` instance
         */

      }, {
        key: "getPluralRules",
        value: function getPluralRules() {
          // `Intl.PluralRules` instance creation is (hypothetically) assumed
          // a lengthy operation so the instances are cached and reused.
          return this.pluralRulesCache.get(this.locale) || this.pluralRulesCache.put(this.locale, new this.IntlPluralRules(this.locale));
        }
        /**
         * Gets localized labels for this type of labels.
         *
         * @param {(string|string[])} labelsType - Relative date/time labels type.
         *                                     If it's an array then all label types are tried
         *                                     until a suitable one is found.
         *
         * @returns {Object} Returns an object of shape { labelsType, labels }
         */

      }, {
        key: "getLabels",
        value: function getLabels() {
          var labelsType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          // Convert `labels` to an array.
          if (typeof labelsType === 'string') {
            labelsType = [labelsType];
          } // Supports legacy "tiny" and "mini-time" label styles.


          labelsType = labelsType.map(function (labelsType) {
            switch (labelsType) {
              case 'tiny':
              case 'mini-time':
                return 'mini';

              default:
                return labelsType;
            }
          }); // "long" labels type is the default one.
          // (it's always present for all languages)

          labelsType = labelsType.concat('long'); // Find a suitable labels type.

          var localeData = getLocaleData$1(this.locale);

          for (var _iterator = labelsType, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref5;

            if (_isArray) {
              if (_i2 >= _iterator.length) break;
              _ref5 = _iterator[_i2++];
            } else {
              _i2 = _iterator.next();
              if (_i2.done) break;
              _ref5 = _i2.value;
            }

            var _labelsType = _ref5;

            if (localeData[_labelsType]) {
              return {
                labelsType: _labelsType,
                labels: localeData[_labelsType]
              };
            }
          }
        }
      }]);

      return TimeAgo;
    }();
    var defaultLocale$1 = 'en';
    /**
     * Gets default locale.
     * @return  {string} locale
     */

    TimeAgo.getDefaultLocale = function () {
      return defaultLocale$1;
    };
    /**
     * Sets default locale.
     * @param  {string} locale
     */


    TimeAgo.setDefaultLocale = function (locale) {
      return defaultLocale$1 = locale;
    };
    /**
     * Adds locale data for a specific locale.
     * @param {Object} localeData
     */


    TimeAgo.addDefaultLocale = function (localeData) {
      if (defaultLocaleHasBeenSpecified) {
        throw new Error('[javascript-time-ago] `TimeAgo.addDefaultLocale()` can only be called once. To add other locales, use `TimeAgo.addLocale()`.');
      }

      defaultLocaleHasBeenSpecified = true;
      TimeAgo.setDefaultLocale(localeData.locale);
      TimeAgo.addLocale(localeData);
    };

    var defaultLocaleHasBeenSpecified;
    /**
     * Adds locale data for a specific locale.
     * @param {Object} localeData
     */

    TimeAgo.addLocale = function (localeData) {
      addLocaleData$1(localeData);
      RelativeTimeFormat.addLocale(localeData);
    };
    /**
     * (legacy alias)
     * Adds locale data for a specific locale.
     * @param {Object} localeData
     * @deprecated
     */


    TimeAgo.locale = TimeAgo.addLocale;
    /**
     * Adds custom labels to locale data.
     * @param {string} locale
     * @param {string} name
     * @param {object} labels
     */

    TimeAgo.addLabels = function (locale, name, labels) {
      var localeData = getLocaleData$1(locale);

      if (!localeData) {
        addLocaleData$1({
          locale: locale
        });
        localeData = getLocaleData$1(locale); // throw new Error(`[javascript-time-ago] No data for locale "${locale}"`)
      }

      localeData[name] = labels;
    }; // Normalizes `.format()` `time` argument.


    function getTimestamp(input) {
      if (input.constructor === Date || isMockedDate(input)) {
        return input.getTime();
      }

      if (typeof input === 'number') {
        return input;
      } // For some weird reason istanbul doesn't see this `throw` covered.

      /* istanbul ignore next */


      throw new Error("Unsupported relative time formatter input: ".concat(_typeof$4(input), ", ").concat(input));
    } // During testing via some testing libraries `Date`s aren't actually `Date`s.
    // https://github.com/catamphetamine/javascript-time-ago/issues/22


    function isMockedDate(object) {
      return _typeof$4(object) === 'object' && typeof object.getTime === 'function';
    } // Get available time interval measurement units.


    function getTimeIntervalMeasurementUnits(allowedUnits, labels, nowLabel) {
      // Get all time interval measurement units that're available
      // in locale data for a given time labels style.
      var units = Object.keys(labels); // `now` unit is handled separately and is shipped in its own `now.json` file.
      // `now.json` isn't present for all locales, so it could be substituted with
      // ".second.current".
      // Add `now` unit if it's available in locale data.

      if (nowLabel) {
        units.push('now');
      } // If only a specific set of available time measurement units can be used
      // then only those units are allowed (if they're present in locale data).


      if (allowedUnits) {
        units = allowedUnits.filter(function (unit) {
          return unit === 'now' || units.indexOf(unit) >= 0;
        });
      }

      return units;
    }

    function getNowLabel(labels, nowLabels, longLabels, future) {
      var nowLabel = labels.now || nowLabels && nowLabels.now; // Specific "now" message form extended locale data (if present).

      if (nowLabel) {
        // Bundle size optimization technique.
        if (typeof nowLabel === 'string') {
          return nowLabel;
        } // Not handling `value === 0` as `localeData.now.current` here
        // because it wouldn't make sense: "now" is a moment,
        // so one can't possibly differentiate between a
        // "previous" moment, a "current" moment and a "next moment".
        // It can only be differentiated between "past" and "future".


        if (future) {
          return nowLabel.future;
        } else {
          return nowLabel.past;
        }
      } // Use ".second.current" as "now" message.


      if (longLabels && longLabels.second && longLabels.second.current) {
        return longLabels.second.current;
      }
    }

    var OBJECT_CONSTRUCTOR = {}.constructor;

    function isObject(object) {
      return _typeof$4(object) !== undefined && object !== null && object.constructor === OBJECT_CONSTRUCTOR;
    }

    function isStyle(variable) {
      return typeof variable === 'string' || isStyleObject(variable);
    }

    function isStyleObject(object) {
      return isObject(object) && (Array.isArray(object.steps) || // `gradation` property is deprecated: it has been renamed to `steps`.
      Array.isArray(object.gradation) || // `flavour` property is deprecated: it has been renamed to `labels`.
      Array.isArray(object.flavour) || typeof object.flavour === 'string' || Array.isArray(object.labels) || typeof object.labels === 'string' || // `units` property is deprecated.
      Array.isArray(object.units) || // `custom` property is deprecated.
      typeof object.custom === 'function');
    }

    var locale = "en";
    var long = {
    	year: {
    		previous: "last year",
    		current: "this year",
    		next: "next year",
    		past: {
    			one: "{0} year ago",
    			other: "{0} years ago"
    		},
    		future: {
    			one: "in {0} year",
    			other: "in {0} years"
    		}
    	},
    	quarter: {
    		previous: "last quarter",
    		current: "this quarter",
    		next: "next quarter",
    		past: {
    			one: "{0} quarter ago",
    			other: "{0} quarters ago"
    		},
    		future: {
    			one: "in {0} quarter",
    			other: "in {0} quarters"
    		}
    	},
    	month: {
    		previous: "last month",
    		current: "this month",
    		next: "next month",
    		past: {
    			one: "{0} month ago",
    			other: "{0} months ago"
    		},
    		future: {
    			one: "in {0} month",
    			other: "in {0} months"
    		}
    	},
    	week: {
    		previous: "last week",
    		current: "this week",
    		next: "next week",
    		past: {
    			one: "{0} week ago",
    			other: "{0} weeks ago"
    		},
    		future: {
    			one: "in {0} week",
    			other: "in {0} weeks"
    		}
    	},
    	day: {
    		previous: "yesterday",
    		current: "today",
    		next: "tomorrow",
    		past: {
    			one: "{0} day ago",
    			other: "{0} days ago"
    		},
    		future: {
    			one: "in {0} day",
    			other: "in {0} days"
    		}
    	},
    	hour: {
    		current: "this hour",
    		past: {
    			one: "{0} hour ago",
    			other: "{0} hours ago"
    		},
    		future: {
    			one: "in {0} hour",
    			other: "in {0} hours"
    		}
    	},
    	minute: {
    		current: "this minute",
    		past: {
    			one: "{0} minute ago",
    			other: "{0} minutes ago"
    		},
    		future: {
    			one: "in {0} minute",
    			other: "in {0} minutes"
    		}
    	},
    	second: {
    		current: "now",
    		past: {
    			one: "{0} second ago",
    			other: "{0} seconds ago"
    		},
    		future: {
    			one: "in {0} second",
    			other: "in {0} seconds"
    		}
    	}
    };
    var short = {
    	year: {
    		previous: "last yr.",
    		current: "this yr.",
    		next: "next yr.",
    		past: "{0} yr. ago",
    		future: "in {0} yr."
    	},
    	quarter: {
    		previous: "last qtr.",
    		current: "this qtr.",
    		next: "next qtr.",
    		past: {
    			one: "{0} qtr. ago",
    			other: "{0} qtrs. ago"
    		},
    		future: {
    			one: "in {0} qtr.",
    			other: "in {0} qtrs."
    		}
    	},
    	month: {
    		previous: "last mo.",
    		current: "this mo.",
    		next: "next mo.",
    		past: "{0} mo. ago",
    		future: "in {0} mo."
    	},
    	week: {
    		previous: "last wk.",
    		current: "this wk.",
    		next: "next wk.",
    		past: "{0} wk. ago",
    		future: "in {0} wk."
    	},
    	day: {
    		previous: "yesterday",
    		current: "today",
    		next: "tomorrow",
    		past: {
    			one: "{0} day ago",
    			other: "{0} days ago"
    		},
    		future: {
    			one: "in {0} day",
    			other: "in {0} days"
    		}
    	},
    	hour: {
    		current: "this hour",
    		past: "{0} hr. ago",
    		future: "in {0} hr."
    	},
    	minute: {
    		current: "this minute",
    		past: "{0} min. ago",
    		future: "in {0} min."
    	},
    	second: {
    		current: "now",
    		past: "{0} sec. ago",
    		future: "in {0} sec."
    	}
    };
    var narrow = {
    	year: {
    		previous: "last yr.",
    		current: "this yr.",
    		next: "next yr.",
    		past: "{0} yr. ago",
    		future: "in {0} yr."
    	},
    	quarter: {
    		previous: "last qtr.",
    		current: "this qtr.",
    		next: "next qtr.",
    		past: {
    			one: "{0} qtr. ago",
    			other: "{0} qtrs. ago"
    		},
    		future: {
    			one: "in {0} qtr.",
    			other: "in {0} qtrs."
    		}
    	},
    	month: {
    		previous: "last mo.",
    		current: "this mo.",
    		next: "next mo.",
    		past: "{0} mo. ago",
    		future: "in {0} mo."
    	},
    	week: {
    		previous: "last wk.",
    		current: "this wk.",
    		next: "next wk.",
    		past: "{0} wk. ago",
    		future: "in {0} wk."
    	},
    	day: {
    		previous: "yesterday",
    		current: "today",
    		next: "tomorrow",
    		past: {
    			one: "{0} day ago",
    			other: "{0} days ago"
    		},
    		future: {
    			one: "in {0} day",
    			other: "in {0} days"
    		}
    	},
    	hour: {
    		current: "this hour",
    		past: "{0} hr. ago",
    		future: "in {0} hr."
    	},
    	minute: {
    		current: "this minute",
    		past: "{0} min. ago",
    		future: "in {0} min."
    	},
    	second: {
    		current: "now",
    		past: "{0} sec. ago",
    		future: "in {0} sec."
    	}
    };
    var now$1 = {
    	now: {
    		current: "now",
    		future: "in a moment",
    		past: "just now"
    	}
    };
    var mini$1 = {
    	year: "{0}yr",
    	month: "{0}mo",
    	week: "{0}wk",
    	day: "{0}d",
    	hour: "{0}h",
    	minute: "{0}m",
    	second: "{0}s",
    	now: "now"
    };
    var en = {
    	locale: locale,
    	long: long,
    	short: short,
    	narrow: narrow,
    	now: now$1,
    	mini: mini$1,
    	"short-time": {
    	year: "{0} yr.",
    	month: "{0} mo.",
    	week: "{0} wk.",
    	day: {
    		one: "{0} day",
    		other: "{0} days"
    	},
    	hour: "{0} hr.",
    	minute: "{0} min.",
    	second: "{0} sec."
    },
    	"long-time": {
    	year: {
    		one: "{0} year",
    		other: "{0} years"
    	},
    	month: {
    		one: "{0} month",
    		other: "{0} months"
    	},
    	week: {
    		one: "{0} week",
    		other: "{0} weeks"
    	},
    	day: {
    		one: "{0} day",
    		other: "{0} days"
    	},
    	hour: {
    		one: "{0} hour",
    		other: "{0} hours"
    	},
    	minute: {
    		one: "{0} minute",
    		other: "{0} minutes"
    	},
    	second: {
    		one: "{0} second",
    		other: "{0} seconds"
    	}
    }
    };

    /* src/components/news-feed/NewsFeed.svelte generated by Svelte v3.32.1 */

    const { console: console_1$7 } = globals;

    const file$1i = "src/components/news-feed/NewsFeed.svelte";

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (462:0) {#if activePopup === 'create-new-audience-popup' }
    function create_if_block_4$1(ctx) {
    	let modalwindow;
    	let current;

    	modalwindow = new ModalWindow({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modalwindow.$on("click", /*clickHandler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(modalwindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalwindow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modalwindow_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				modalwindow_changes.$$scope = { dirty, ctx };
    			}

    			modalwindow.$set(modalwindow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalwindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalwindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalwindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(462:0) {#if activePopup === 'create-new-audience-popup' }",
    		ctx
    	});

    	return block;
    }

    // (463:4) <ModalWindow on:click={clickHandler}>
    function create_default_slot_1$1(ctx) {
    	let createnewaudience;
    	let current;
    	createnewaudience = new CreateNewAudience({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(createnewaudience.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(createnewaudience, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(createnewaudience.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(createnewaudience.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(createnewaudience, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(463:4) <ModalWindow on:click={clickHandler}>",
    		ctx
    	});

    	return block;
    }

    // (468:0) {#if activePopup === 'select-audience-popup' }
    function create_if_block_3$4(ctx) {
    	let modalwindow;
    	let current;

    	modalwindow = new ModalWindow({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	modalwindow.$on("click", /*clickHandler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(modalwindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalwindow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modalwindow_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				modalwindow_changes.$$scope = { dirty, ctx };
    			}

    			modalwindow.$set(modalwindow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalwindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalwindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalwindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(468:0) {#if activePopup === 'select-audience-popup' }",
    		ctx
    	});

    	return block;
    }

    // (469:4) <ModalWindow on:click={clickHandler}>
    function create_default_slot$1(ctx) {
    	let selectaudience;
    	let current;
    	selectaudience = new SelectAudience({ $$inline: true });
    	selectaudience.$on("click", /*clickHandler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(selectaudience.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectaudience, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectaudience.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectaudience.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectaudience, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(469:4) <ModalWindow on:click={clickHandler}>",
    		ctx
    	});

    	return block;
    }

    // (479:8) {:else}
    function create_else_block(ctx) {
    	let div;
    	let tagsarea;
    	let t0;
    	let commentform;
    	let t1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	tagsarea = new TagsArea({ $$inline: true });
    	commentform = new CommentForm({ $$inline: true });
    	commentform.$on("click", /*clickHandler*/ ctx[5]);
    	commentform.$on("sortPostsByTag", /*sortPostsByTagHandler*/ ctx[7]);
    	let each_value = feed;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*feed_item*/ ctx[11].id;
    	validate_each_keys(ctx, each_value, get_each_context$l, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$l(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$l(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tagsarea.$$.fragment);
    			t0 = space();
    			create_component(commentform.$$.fragment);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "container svelte-isa7rv");
    			add_location(div, file$1i, 479, 12, 23849);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tagsarea, div, null);
    			append_dev(div, t0);
    			mount_component(commentform, div, null);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*feed, timeAgo, childDisplayStatuses, displayChildHandler, tagName*/ 89) {
    				each_value = feed;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$l, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$l, null, get_each_context$l);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagsarea.$$.fragment, local);
    			transition_in(commentform.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagsarea.$$.fragment, local);
    			transition_out(commentform.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tagsarea);
    			destroy_component(commentform);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(479:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (477:8) {#if isUserProfileOpened}
    function create_if_block$z(ctx) {
    	let userdata;
    	let current;
    	userdata = new UserData({ $$inline: true });
    	userdata.$on("click", /*clickHandler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(userdata.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(userdata, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(userdata.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(userdata.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(userdata, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(477:8) {#if isUserProfileOpened}",
    		ctx
    	});

    	return block;
    }

    // (486:20) {#if feed_item.parent_post_id === null               && (tagName === ''                || feed_item['tags'].includes(tagName)               )                     }
    function create_if_block_1$k(ctx) {
    	let feeditem;
    	let t;
    	let if_block_anchor;
    	let current;

    	feeditem = new FeedItem({
    			props: {
    				data: /*feed_item*/ ctx[11],
    				timeInstance: /*timeAgo*/ ctx[4]
    			},
    			$$inline: true
    		});

    	feeditem.$on("toggleChild", /*displayChildHandler*/ ctx[6]);
    	let if_block = /*feed_item*/ ctx[11].children_post_ids.length && create_if_block_2$7(ctx);

    	const block = {
    		c: function create() {
    			create_component(feeditem.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(feeditem, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*feed_item*/ ctx[11].children_post_ids.length) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(feeditem.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(feeditem.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(feeditem, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(486:20) {#if feed_item.parent_post_id === null               && (tagName === ''                || feed_item['tags'].includes(tagName)               )                     }",
    		ctx
    	});

    	return block;
    }

    // (496:24) {#if feed_item.children_post_ids.length }
    function create_if_block_2$7(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let commentform;
    	let current;
    	let each_value_1 = /*feed_item*/ ctx[11].children_post_ids;
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*child_feed_item*/ ctx[14];
    	validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
    	}

    	commentform = new CommentForm({
    			props: { showCheckbox: "false" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			create_component(commentform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			mount_component(commentform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*feed, timeAgo, childDisplayStatuses*/ 17) {
    				each_value_1 = /*feed_item*/ ctx[11].children_post_ids;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1$1, t, get_each_context_1$1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(commentform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(commentform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			destroy_component(commentform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(496:24) {#if feed_item.children_post_ids.length }",
    		ctx
    	});

    	return block;
    }

    // (497:28) {#each feed_item.children_post_ids as child_feed_item (child_feed_item) }
    function create_each_block_1$1(key_1, ctx) {
    	let first;
    	let feeditem;
    	let current;

    	feeditem = new FeedItem({
    			props: {
    				data: feed[/*child_feed_item*/ ctx[14]],
    				timeInstance: /*timeAgo*/ ctx[4],
    				customClasses: /*childDisplayStatuses*/ ctx[0][/*feed_item*/ ctx[11].id],
    				isChild: true
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(feeditem.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(feeditem, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const feeditem_changes = {};
    			if (dirty & /*childDisplayStatuses*/ 1) feeditem_changes.customClasses = /*childDisplayStatuses*/ ctx[0][/*feed_item*/ ctx[11].id];
    			feeditem.$set(feeditem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(feeditem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(feeditem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(feeditem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(497:28) {#each feed_item.children_post_ids as child_feed_item (child_feed_item) }",
    		ctx
    	});

    	return block;
    }

    // (483:16) {#each feed as feed_item (feed_item.id) }
    function create_each_block$l(key_1, ctx) {
    	let first;
    	let show_if = /*feed_item*/ ctx[11].parent_post_id === null && (/*tagName*/ ctx[3] === "" || /*feed_item*/ ctx[11]["tags"].includes(/*tagName*/ ctx[3]));
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block_1$k(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*tagName*/ 8) show_if = /*feed_item*/ ctx[11].parent_post_id === null && (/*tagName*/ ctx[3] === "" || /*feed_item*/ ctx[11]["tags"].includes(/*tagName*/ ctx[3]));

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*tagName*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$k(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$l.name,
    		type: "each",
    		source: "(483:16) {#each feed as feed_item (feed_item.id) }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1k(ctx) {
    	let t0;
    	let t1;
    	let main;
    	let mainheader;
    	let t2;
    	let div;
    	let current_block_type_index;
    	let if_block2;
    	let current;
    	let if_block0 = /*activePopup*/ ctx[2] === "create-new-audience-popup" && create_if_block_4$1(ctx);
    	let if_block1 = /*activePopup*/ ctx[2] === "select-audience-popup" && create_if_block_3$4(ctx);
    	mainheader = new MainHeader({ $$inline: true });
    	mainheader.$on("click", /*clickHandler*/ ctx[5]);
    	const if_block_creators = [create_if_block$z, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isUserProfileOpened*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			main = element("main");
    			create_component(mainheader.$$.fragment);
    			t2 = space();
    			div = element("div");
    			if_block2.c();
    			attr_dev(div, "class", "news-feed-wrapper svelte-isa7rv");
    			add_location(div, file$1i, 475, 4, 23707);
    			add_location(main, file$1i, 472, 0, 23653);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(mainheader, main, null);
    			append_dev(main, t2);
    			append_dev(main, div);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*activePopup*/ ctx[2] === "create-new-audience-popup") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*activePopup*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*activePopup*/ ctx[2] === "select-audience-popup") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*activePopup*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(mainheader.$$.fragment, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(mainheader.$$.fragment, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(main);
    			destroy_component(mainheader);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewsFeed", slots, []);
    	TimeAgo.addLocale(en);

    	// Getting app lang
    	const LANG = ({
    		"env": {
    			"isProd": false,
    			"CURRENT_LANG": "en",
    			"DOMAIN_FOR_REQUEST": "https://super.aladin.od.ua",
    			"GOOGLE_AUTHORIZATION_LINK": "/auth/redirect/google",
    			"LINKEDIN_AUTHORIZATION_LINK": "/auth/redirect/linkedin",
    			"GET_POST_ENDPOINT": "/community/posts/12",
    			"SET_NEW_POST_ENDPOINT": "/community/posts/13",
    			"SEARCH_POST_ENDPOINT": "/community/search/16",
    			"DELETE_POST_ENDPOINT": "/post/delete/15",
    			"CREATE_COMMENT_ENDPOINT": "/post/comment/1",
    			"DELETE_COMMENT_ENDPOINT": "/comment/delete/1",
    			"GET_USER_PROFILE_ENDPOINT": "/profile",
    			"GET_USER_PROFILE_EMAIL_ENDPOINT": "/profile/email",
    			"SEARCH_TAGS_ENDPOINT": "/community/tags/",
    			"LIST_TAGS_ENDPOINT": "/community/tags/12",
    			"LIST_CONTACTS_ENDPOINT": "/community/contacts/13",
    			"CREATE_COMMUNITY_ENDPOINT": "/community/0",
    			"GET_COMMUNITIES_ENDPOINT": "/community",
    			"GET_DRIVERS_ENDPOINT": "/export/drivers",
    			"GET_FIELDS_ENDPOINT": "/export/fields",
    			"PREVIEW_TAGS_ENDPOINT": "/export/preview",
    			"LOAD_PREVIEW_PARAMETERS_ENDPOINT": "/export/load",
    			"AUTOCOMPLETE_VALUES_ENDPOINT": "/export/values",
    			"EXPORT_RULES_ENDPOINT": "/export"
    		}
    	}).env.CURRENT_LANG;

    	// Status of showing Child posts
    	let childDisplayStatuses = [];

    	// Defining lang for date conversion
    	let timeFormatLang = "en-US";

    	switch (LANG) {
    		case "en":
    			timeFormatLang = "en-US";
    			break;
    		case "de":
    			timeFormatLang = "de-DE";
    			break;
    	}

    	console.log("timeFormatLang", timeFormatLang);

    	// Create formatter (English).
    	let timeAgo = new TimeAgo(timeFormatLang);

    	let isUserProfileOpened = false;
    	let activePopup = false;
    	let tagName = "";

    	const popupHandler = event => {
    		$$invalidate(2, activePopup = event.target.dataset.href);
    	};

    	/**
     * Popup external click handler
     * @param event
     */
    	const clickHandler = event => {
    		const ROLE = event.target.dataset.role;

    		//console.log('ROLE', ROLE);
    		switch (ROLE) {
    			case "popup-close":
    				$$invalidate(2, activePopup = false);
    				break;
    			case "create-new-audience-popup":
    				$$invalidate(2, activePopup = "create-new-audience-popup");
    				break;
    			case "select-audience-popup":
    				$$invalidate(2, activePopup = "select-audience-popup");
    				break;
    			case "open-create-new-audience-popup":
    				$$invalidate(2, activePopup = "create-new-audience-popup");
    				break;
    			case "open-profile":
    				$$invalidate(1, isUserProfileOpened = true);
    				break;
    			case "close-edit-profile":
    				$$invalidate(1, isUserProfileOpened = false);
    				break;
    		}
    	};

    	/**
     * Change child posts display status
     * @param event
     */
    	const displayChildHandler = event => {
    		$$invalidate(0, childDisplayStatuses[event.detail.parent_id] = event.detail.isChildShown, childDisplayStatuses);
    		console.log("showStatus", childDisplayStatuses);
    	};

    	const sortPostsByTagHandler = event => {
    		$$invalidate(3, tagName = event.detail?.tag_name);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<NewsFeed> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		feed,
    		MainHeader,
    		FeedItem,
    		CommentForm,
    		ModalWindow,
    		StepsNewAudience,
    		SelectAudience,
    		CreateNewAudience,
    		UserData,
    		TagsArea,
    		TimeAgo,
    		en,
    		LANG,
    		childDisplayStatuses,
    		timeFormatLang,
    		timeAgo,
    		isUserProfileOpened,
    		activePopup,
    		tagName,
    		popupHandler,
    		clickHandler,
    		displayChildHandler,
    		sortPostsByTagHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("childDisplayStatuses" in $$props) $$invalidate(0, childDisplayStatuses = $$props.childDisplayStatuses);
    		if ("timeFormatLang" in $$props) timeFormatLang = $$props.timeFormatLang;
    		if ("timeAgo" in $$props) $$invalidate(4, timeAgo = $$props.timeAgo);
    		if ("isUserProfileOpened" in $$props) $$invalidate(1, isUserProfileOpened = $$props.isUserProfileOpened);
    		if ("activePopup" in $$props) $$invalidate(2, activePopup = $$props.activePopup);
    		if ("tagName" in $$props) $$invalidate(3, tagName = $$props.tagName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		childDisplayStatuses,
    		isUserProfileOpened,
    		activePopup,
    		tagName,
    		timeAgo,
    		clickHandler,
    		displayChildHandler,
    		sortPostsByTagHandler
    	];
    }

    class NewsFeed extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewsFeed",
    			options,
    			id: create_fragment$1k.name
    		});
    	}
    }

    /* src/components/StepsWindow.svelte generated by Svelte v3.32.1 */

    const { console: console_1$8 } = globals;

    const file$1j = "src/components/StepsWindow.svelte";

    // (109:0) {#if currentStepWindow === 'login-step'}
    function create_if_block_21(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(109:0) {#if currentStepWindow === 'login-step'}",
    		ctx
    	});

    	return block;
    }

    // (110:4) <CenterBlock>
    function create_default_slot_19(ctx) {
    	let loginblock;
    	let current;
    	loginblock = new LoginBlock({ $$inline: true });
    	loginblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(loginblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loginblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loginblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loginblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loginblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(110:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (114:0) {#if currentStepWindow === 'sign-up-step'}
    function create_if_block_20(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(114:0) {#if currentStepWindow === 'sign-up-step'}",
    		ctx
    	});

    	return block;
    }

    // (115:4) <CenterBlock>
    function create_default_slot_18(ctx) {
    	let signupblock;
    	let current;
    	signupblock = new SignUpBlock({ $$inline: true });
    	signupblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(signupblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(signupblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(signupblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(signupblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(signupblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(115:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (119:0) {#if currentStepWindow === 'welcome-step'}
    function create_if_block_19(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(119:0) {#if currentStepWindow === 'welcome-step'}",
    		ctx
    	});

    	return block;
    }

    // (120:4) <CenterBlock>
    function create_default_slot_17(ctx) {
    	let welcomeblock;
    	let current;
    	welcomeblock = new WelcomeBlock({ $$inline: true });
    	welcomeblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(welcomeblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(welcomeblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(welcomeblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(welcomeblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(welcomeblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(120:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (124:0) {#if currentStepWindow === 'user-personality-step'}
    function create_if_block_18(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(124:0) {#if currentStepWindow === 'user-personality-step'}",
    		ctx
    	});

    	return block;
    }

    // (125:4) <CenterBlock>
    function create_default_slot_16(ctx) {
    	let userpersonalityblock;
    	let current;
    	userpersonalityblock = new UserPersonalityBlock({ $$inline: true });
    	userpersonalityblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(userpersonalityblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(userpersonalityblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(userpersonalityblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(userpersonalityblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(userpersonalityblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(125:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (129:0) {#if currentStepWindow === 'user-import-step'}
    function create_if_block_17(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(129:0) {#if currentStepWindow === 'user-import-step'}",
    		ctx
    	});

    	return block;
    }

    // (130:4) <CenterBlock>
    function create_default_slot_15(ctx) {
    	let importconfirmation;
    	let current;
    	importconfirmation = new ImportConfirmation({ $$inline: true });
    	importconfirmation.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(importconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(importconfirmation, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(importconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(importconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(importconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(130:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (134:0) {#if currentStepWindow === 'user-setup-step'}
    function create_if_block_16(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(134:0) {#if currentStepWindow === 'user-setup-step'}",
    		ctx
    	});

    	return block;
    }

    // (135:4) <CenterBlock>
    function create_default_slot_14(ctx) {
    	let usersetupblock;
    	let current;
    	usersetupblock = new UserSetupBlock({ $$inline: true });
    	usersetupblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(usersetupblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(usersetupblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(usersetupblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(usersetupblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(usersetupblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(135:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (139:0) {#if currentStepWindow === 'user-preview-step'}
    function create_if_block_15(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(139:0) {#if currentStepWindow === 'user-preview-step'}",
    		ctx
    	});

    	return block;
    }

    // (140:4) <CenterBlock>
    function create_default_slot_13(ctx) {
    	let userpreviewblock;
    	let current;
    	userpreviewblock = new UserPreviewBlock({ $$inline: true });
    	userpreviewblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(userpreviewblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(userpreviewblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(userpreviewblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(userpreviewblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(userpreviewblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(140:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (144:0) {#if currentStepWindow === 'user-community-step'}
    function create_if_block_14(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(144:0) {#if currentStepWindow === 'user-community-step'}",
    		ctx
    	});

    	return block;
    }

    // (145:4) <CenterBlock>
    function create_default_slot_12(ctx) {
    	let usercommunityblock;
    	let current;
    	usercommunityblock = new UserCommunityBlock({ $$inline: true });
    	usercommunityblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(usercommunityblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(usercommunityblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(usercommunityblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(usercommunityblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(usercommunityblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(145:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (149:0) {#if currentStepWindow === 'user-whichCRM-step'}
    function create_if_block_13(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(149:0) {#if currentStepWindow === 'user-whichCRM-step'}",
    		ctx
    	});

    	return block;
    }

    // (150:4) <CenterBlock>
    function create_default_slot_11(ctx) {
    	let userwhichcrmblock;
    	let current;
    	userwhichcrmblock = new UserWhichCRMBlock({ $$inline: true });
    	userwhichcrmblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(userwhichcrmblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(userwhichcrmblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(userwhichcrmblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(userwhichcrmblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(userwhichcrmblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(150:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (154:0) {#if currentStepWindow === 'user-setApiKey-step'}
    function create_if_block_12(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(154:0) {#if currentStepWindow === 'user-setApiKey-step'}",
    		ctx
    	});

    	return block;
    }

    // (155:4) <CenterBlock>
    function create_default_slot_10(ctx) {
    	let usersetapikeyblock;
    	let current;
    	usersetapikeyblock = new UserSetApiKeyBlock({ $$inline: true });
    	usersetapikeyblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(usersetapikeyblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(usersetapikeyblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(usersetapikeyblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(usersetapikeyblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(usersetapikeyblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(155:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (159:0) {#if currentStepWindow === 'willYouReadThisBlock-step'}
    function create_if_block_11(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(159:0) {#if currentStepWindow === 'willYouReadThisBlock-step'}",
    		ctx
    	});

    	return block;
    }

    // (160:4) <CenterBlock>
    function create_default_slot_9(ctx) {
    	let willyoureadthisblock;
    	let current;
    	willyoureadthisblock = new WillYouReadThisBlock({ $$inline: true });
    	willyoureadthisblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(willyoureadthisblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(willyoureadthisblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(willyoureadthisblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(willyoureadthisblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(willyoureadthisblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(160:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (164:0) {#if currentStepWindow === 'willYouReadThisBlock2-step'}
    function create_if_block_10(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(164:0) {#if currentStepWindow === 'willYouReadThisBlock2-step'}",
    		ctx
    	});

    	return block;
    }

    // (165:4) <CenterBlock>
    function create_default_slot_8(ctx) {
    	let willyoureadthisblock2;
    	let current;
    	willyoureadthisblock2 = new WillYouReadThisBlock2({ $$inline: true });
    	willyoureadthisblock2.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(willyoureadthisblock2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(willyoureadthisblock2, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(willyoureadthisblock2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(willyoureadthisblock2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(willyoureadthisblock2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(165:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (169:0) {#if currentStepWindow === 'shallWeStartBlock-step'}
    function create_if_block_9(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(169:0) {#if currentStepWindow === 'shallWeStartBlock-step'}",
    		ctx
    	});

    	return block;
    }

    // (170:4) <CenterBlock>
    function create_default_slot_7(ctx) {
    	let shallwestartblock;
    	let current;
    	shallwestartblock = new ShallWeStartBlock({ $$inline: true });
    	shallwestartblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(shallwestartblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(shallwestartblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shallwestartblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shallwestartblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(shallwestartblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(170:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (174:0) {#if currentStepWindow === 'createAccessRulesBlock-step'}
    function create_if_block_8(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(174:0) {#if currentStepWindow === 'createAccessRulesBlock-step'}",
    		ctx
    	});

    	return block;
    }

    // (175:4) <CenterBlock>
    function create_default_slot_6(ctx) {
    	let createaccessrulesblock;
    	let current;
    	createaccessrulesblock = new CreateAccessRulesBlock({ $$inline: true });
    	createaccessrulesblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(createaccessrulesblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(createaccessrulesblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(createaccessrulesblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(createaccessrulesblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(createaccessrulesblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(175:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (179:0) {#if currentStepWindow === 'addRulesBlock-step'}
    function create_if_block_7(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(179:0) {#if currentStepWindow === 'addRulesBlock-step'}",
    		ctx
    	});

    	return block;
    }

    // (180:4) <CenterBlock>
    function create_default_slot_5(ctx) {
    	let addrulesblock;
    	let current;
    	addrulesblock = new AddRulesBlock({ $$inline: true });
    	addrulesblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(addrulesblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(addrulesblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addrulesblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addrulesblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addrulesblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(180:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (184:0) {#if currentStepWindow === 'editRulesBlock-step'}
    function create_if_block_6(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(184:0) {#if currentStepWindow === 'editRulesBlock-step'}",
    		ctx
    	});

    	return block;
    }

    // (185:4) <CenterBlock>
    function create_default_slot_4(ctx) {
    	let editrulesblock;
    	let current;
    	editrulesblock = new EditRulesBlock({ $$inline: true });
    	editrulesblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(editrulesblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(editrulesblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editrulesblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editrulesblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(editrulesblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(185:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (189:0) {#if currentStepWindow === 'selectFieldsPull-step'}
    function create_if_block_5$1(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(189:0) {#if currentStepWindow === 'selectFieldsPull-step'}",
    		ctx
    	});

    	return block;
    }

    // (190:4) <CenterBlock>
    function create_default_slot_3(ctx) {
    	let selectfieldspull;
    	let current;
    	selectfieldspull = new SelectFieldsPull({ $$inline: true });
    	selectfieldspull.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(selectfieldspull.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectfieldspull, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectfieldspull.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectfieldspull.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectfieldspull, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(190:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (194:0) {#if currentStepWindow === 'addTags-step'}
    function create_if_block_4$2(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(194:0) {#if currentStepWindow === 'addTags-step'}",
    		ctx
    	});

    	return block;
    }

    // (195:4) <CenterBlock>
    function create_default_slot_2(ctx) {
    	let addtagsblock;
    	let current;
    	addtagsblock = new AddTagsBlock({ $$inline: true });
    	addtagsblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(addtagsblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(addtagsblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addtagsblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addtagsblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addtagsblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(195:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (199:0) {#if currentStepWindow === 'editTags-step'}
    function create_if_block_3$5(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(199:0) {#if currentStepWindow === 'editTags-step'}",
    		ctx
    	});

    	return block;
    }

    // (200:4) <CenterBlock>
    function create_default_slot_1$2(ctx) {
    	let edittagsblock;
    	let current;
    	edittagsblock = new EditTagsBlock({ $$inline: true });
    	edittagsblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(edittagsblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(edittagsblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(edittagsblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(edittagsblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(edittagsblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(200:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (204:0) {#if currentStepWindow === 'addAdmin-step'}
    function create_if_block_2$8(ctx) {
    	let centerblock;
    	let current;

    	centerblock = new CenterBlock({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(centerblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(centerblock, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const centerblock_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				centerblock_changes.$$scope = { dirty, ctx };
    			}

    			centerblock.$set(centerblock_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(centerblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(centerblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(centerblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(204:0) {#if currentStepWindow === 'addAdmin-step'}",
    		ctx
    	});

    	return block;
    }

    // (205:4) <CenterBlock>
    function create_default_slot$2(ctx) {
    	let addadminblock;
    	let current;
    	addadminblock = new AddAdminBlock({ $$inline: true });
    	addadminblock.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(addadminblock.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(addadminblock, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addadminblock.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addadminblock.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addadminblock, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(205:4) <CenterBlock>",
    		ctx
    	});

    	return block;
    }

    // (210:0) {#if currentStepWindow === 'StepsAdminWindow'}
    function create_if_block_1$l(ctx) {
    	let stepsadminwindow;
    	let current;
    	stepsadminwindow = new StepsAdminWindow({ $$inline: true });
    	stepsadminwindow.$on("goToStep", /*stepsHandler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			create_component(stepsadminwindow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(stepsadminwindow, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(stepsadminwindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(stepsadminwindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(stepsadminwindow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(210:0) {#if currentStepWindow === 'StepsAdminWindow'}",
    		ctx
    	});

    	return block;
    }

    // (214:0) {#if currentStepWindow === 'news-feed'}
    function create_if_block$A(ctx) {
    	let newsfeed;
    	let current;
    	newsfeed = new NewsFeed({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(newsfeed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newsfeed, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newsfeed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newsfeed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newsfeed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(214:0) {#if currentStepWindow === 'news-feed'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1l(ctx) {
    	let div;
    	let h2;
    	let t1;
    	let button0;
    	let t3;
    	let button1;
    	let t5;
    	let button2;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let t15;
    	let t16;
    	let t17;
    	let t18;
    	let t19;
    	let t20;
    	let t21;
    	let t22;
    	let t23;
    	let t24;
    	let t25;
    	let t26;
    	let t27;
    	let t28;
    	let if_block21_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*currentStepWindow*/ ctx[0] === "login-step" && create_if_block_21(ctx);
    	let if_block1 = /*currentStepWindow*/ ctx[0] === "sign-up-step" && create_if_block_20(ctx);
    	let if_block2 = /*currentStepWindow*/ ctx[0] === "welcome-step" && create_if_block_19(ctx);
    	let if_block3 = /*currentStepWindow*/ ctx[0] === "user-personality-step" && create_if_block_18(ctx);
    	let if_block4 = /*currentStepWindow*/ ctx[0] === "user-import-step" && create_if_block_17(ctx);
    	let if_block5 = /*currentStepWindow*/ ctx[0] === "user-setup-step" && create_if_block_16(ctx);
    	let if_block6 = /*currentStepWindow*/ ctx[0] === "user-preview-step" && create_if_block_15(ctx);
    	let if_block7 = /*currentStepWindow*/ ctx[0] === "user-community-step" && create_if_block_14(ctx);
    	let if_block8 = /*currentStepWindow*/ ctx[0] === "user-whichCRM-step" && create_if_block_13(ctx);
    	let if_block9 = /*currentStepWindow*/ ctx[0] === "user-setApiKey-step" && create_if_block_12(ctx);
    	let if_block10 = /*currentStepWindow*/ ctx[0] === "willYouReadThisBlock-step" && create_if_block_11(ctx);
    	let if_block11 = /*currentStepWindow*/ ctx[0] === "willYouReadThisBlock2-step" && create_if_block_10(ctx);
    	let if_block12 = /*currentStepWindow*/ ctx[0] === "shallWeStartBlock-step" && create_if_block_9(ctx);
    	let if_block13 = /*currentStepWindow*/ ctx[0] === "createAccessRulesBlock-step" && create_if_block_8(ctx);
    	let if_block14 = /*currentStepWindow*/ ctx[0] === "addRulesBlock-step" && create_if_block_7(ctx);
    	let if_block15 = /*currentStepWindow*/ ctx[0] === "editRulesBlock-step" && create_if_block_6(ctx);
    	let if_block16 = /*currentStepWindow*/ ctx[0] === "selectFieldsPull-step" && create_if_block_5$1(ctx);
    	let if_block17 = /*currentStepWindow*/ ctx[0] === "addTags-step" && create_if_block_4$2(ctx);
    	let if_block18 = /*currentStepWindow*/ ctx[0] === "editTags-step" && create_if_block_3$5(ctx);
    	let if_block19 = /*currentStepWindow*/ ctx[0] === "addAdmin-step" && create_if_block_2$8(ctx);
    	let if_block20 = /*currentStepWindow*/ ctx[0] === "StepsAdminWindow" && create_if_block_1$l(ctx);
    	let if_block21 = /*currentStepWindow*/ ctx[0] === "news-feed" && create_if_block$A(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			h2.textContent = "Temporary buttons for testing";
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "Login steps";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "Admin Panel";
    			t5 = space();
    			button2 = element("button");
    			button2.textContent = "Home Feed";
    			t7 = space();
    			if (if_block0) if_block0.c();
    			t8 = space();
    			if (if_block1) if_block1.c();
    			t9 = space();
    			if (if_block2) if_block2.c();
    			t10 = space();
    			if (if_block3) if_block3.c();
    			t11 = space();
    			if (if_block4) if_block4.c();
    			t12 = space();
    			if (if_block5) if_block5.c();
    			t13 = space();
    			if (if_block6) if_block6.c();
    			t14 = space();
    			if (if_block7) if_block7.c();
    			t15 = space();
    			if (if_block8) if_block8.c();
    			t16 = space();
    			if (if_block9) if_block9.c();
    			t17 = space();
    			if (if_block10) if_block10.c();
    			t18 = space();
    			if (if_block11) if_block11.c();
    			t19 = space();
    			if (if_block12) if_block12.c();
    			t20 = space();
    			if (if_block13) if_block13.c();
    			t21 = space();
    			if (if_block14) if_block14.c();
    			t22 = space();
    			if (if_block15) if_block15.c();
    			t23 = space();
    			if (if_block16) if_block16.c();
    			t24 = space();
    			if (if_block17) if_block17.c();
    			t25 = space();
    			if (if_block18) if_block18.c();
    			t26 = space();
    			if (if_block19) if_block19.c();
    			t27 = space();
    			if (if_block20) if_block20.c();
    			t28 = space();
    			if (if_block21) if_block21.c();
    			if_block21_anchor = empty();
    			add_location(h2, file$1j, 100, 4, 4244);
    			attr_dev(button0, "data-step", "login-step");
    			attr_dev(button0, "class", "svelte-tdgx4");
    			add_location(button0, file$1j, 101, 4, 4287);
    			attr_dev(button1, "data-step", "StepsAdminWindow");
    			attr_dev(button1, "class", "svelte-tdgx4");
    			add_location(button1, file$1j, 102, 4, 4386);
    			attr_dev(button2, "data-step", "news-feed");
    			attr_dev(button2, "class", "svelte-tdgx4");
    			add_location(button2, file$1j, 103, 4, 4491);
    			attr_dev(div, "class", "test svelte-tdgx4");
    			add_location(div, file$1j, 99, 0, 4221);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			append_dev(div, t1);
    			append_dev(div, button0);
    			append_dev(div, t3);
    			append_dev(div, button1);
    			append_dev(div, t5);
    			append_dev(div, button2);
    			insert_dev(target, t7, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t9, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t10, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t11, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t12, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t13, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, t14, anchor);
    			if (if_block7) if_block7.m(target, anchor);
    			insert_dev(target, t15, anchor);
    			if (if_block8) if_block8.m(target, anchor);
    			insert_dev(target, t16, anchor);
    			if (if_block9) if_block9.m(target, anchor);
    			insert_dev(target, t17, anchor);
    			if (if_block10) if_block10.m(target, anchor);
    			insert_dev(target, t18, anchor);
    			if (if_block11) if_block11.m(target, anchor);
    			insert_dev(target, t19, anchor);
    			if (if_block12) if_block12.m(target, anchor);
    			insert_dev(target, t20, anchor);
    			if (if_block13) if_block13.m(target, anchor);
    			insert_dev(target, t21, anchor);
    			if (if_block14) if_block14.m(target, anchor);
    			insert_dev(target, t22, anchor);
    			if (if_block15) if_block15.m(target, anchor);
    			insert_dev(target, t23, anchor);
    			if (if_block16) if_block16.m(target, anchor);
    			insert_dev(target, t24, anchor);
    			if (if_block17) if_block17.m(target, anchor);
    			insert_dev(target, t25, anchor);
    			if (if_block18) if_block18.m(target, anchor);
    			insert_dev(target, t26, anchor);
    			if (if_block19) if_block19.m(target, anchor);
    			insert_dev(target, t27, anchor);
    			if (if_block20) if_block20.m(target, anchor);
    			insert_dev(target, t28, anchor);
    			if (if_block21) if_block21.m(target, anchor);
    			insert_dev(target, if_block21_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", prevent_default(/*testStepsHandler*/ ctx[2]), false, true, false),
    					listen_dev(button1, "click", prevent_default(/*testStepsHandler*/ ctx[2]), false, true, false),
    					listen_dev(button2, "click", prevent_default(/*testStepsHandler*/ ctx[2]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentStepWindow*/ ctx[0] === "login-step") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_21(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t8.parentNode, t8);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "sign-up-step") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_20(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t9.parentNode, t9);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "welcome-step") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_19(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t10.parentNode, t10);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "user-personality-step") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_18(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t11.parentNode, t11);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "user-import-step") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_17(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t12.parentNode, t12);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "user-setup-step") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_16(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t13.parentNode, t13);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "user-preview-step") {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_15(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(t14.parentNode, t14);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "user-community-step") {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_14(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(t15.parentNode, t15);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "user-whichCRM-step") {
    				if (if_block8) {
    					if_block8.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block8, 1);
    					}
    				} else {
    					if_block8 = create_if_block_13(ctx);
    					if_block8.c();
    					transition_in(if_block8, 1);
    					if_block8.m(t16.parentNode, t16);
    				}
    			} else if (if_block8) {
    				group_outros();

    				transition_out(if_block8, 1, 1, () => {
    					if_block8 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "user-setApiKey-step") {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block9, 1);
    					}
    				} else {
    					if_block9 = create_if_block_12(ctx);
    					if_block9.c();
    					transition_in(if_block9, 1);
    					if_block9.m(t17.parentNode, t17);
    				}
    			} else if (if_block9) {
    				group_outros();

    				transition_out(if_block9, 1, 1, () => {
    					if_block9 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "willYouReadThisBlock-step") {
    				if (if_block10) {
    					if_block10.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block10, 1);
    					}
    				} else {
    					if_block10 = create_if_block_11(ctx);
    					if_block10.c();
    					transition_in(if_block10, 1);
    					if_block10.m(t18.parentNode, t18);
    				}
    			} else if (if_block10) {
    				group_outros();

    				transition_out(if_block10, 1, 1, () => {
    					if_block10 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "willYouReadThisBlock2-step") {
    				if (if_block11) {
    					if_block11.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block11, 1);
    					}
    				} else {
    					if_block11 = create_if_block_10(ctx);
    					if_block11.c();
    					transition_in(if_block11, 1);
    					if_block11.m(t19.parentNode, t19);
    				}
    			} else if (if_block11) {
    				group_outros();

    				transition_out(if_block11, 1, 1, () => {
    					if_block11 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "shallWeStartBlock-step") {
    				if (if_block12) {
    					if_block12.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block12, 1);
    					}
    				} else {
    					if_block12 = create_if_block_9(ctx);
    					if_block12.c();
    					transition_in(if_block12, 1);
    					if_block12.m(t20.parentNode, t20);
    				}
    			} else if (if_block12) {
    				group_outros();

    				transition_out(if_block12, 1, 1, () => {
    					if_block12 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "createAccessRulesBlock-step") {
    				if (if_block13) {
    					if_block13.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block13, 1);
    					}
    				} else {
    					if_block13 = create_if_block_8(ctx);
    					if_block13.c();
    					transition_in(if_block13, 1);
    					if_block13.m(t21.parentNode, t21);
    				}
    			} else if (if_block13) {
    				group_outros();

    				transition_out(if_block13, 1, 1, () => {
    					if_block13 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "addRulesBlock-step") {
    				if (if_block14) {
    					if_block14.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block14, 1);
    					}
    				} else {
    					if_block14 = create_if_block_7(ctx);
    					if_block14.c();
    					transition_in(if_block14, 1);
    					if_block14.m(t22.parentNode, t22);
    				}
    			} else if (if_block14) {
    				group_outros();

    				transition_out(if_block14, 1, 1, () => {
    					if_block14 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "editRulesBlock-step") {
    				if (if_block15) {
    					if_block15.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block15, 1);
    					}
    				} else {
    					if_block15 = create_if_block_6(ctx);
    					if_block15.c();
    					transition_in(if_block15, 1);
    					if_block15.m(t23.parentNode, t23);
    				}
    			} else if (if_block15) {
    				group_outros();

    				transition_out(if_block15, 1, 1, () => {
    					if_block15 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "selectFieldsPull-step") {
    				if (if_block16) {
    					if_block16.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block16, 1);
    					}
    				} else {
    					if_block16 = create_if_block_5$1(ctx);
    					if_block16.c();
    					transition_in(if_block16, 1);
    					if_block16.m(t24.parentNode, t24);
    				}
    			} else if (if_block16) {
    				group_outros();

    				transition_out(if_block16, 1, 1, () => {
    					if_block16 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "addTags-step") {
    				if (if_block17) {
    					if_block17.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block17, 1);
    					}
    				} else {
    					if_block17 = create_if_block_4$2(ctx);
    					if_block17.c();
    					transition_in(if_block17, 1);
    					if_block17.m(t25.parentNode, t25);
    				}
    			} else if (if_block17) {
    				group_outros();

    				transition_out(if_block17, 1, 1, () => {
    					if_block17 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "editTags-step") {
    				if (if_block18) {
    					if_block18.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block18, 1);
    					}
    				} else {
    					if_block18 = create_if_block_3$5(ctx);
    					if_block18.c();
    					transition_in(if_block18, 1);
    					if_block18.m(t26.parentNode, t26);
    				}
    			} else if (if_block18) {
    				group_outros();

    				transition_out(if_block18, 1, 1, () => {
    					if_block18 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "addAdmin-step") {
    				if (if_block19) {
    					if_block19.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block19, 1);
    					}
    				} else {
    					if_block19 = create_if_block_2$8(ctx);
    					if_block19.c();
    					transition_in(if_block19, 1);
    					if_block19.m(t27.parentNode, t27);
    				}
    			} else if (if_block19) {
    				group_outros();

    				transition_out(if_block19, 1, 1, () => {
    					if_block19 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "StepsAdminWindow") {
    				if (if_block20) {
    					if_block20.p(ctx, dirty);

    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block20, 1);
    					}
    				} else {
    					if_block20 = create_if_block_1$l(ctx);
    					if_block20.c();
    					transition_in(if_block20, 1);
    					if_block20.m(t28.parentNode, t28);
    				}
    			} else if (if_block20) {
    				group_outros();

    				transition_out(if_block20, 1, 1, () => {
    					if_block20 = null;
    				});

    				check_outros();
    			}

    			if (/*currentStepWindow*/ ctx[0] === "news-feed") {
    				if (if_block21) {
    					if (dirty & /*currentStepWindow*/ 1) {
    						transition_in(if_block21, 1);
    					}
    				} else {
    					if_block21 = create_if_block$A(ctx);
    					if_block21.c();
    					transition_in(if_block21, 1);
    					if_block21.m(if_block21_anchor.parentNode, if_block21_anchor);
    				}
    			} else if (if_block21) {
    				group_outros();

    				transition_out(if_block21, 1, 1, () => {
    					if_block21 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			transition_in(if_block8);
    			transition_in(if_block9);
    			transition_in(if_block10);
    			transition_in(if_block11);
    			transition_in(if_block12);
    			transition_in(if_block13);
    			transition_in(if_block14);
    			transition_in(if_block15);
    			transition_in(if_block16);
    			transition_in(if_block17);
    			transition_in(if_block18);
    			transition_in(if_block19);
    			transition_in(if_block20);
    			transition_in(if_block21);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			transition_out(if_block8);
    			transition_out(if_block9);
    			transition_out(if_block10);
    			transition_out(if_block11);
    			transition_out(if_block12);
    			transition_out(if_block13);
    			transition_out(if_block14);
    			transition_out(if_block15);
    			transition_out(if_block16);
    			transition_out(if_block17);
    			transition_out(if_block18);
    			transition_out(if_block19);
    			transition_out(if_block20);
    			transition_out(if_block21);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t7);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t9);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t10);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t11);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t12);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t13);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(t14);
    			if (if_block7) if_block7.d(detaching);
    			if (detaching) detach_dev(t15);
    			if (if_block8) if_block8.d(detaching);
    			if (detaching) detach_dev(t16);
    			if (if_block9) if_block9.d(detaching);
    			if (detaching) detach_dev(t17);
    			if (if_block10) if_block10.d(detaching);
    			if (detaching) detach_dev(t18);
    			if (if_block11) if_block11.d(detaching);
    			if (detaching) detach_dev(t19);
    			if (if_block12) if_block12.d(detaching);
    			if (detaching) detach_dev(t20);
    			if (if_block13) if_block13.d(detaching);
    			if (detaching) detach_dev(t21);
    			if (if_block14) if_block14.d(detaching);
    			if (detaching) detach_dev(t22);
    			if (if_block15) if_block15.d(detaching);
    			if (detaching) detach_dev(t23);
    			if (if_block16) if_block16.d(detaching);
    			if (detaching) detach_dev(t24);
    			if (if_block17) if_block17.d(detaching);
    			if (detaching) detach_dev(t25);
    			if (if_block18) if_block18.d(detaching);
    			if (detaching) detach_dev(t26);
    			if (if_block19) if_block19.d(detaching);
    			if (detaching) detach_dev(t27);
    			if (if_block20) if_block20.d(detaching);
    			if (detaching) detach_dev(t28);
    			if (if_block21) if_block21.d(detaching);
    			if (detaching) detach_dev(if_block21_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("StepsWindow", slots, []);
    	let currentStepWindow = "";
    	console.log("26.02.2021 22:03");

    	// Checking what page should we open on start app
    	(async () => {
    		// TODO: temp
    		$$invalidate(0, currentStepWindow = "news-feed");

    		// currentStepWindow = 'user-community-step';
    		// currentStepWindow = 'addTags-step';
    		//currentStepWindow = 'createAccessRulesBlock-step';
    		return;
    	})();

    	// Define what step should be displayed
    	const stepsHandler = event => {
    		$$invalidate(0, currentStepWindow = event.detail.step);
    	};

    	console.log("28.02.2021 12:03 v1");

    	// TODO: Need to remove before go to production
    	const testStepsHandler = event => {
    		$$invalidate(0, currentStepWindow = event.target.dataset.step);
    	};

    	console.log("ddd");
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<StepsWindow> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CenterBlock,
    		LoginBlock,
    		SignUpBlock,
    		WelcomeBlock,
    		UserPersonalityBlock,
    		UserCommunityBlock,
    		UserWhichCRMBlock,
    		UserSetApiKeyBlock,
    		UserSetupBlock,
    		UserPreviewBlock,
    		ImportConfirmation,
    		WillYouReadThisBlock,
    		WillYouReadThisBlock2,
    		ShallWeStartBlock,
    		CreateAccessRulesBlock,
    		AddRulesBlock,
    		EditRulesBlock,
    		SelectFieldsPull,
    		AddTagsBlock,
    		EditTagsBlock,
    		AddAdminBlock,
    		StepsAdminWindow,
    		makeRequestToBackend,
    		NewsFeed,
    		currentStepWindow,
    		stepsHandler,
    		testStepsHandler
    	});

    	$$self.$inject_state = $$props => {
    		if ("currentStepWindow" in $$props) $$invalidate(0, currentStepWindow = $$props.currentStepWindow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStepWindow, stepsHandler, testStepsHandler];
    }

    class StepsWindow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StepsWindow",
    			options,
    			id: create_fragment$1l.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.32.1 */
    const file$1k = "src/App.svelte";

    function create_fragment$1m(ctx) {
    	let div;
    	let stepswindow;
    	let current;
    	stepswindow = new StepsWindow({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(stepswindow.$$.fragment);
    			attr_dev(div, "id", "wrapper");
    			add_location(div, file$1k, 796, 0, 18653);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(stepswindow, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(stepswindow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(stepswindow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(stepswindow);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ StepsWindow });
    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$1m.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
